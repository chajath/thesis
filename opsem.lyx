#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1.5cm
\rightmargin 1.5cm
\bottommargin 1.5cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Simple Duck-Typing Language (SDTL)
\end_layout

\begin_layout Part
Operation Semantics
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Subsection
Constant 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
con ::= number | boolean
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
number ::= Z
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
boolean ::= tt | ff
\end_layout

\end_deeper
\begin_layout Subsection
Expressions
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Lexpr ::= ID | Expr .
 ID
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Expr ::= con | 
\emph on
global
\emph default
 | Lexpr | 
\emph on
this
\emph default
 | 
\emph on
input
\emph default
 | 
\emph on
new
\emph default
 Lexpr([Expr[,Expr]*]?) | Lexpr([Expr[,Expr]*]?) | Expr binop Expr | (Expr)
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
binop ::= + - * / > < ==
\end_layout

\end_deeper
\begin_layout Subsection
Statements
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= nil 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= S; S 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= Expr 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
output
\emph default
 Expr 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= LExpr = Expr
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
if
\emph default
(Expr) { S } 
\emph on
else
\emph default
 { S } 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
while
\emph default
(Expr) { S } 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
function
\emph default
 ID ([ID [, ID]*]?) { S }
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
return
\emph default
 Expr
\end_layout

\begin_layout Section
Static semantics
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Store = 
\begin_inset Formula $\left\langle Vars,ObjMemory,FunctionPointers,This\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Vars = ID 
\begin_inset Formula $\rightarrow$
\end_inset

 Value 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Value = 
\begin_inset Formula $\left(N|T|\left\langle OBJ_{n}\right\rangle |\left\langle FP_{n},\left[ID,\ldots\right],ID\rightarrow Value\right\rangle \right)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $V[\{ID=Value\}]=V\backslash\{ID\}\cup\{ID=Value\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
ObjMemory = 
\begin_inset Formula $\left\langle OBJ_{n}\right\rangle \rightarrow ID\rightarrow Value,n=0,1,2,...$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
FunctionPointers = 
\begin_inset Formula $\left\langle FP_{n}\right\rangle $
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Formula $\left\langle S,\left[ID,\ldots\right]\right\rangle ,n=0,1,2,\ldots$
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
FS(FP,
\begin_inset Formula $\left\langle FP_{n}\right\rangle $
\end_inset

) =
\begin_inset Formula $S$
\end_inset

 where
\begin_inset Formula $\left\langle FP_{n}\right\rangle \rightarrow\left\langle S,\left[ID,\ldots\right]\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Configuration = 
\begin_inset Formula $\left\langle S,Store\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
This = 
\begin_inset Formula $\left\langle OBJ_{n}\right\rangle $
\end_inset


\end_layout

\begin_layout Subsection
Program Invariant
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Global = 
\begin_inset Formula $\left\langle OBJ_{0}\right\rangle $
\end_inset


\end_layout

\begin_layout Section
Dynamic semantics
\end_layout

\begin_layout Subsection
Constant 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsection
Left Expressions
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle ID,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle V\left(ID\right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .ID,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle OM\left(\left\langle OBJ_{n}\right\rangle \right)\left(ID\right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle e.ID,s\right\rangle \rightarrow\left\langle e'.ID,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsection
Expressions 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left(e\right),s\right\rangle \rightarrow\left\langle e,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $<con_{0}\, binop\, con_{1},s>\rightarrow<con',s>$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $con'=con_{0}\,+|-|*|/|>|<|==\, con_{1}$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle e_{0}\, binop\, e,s\right\rangle \rightarrow\left\langle e_{0}'\, binop\, e,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle con\, binop\, e,s\right\rangle \rightarrow\left\langle con\, binop\, e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle this,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle T,\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle global,s\right\rangle \rightarrow\left\langle \left\langle OBJ_{0}\right\rangle ,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle ,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle OM\left(\left\langle OBJ_{n}\right\rangle \right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Function calls
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle FP_{n},[ID_{0}|IDs],C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\cup\left\{ ID_{0}=con\right\} \right\rangle \left(es\right),s\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
where 
\begin_inset Formula $C=ID\rightarrow Value$
\end_inset

 and 
\begin_inset Formula $C\left(ID_{0}\right)$
\end_inset

is undefined
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle \left\langle FP_{n},[ID_{0}|IDs],C\right\rangle \left(\left[e_{0}|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\right\rangle \left(\left[e_{0}'|es\right]\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle OBJ_{n}\right\rangle \right),\left\langle C,OM,FP,\phi\right\rangle \right\rangle \rightarrow^{*}\left\langle return\ con,\left\langle V',OM',FP',\phi\right\rangle \right\rangle }{\left\langle \left\langle FP_{n},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle con,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle OBJ_{n}\right\rangle \right),\left\langle C,OM,FP,\phi\right\rangle \right\rangle \rightarrow^{*}\left\langle nil,\left\langle V',OM',FP',\phi\right\rangle \right\rangle }{\left\langle \left\langle FP_{n},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle FP_{n},IDs,C\right\rangle \left(\phi\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\right\rangle ,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Method calls
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle le,s\right\rangle \rightarrow\left\langle le',s'\right\rangle }{\left\langle le(\left[e\right]),s\right\rangle \rightarrow\left\langle le'(\left[e\right]),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID_{0}|ID],C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID],C\cup\left\{ ID_{0}=con\right\} \right\rangle \left(es\right),s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID_{0}|ID],C\right\rangle \left(\left[e_{0}|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID],C\right\rangle \left(\left[e_{0}'|es\right]\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{OM\left(\left\langle OBJ_{n}\right\rangle \right)\left(ID\right)=\left\langle FP_{m},[ID']\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .ID\left(es\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\dot{\left\langle FP_{m},[ID'],\phi\right\rangle \left(es\right),\left\langle V,OM,FP,T\right\rangle }\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle FP_{m}\right\rangle \right),\left\langle C,OM,FP,\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle \rightarrow^{*}\left\langle return\ con,\left\langle V',OM',FP',\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle con,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle FP_{m}\right\rangle \right),\left\langle C,OM,FP,\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle \rightarrow^{*}\left\langle nil,\left\langle V',OM',FP',\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsection
Statements
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle return\ con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle con,s\right\rangle \rightarrow\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle con;S,s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle nil;S,s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle S_{0},s\right\rangle \rightarrow\left\langle S_{0}',s'\right\rangle }{\left\langle S_{0};S,s\right\rangle \rightarrow\left\langle S_{0}';S,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle return\ con;S,s\right\rangle \rightarrow\left\langle return\ con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Assignments
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle ID=Value,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V[\{ID=Value\}],OM,FP,T]\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .ID=Value,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM[\{OM(\left\langle OBJ_{n}\right\rangle )(ID)=Value\}],FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle {\displaystyle \frac{\left\langle le,s\right\rangle \rightarrow\left\langle le',s'\right\rangle }{\left\langle le=e,s\right\rangle \rightarrow\left\langle le'=e,s'\right\rangle }}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle ID=e,s\right\rangle \rightarrow\left\langle ID=e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .ID=e,s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .ID=e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsubsection

\lang english
Flow controls
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle {\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle if\ e\ then\ S,s\right\rangle \rightarrow\left\langle if\ e'\ then\ S,s'\right\rangle }}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle if\ tt\ then\ S,s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\left\langle if\ ff\ then\ S,s\right\rangle \rightarrow\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle if\ e\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle if\ e'\ then\ S\ else\ S_{0},s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle if\ tt\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\left\langle if\ ff\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle S_{0},s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle while\ e\ S,s\right\rangle \rightarrow\left\langle if\left(e\right)\ then\ S',s\right\rangle $
\end_inset

 where 
\begin_inset Formula $S'=S;while\ e\ S$
\end_inset


\end_layout

\begin_layout Part
Analysis
\end_layout

\begin_layout Section
Control Flow Analysis
\end_layout

\begin_layout Subsection
Numbering New Expressions and Function Declarations
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Expr ::= 
\emph on
new
\begin_inset Formula $_{n}$
\end_inset


\emph default
 Lexpr([Expr[,Expr]*]?) 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
function
\begin_inset Formula $_{n}$
\end_inset


\emph default
 ID ([ID [, ID]*]?) { Ss }
\end_layout

\begin_layout Subsection
Nodes and Edges
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
if
\emph default
(Expr) { S' }
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {succ(S), first(S')}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = {succ(S)} if S' not 
\emph on
return
\emph default
 
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
if
\emph default
(Expr) { S' } 
\emph on
else
\emph default
 { S'' } 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {first(S'), first(S'')}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = succ(S) if S' not 
\emph on
return
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S'')) = succ(S) if S'' not 
\emph on
return
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
while
\emph default
(Expr) { S' } 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {first(S'}, succ(S)}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = {S, succ(S)} if S' not 
\emph on
return
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
return
\emph default
 Expr
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Object Analysis
\end_layout

\begin_layout Standard
t = types = (number | boolean | OBJ
\begin_inset Formula $_{n}$
\end_inset

|FUNC
\begin_inset Formula $_{n,c}$
\end_inset

)
\end_layout

\begin_layout Standard
n_curried 
\begin_inset Formula $\in$
\end_inset

 [0, 
\begin_inset Formula $\propto$
\end_inset

)
\end_layout

\begin_layout Subsection
Program Invariants
\end_layout

\begin_layout Itemize
Functions = n
\begin_inset Formula $\mapsto$
\end_inset


\begin_inset Formula $\left\langle S,Params,Paramnames,EntryMemory,ReturnType,ReturnMemory,this\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
(nomenclature 
\begin_inset Formula $\phi=n\mapsto\left\langle S,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle $
\end_inset

)
\end_layout

\begin_layout Itemize
Params = 
\begin_inset Formula $\left[arg_{0}\mapsto\wp\left(types\right),\ldots\right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Set of types for each arguments to a function
\end_layout

\end_deeper
\begin_layout Itemize
Paramnames = 
\begin_inset Formula $\left[ID\right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
List of parameter names (used for constructing initial symbol table)
\end_layout

\end_deeper
\begin_layout Itemize
EntryMemory = 
\begin_inset Formula $n\mapsto Symmap$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
State of abstract memory when entering the function
\end_layout

\end_deeper
\begin_layout Itemize
ReturnType = 
\begin_inset Formula $\wp\left(types\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Set of possible return types
\end_layout

\end_deeper
\begin_layout Itemize
ReturnMemory=
\begin_inset Formula $n\mapsto Symmap$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
State of abstract memory when returning from the function
\end_layout

\end_deeper
\begin_layout Itemize
this = 
\begin_inset Formula $\wp\left(types\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Possible types of 
\emph on
this
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\emph on
global
\emph default
 
\begin_inset Formula $\mapsto$
\end_inset

OBJ
\begin_inset Formula $_{0}$
\end_inset


\end_layout

\begin_layout Subsection
Node Analysis
\end_layout

\begin_layout Subsubsection
Definitions
\end_layout

\begin_layout Itemize
Symmap = 
\begin_inset Formula $ID\mapsto\wp\left(types\right)$
\end_inset


\end_layout

\begin_layout Itemize
Absmem = 
\begin_inset Formula $OBJ_{n}\mapsto Symmap$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Env=\left\langle Symmap,Absmem,Functions,CurrentFunction\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
(nomenclature = 
\begin_inset Formula $\left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $S::Stmt\rightarrow Env\rightarrow\left\langle Env,Terminating\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Terminating is a boolean value.
 Terminating is true if the next statement to Stmt is unreachable.
\end_layout

\end_deeper
\begin_layout Standard
Expression can alter abstract memory and functions (possible types of arguments
 to functions, to be specific)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}::Expr\rightarrow Env\rightarrow\left\langle \left\langle Absmem,Functions\right\rangle ,type\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Statement analysis
\end_layout

\begin_layout Standard
An empty statement simply returns the environment given.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ nil\ \rho=\rho$
\end_inset


\end_layout

\begin_layout Standard
When consecutive statements are given, evaluate the first statement and
 pass on the resulting environment to the next statement if the statement
 is not returning (thus we have a composed function).
 Otherwise, we only evaluate the first statement.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[S_{1};S_{2}\right]\rho=$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $S\ S_{2}\ \rho'$
\end_inset

if 
\begin_inset Formula $term$
\end_inset

 is not true
\end_layout

\begin_layout Standard
\begin_inset Formula $S\ S_{1}$
\end_inset

 otherwise
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho',term\right\rangle =S\ S_{1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
When returning, we first evaluate expression being returned, and manipulate
 function pointers accordingly, by adding possible return types and return
 memory states to a current function.
 For abstract memory and symbols, we return a bottom set, so that when this
 branch is being merged, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[return\ e\right]\left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \bot,\bot,\phi\left[\gamma=\left\langle s,\pi,\nu,\eta,\tau\sqcup type,\mu\sqcup env',\theta\right\rangle \right],\gamma\right\rangle ,true\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle s,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle =\phi(\gamma)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle env',type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In an 
\emph on
if-else
\emph default
 statement, we first evaluate the expression and pass on a modified environment
 to each of statements, then unify resulting environments.
 This statement is deemed terminating only when both branches are terminating.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[if\left(e\right)S_{1}else\ S_{2}\right]\rho=\left\langle \rho_{1}\sqcup\rho_{2},term_{1}\wedge term_{2}\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \rho',t\right\rangle =\mathcal{E}\ e\ \rho$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \rho_{1},term_{1}\right\rangle =S\ S_{1}\rho'$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \rho_{2},term_{2}\right\rangle =S\ S_{2}\rho'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\emph on
if
\emph default
 statement is similar except the fact that we unify the resulting environment
 with the initial environment.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[if\left(e\right)S_{1}\right]\rho=\left\langle \rho'\sqcup\rho_{1},false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \rho',t\right\rangle =\mathcal{E}\ e\ \rho$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \rho_{1},term\right\rangle =S\ S_{1}\rho'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a simple assignment statement, we first evaluate the expression and take
 its updated environment, we then assign an id to possible set of types
 that a right expression can have.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[id=e\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma[id\mapsto t],\alpha',\phi',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,t\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a member assignment statement, we first evaluate the referred expression,
 then we evaluate right expression with updated environment, finally we
 add id pointing to possible types of right expression, to abstract memory
 entry of possible referred objects.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[e_{1}.id=e_{2}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma'',\alpha''\left[OBJ_{n}=OBJ_{n}\left[id\mapsto type'\right]\right]\mbox{for all}\ OBJ_{n}\in type,\phi'',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e_{1}\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle \alpha'',\phi''\right\rangle ,type'\right\rangle =\mathcal{E}\ e_{2}\ \left\langle \sigma',\alpha',\phi',\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a while statement, we first evaluate the expression, take the updated
 environment, then we recursively evaluate inner statement block with environmen
ts from its own evaluation.
 Then, we unify the resulting environment with the initial environment after
 expression evaluation, to cater for the scenario where the statement never
 runs.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[while(e)S_{1}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma\sqcup\sigma'',\alpha'\sqcup\alpha'',\phi,\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
whererec
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \sigma'',\alpha'',\phi'',\gamma\right\rangle =S\ S_{1}\ \left\langle \sigma\sqcup\sigma'',\alpha'\sqcup\alpha'',\phi',\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In an output statement, we evaluate expression and take the updated environment
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[output\ e\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma,\alpha',\phi',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
When we declare a new function, we just map the function name to a corresponding
 function number, with zero curried argument.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S\ \left[function_{n}\ id\left(ID*\right)S_{1}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma\left[id\mapsto\left\{ FUNC_{n,0}\right\} \right],\alpha,\phi,\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Expressions
\end_layout

\begin_layout Standard
Left expression analysis returns possible types
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{L}::Env\rightarrow\wp\left(type\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{L}\ \left[ID\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\sigma(ID)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{L}\ \left[e.ID\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =type$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ con\ \rho=\left\langle \rho,type\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $type=number\ \mbox{if}\ con\ \mbox{is a number}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $type=boolean\ \mbox{if}\ con\ \mbox{is a boolean value}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ global\ \rho=\left\langle \rho,OBJ_{0}\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ Lexpr\ \rho=\mathcal{L}\ Lexpr\ \rho$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ this\ \left\langle symmap,absmem,fps,cf\right\rangle =\left\langle \left\langle symmap,absmem,fps,cf\right\rangle ,this\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle s,param,returntype,this\right\rangle =fps(cf)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ input\ \rho=\left\langle \rho,number\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ \left[Lexpr\left(e_{1},e_{2},\cdots,e_{k}\right)\right]\ \left\langle symmap,absmem,fps,cf\right\rangle =$
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle symmap,absmem_{k},fps',cf\right\rangle ,returntypes\right\rangle \ \mbox{if}\ k+c=N\left(params_{k,n}\right)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle symmap,absmem_{k},fps',cf\right\rangle ,FP_{n,c+k}\right\rangle \mbox{otherwise}$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $FP_{n,c}=\mathcal{L}\ Lexpr\ \left\langle symmap,absmem,fps,cf\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle absmem_{1},fps_{1}\right\rangle ,type_{1}\right\rangle =\mathcal{E}\ e_{1}\ \left\langle symmap,absmem,fps,cf\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle absmem_{i},fps_{i}\right\rangle ,type_{i}\right\rangle =\mathcal{E}\ e_{i-1}\ \left\langle symmap,absmem_{i-1},fps_{i-1},cf\right\rangle ,\ i\in\mathbb{N},1<i\leq k$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle S_{k},\pi{}_{k},\nu{}_{k},\tau_{k},\theta_{k}\right\rangle =fps_{k}\left(n\right)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $fps'=fps_{k}\left[FP_{n}=\left\langle S_{k},params_{k}\left[arg_{c+j}=arg_{c+j}\sqcup type_{j},j\in\mathbb{N},1\le j\le k\right],paramnames_{k},returntype_{k},this_{k}\right\rangle \right]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{E}\ \left[new_{n}\ Lexpr\left(e_{1},e_{2},\cdots,e_{k}\right)\right]\ \left\langle symmap,absmem,fps,cf\right\rangle =\left\langle \left\langle symmap,absmem_{k},fps',cf\right\rangle ,this_{k,n}\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $FP_{n,c}=\mathcal{L}\ Lexpr\ \left\langle symmap,absmem,fps,cf\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle absmem_{1},fps_{1}\right\rangle ,type_{1}\right\rangle =\mathcal{E}\ e_{1}\ \left\langle symmap,absmem,fps,cf\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\left\langle \left\langle absmem_{i},fps_{i}\right\rangle ,type_{i}\right\rangle =\mathcal{E}\ e_{i-1}\ \left\langle symmap,absmem_{i-1},fps_{i-1},cf\right\rangle ,\ i\in\mathbb{N},1<i\leq k$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle S_{k,n},params_{k,n},paramnames_{k,n},entrymemory_{k,n},returntype_{k,n},this_{k,n}\right\rangle =fps_{k}\left(n\right)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $newparams=params_{k,n}\left[arg_{c+j}=arg_{c+j}\sqcup type_{j},j\in\mathbb{N},1\le j\le k\right]$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $fps'=fps_{k}\left[FP_{n}=\left\langle S_{k,n},newparams,paramnames_{k,n},returntype_{k,n},this_{k,n}\right\rangle \right]$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_body
\end_document
