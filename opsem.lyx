#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.5cm
\topmargin 1.5cm
\rightmargin 1.5cm
\bottommargin 1.5cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "backgroundcolor={\color{lightgray}},basicstyle={\footnotesize\ttfamily},breaklines=true,captionpos=b,extendedchars=true,numbers=left,numbersep=9pt,numberstyle={\footnotesize},showspaces=false,showstringspaces=false,showtabs=false,tabsize=2"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Inferring Class Structures of Duck-Typed Variables Through Static Code Analysis
\end_layout

\begin_layout Author
In-Ho Yi
\begin_inset Newline newline
\end_inset

 i.yi@student.unimelb.edu.au 
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstdefinelanguage{sdtl}{   
\end_layout

\begin_layout Plain Layout

keywords={new, true, false, function, return, if, while, else, output, input},
   
\end_layout

\begin_layout Plain Layout

keywordstyle=
\backslash
color{blue}
\backslash
bfseries,   
\end_layout

\begin_layout Plain Layout

ndkeywords={this},   
\end_layout

\begin_layout Plain Layout

ndkeywordstyle=
\backslash
color{darkgray}
\backslash
bfseries,   
\end_layout

\begin_layout Plain Layout

identifierstyle=
\backslash
color{black},   
\end_layout

\begin_layout Plain Layout

sensitive=false,   
\end_layout

\begin_layout Plain Layout

comment=[l]{
\backslash
#},   
\end_layout

\begin_layout Plain Layout

commentstyle=
\backslash
color{purple}
\backslash
ttfamily, }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{    language=sdtl,    backgroundcolor=
\backslash
color{lightgray},    extendedchars=true,    basicstyle=
\backslash
footnotesize
\backslash
ttfamily,    showstringspaces=false,    showspaces=false,    numbers=left,
    numberstyle=
\backslash
footnotesize,    numbersep=9pt,    tabsize=2,    breaklines=true,    showtabs=fa
lse,    captionpos=b }
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Contemporary dynamic-typing languages such as Python and ECMAScript utilise
 `duck-typing' as a way of allowing users to define and use classes on-the-fly.
 By allowing a programmer to dynamically create properties of variables,
 these languages allow a programmer to rapidly prototype models.
\end_layout

\begin_layout Standard
The aim of the proposed project is to apply static code analysis to infer
 class structures from the use of duck-typed variables.
\end_layout

\begin_layout Subsection
The Challenge of Analysing Duck-Typing Programs
\end_layout

\begin_layout Standard
In traditional OOP languages such as Java and C#, the task of statically
 analysing class structure is almost trivial.
 Programmers define the types and hierarchies in advance, and the declarations
 themselves are readily understandable by machine.
 There are tools available for translating a design diagram such as UML
 to a code stub, and vice versa.
\end_layout

\begin_layout Standard
Duck-typing languages, on the other hand, does not include a finite definition
 of a class structure.
 Consider the following declaration of class in Python:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Python"
inline false
status open

\begin_layout Plain Layout

from random import random 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class ExampleA:
\end_layout

\begin_layout Plain Layout

	def __init__(self):
\end_layout

\begin_layout Plain Layout

		self.someProperty = 'a'
\end_layout

\begin_layout Plain Layout

		if(random() > 0.5):             
\end_layout

\begin_layout Plain Layout

			self.otherProperty = 'b'     
\end_layout

\begin_layout Plain Layout

	def someMethod(self, a):
\end_layout

\begin_layout Plain Layout

		print(a) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a = ExampleA() 
\end_layout

\begin_layout Plain Layout

a.someMethod('Hello, world') 
\end_layout

\begin_layout Plain Layout

a.myProperty = 2 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def newMethod(b):
\end_layout

\begin_layout Plain Layout

	print(b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a.newMethod = newMethod 
\end_layout

\begin_layout Plain Layout

a.newMethod('Hello, world')
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Python class creation
\end_layout

\end_inset


\end_layout

\end_inset

There are several difficulties of statically analysing the present code.
 First, declarations of members are dynamic, and the type itself can even
 depend on a control flow.
 In case of class ExampleA, instances have 50% chance of having `otherProperty'
 as a member.
 
\end_layout

\begin_layout Standard
Second, after the initial creation of an instance, programmer can extend
 the class by declaring new members dynamically.
 `myProperty' and `newMethod' are declared in such manner.
\end_layout

\begin_layout Part
Simple Duck-Typing Language (SDTL)
\end_layout

\begin_layout Standard
We will define a toy language that we name Simple Duck-Typing Language (SDTL).
 The design goal is to come up with a largely subset of ECMAScript expressive
 enough to cover the topic without losing generality of the argument.
 The language features dynamic declaration of functions, primitive variables
 (int, bool) and objects (through 
\shape italic
new
\shape default
 keyword), to which a programmer can dynamically assign variables or functions
 to their properties.
\begin_inset Newline newline
\end_inset

SDTL does not allow explicit class definition, as in Python, or prototyping,
 as in ECMAScript.
 However, it is argued here that class definitions and prototypes can be
 normalised as a series of dynamic declaration.
\end_layout

\begin_layout Section
Type System of SDTL
\end_layout

\begin_layout Standard
There are two categories of types in SDTL: Primitive types and Reference
 types 
\end_layout

\begin_layout Subsection
Primitive types
\end_layout

\begin_layout Standard
As in languages like Java and C#, primitive types are analogous to non-pointer
 C types.
 Variables are generally created through a new assignment statement.
 Assigning a value into another variable would cause the value to be copied
 into a new location.
 When used as arguments to a function call, they will be passed by value.
 
\end_layout

\begin_layout Subsubsection
Boolean
\end_layout

\begin_layout Standard
Boolean values are either true or false.
 In addition to 
\shape italic
true
\shape default
 and 
\shape italic
false
\shape default
 keyword, resulting values of logical operations are also boolean.
 
\end_layout

\begin_layout Subsubsection
Number
\end_layout

\begin_layout Standard
Numbers are also primitive type.
 For numeric binary operators, it is expected that both expressions are
 in primitive number type.
 If either of them are not, then a run-time type error is thrown.
 
\end_layout

\begin_layout Subsection
Reference types
\end_layout

\begin_layout Standard
Both objects and functions are referred to via reference types.
 
\end_layout

\begin_layout Subsubsection
Objects
\end_layout

\begin_layout Standard
In SDTL, an object is consisted of a collection of members, which can be
 primitives, function points or objects.
 When a new object is created, the object is stored in a memory and a reference
 point to the memory is returned.
 Subsequent assignments of such value is all passed in as a reference.
 When used in a function call, such value is passed by reference.
 
\end_layout

\begin_layout Subsubsection
Function pointers
\end_layout

\begin_layout Standard
Functions are stored as function pointers.
 When a new function is declared, the code fragment is stored in the memory
 and its reference is associated with the name of the function.
 The function pointer then can be used like any other variables.
 SDTL does not allow method overloading, so a function pointer can be associated
 with one function only.
\end_layout

\begin_layout Section
Structure
\end_layout

\begin_layout Subsection
Constant 
\end_layout

\begin_layout Standard
A constant can either be a number or a boolean value.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
con ::= Number | Boolean
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Number ::= Z
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Boolean ::= tt | ff
\end_layout

\end_deeper
\begin_layout Subsection
Expressions
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Lexpr ::= ID | Expr .
 ID
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Expr ::= con | 
\emph on
global
\emph default
 | Lexpr | 
\emph on
this
\emph default
 | 
\emph on
input
\emph default
 | 
\emph on
new
\emph default
 Lexpr([Expr[,Expr]*]?) | Lexpr([Expr[,Expr]*]?) | Expr binop Expr | (Expr)
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
binop ::= + - * / > < ==
\end_layout

\end_deeper
\begin_layout Subsection
Statements
\end_layout

\begin_layout Standard
Statements are the essential elements of the program.
 First of all, a statement can be an empty string, making an empty input
 a valid program.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= nil 
\end_layout

\begin_layout Standard
Statement can also be a concatenation of statements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= S; S 
\end_layout

\begin_layout Standard
Statement can be an expression.
 An evaluated value, if there is one, will be discard.
 If a programmer chose to use this construct, the intention would be to
 use a side-effect of an expression evaluation, e.g.
 calling a database function to generate a side-effect.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= Expr
\end_layout

\begin_layout Standard
We define 
\shape italic
output
\shape default
 statement, with which a programmer can print out result of numeric evaluation
 to console.
 For the purpose of simplicity, we assume that only numeric expressions
 are printed.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
output
\emph default
 Expr 
\end_layout

\begin_layout Standard
We define an assignment statement.
 Here we make a distinction between left expression(LExpr) and expression(Expr).
 A left expression is an expression that is capable of designating a memory
 location, such as a symbol or a member of an object.
 Naturally, a left expression is a subset of an expression.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= LExpr = Expr
\end_layout

\begin_layout Standard
We introduce 
\shape italic
if
\shape default
 statement here.
 If the Expr evaluates to be a boolean TRUE, the first statement is executed,
 otherwise, else statement is executed (if given).
 Any Expr that does not evaluate to be a boolean value will give rise to
 a runtime error.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
if
\emph default
(Expr) { S }
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
if
\emph default
(Expr) { S } 
\emph on
else
\emph default
 { S } 
\end_layout

\begin_layout Standard

\shape italic
while
\shape default
 statement is also a standard one present in most C-like languages.
 If Expr evaluates to be a boolean TRUE, it will execute S and repeat from
 evaluating Expr again.
 An Expr that does not evaluate to be a boolean value will give rise to
 a runtime error.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
while
\emph default
(Expr) { S } 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
function
\emph default
 ID ([ID [, ID]*]?) { S }
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Stmt ::= 
\emph on
return
\emph default
 Expr
\end_layout

\begin_layout Subsection
Program
\end_layout

\begin_layout Standard
In SDTL, as in other scripting languages, a program is a list of statements.
 Formally,
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Program ::= Stmt
\end_layout

\begin_layout Part
Operation Semantics
\end_layout

\begin_layout Section
Static semantics
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Store = 
\begin_inset Formula $\left\langle Vars,ObjMemory,FunctionPointers,This\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Vars = ID 
\begin_inset Formula $\rightarrow$
\end_inset

 Value 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Value = 
\begin_inset Formula $\left(N|T|\left\langle OBJ_{n}\right\rangle |\left\langle FP_{n},\left[ID,\ldots\right],ID\rightarrow Value\right\rangle \right)$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $V[\{ID=Value\}]=V\backslash\{ID\}\cup\{ID=Value\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
ObjMemory = 
\begin_inset Formula $\left\langle OBJ_{n}\right\rangle \rightarrow ID\rightarrow Value,n=0,1,2,...$
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
FunctionPointers = 
\begin_inset Formula $\left\langle FP_{n}\right\rangle $
\end_inset


\begin_inset Formula $\rightarrow$
\end_inset


\begin_inset Formula $\left\langle S,\left[ID,\ldots\right]\right\rangle ,n=0,1,2,\ldots$
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
FS(FP,
\begin_inset Formula $\left\langle FP_{n}\right\rangle $
\end_inset

) =
\begin_inset Formula $S$
\end_inset

 where
\begin_inset Formula $\left\langle FP_{n}\right\rangle \rightarrow\left\langle S,\left[ID,\ldots\right]\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
Configuration = 
\begin_inset Formula $\left\langle S,Store\right\rangle $
\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
This = 
\begin_inset Formula $\left\langle OBJ_{n}\right\rangle $
\end_inset


\end_layout

\begin_layout Subsection
Program Invariant
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Global = 
\begin_inset Formula $\left\langle OBJ_{0}\right\rangle $
\end_inset


\end_layout

\begin_layout Section
Dynamic semantics
\end_layout

\begin_layout Subsection
Constant 
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsection
Left Expressions
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle ID,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle V\left(ID\right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .ID,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle OM\left(\left\langle OBJ_{n}\right\rangle \right)\left(ID\right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle e.ID,s\right\rangle \rightarrow\left\langle e'.ID,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsection
Expressions 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left(e\right),s\right\rangle \rightarrow\left\langle e,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $<con_{0}\, binop\, con_{1},s>\rightarrow<con',s>$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $con'=con_{0}\,+|-|*|/|>|<|==\, con_{1}$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle e_{0}\, binop\, e,s\right\rangle \rightarrow\left\langle e_{0}'\, binop\, e,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle con\, binop\, e,s\right\rangle \rightarrow\left\langle con\, binop\, e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle this,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle T,\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle global,s\right\rangle \rightarrow\left\langle \left\langle OBJ_{0}\right\rangle ,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle ,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle OM\left(\left\langle OBJ_{n}\right\rangle \right),\left\langle V,OM,FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Function calls
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle FP_{n},[ID_{0}|IDs],C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\cup\left\{ ID_{0}=con\right\} \right\rangle \left(es\right),s\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
where 
\begin_inset Formula $C=ID\rightarrow Value$
\end_inset

 and 
\begin_inset Formula $C\left(ID_{0}\right)$
\end_inset

is undefined
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle \left\langle FP_{n},[ID_{0}|IDs],C\right\rangle \left(\left[e_{0}|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\right\rangle \left(\left[e_{0}'|es\right]\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle OBJ_{n}\right\rangle \right),\left\langle C,OM,FP,\phi\right\rangle \right\rangle \rightarrow^{*}\left\langle return\ con,\left\langle V',OM',FP',\phi\right\rangle \right\rangle }{\left\langle \left\langle FP_{n},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle con,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle OBJ_{n}\right\rangle \right),\left\langle C,OM,FP,\phi\right\rangle \right\rangle \rightarrow^{*}\left\langle nil,\left\langle V',OM',FP',\phi\right\rangle \right\rangle }{\left\langle \left\langle FP_{n},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle FP_{n},IDs,C\right\rangle \left(\phi\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs,C\right\rangle ,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Object creation
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle new\ \left\langle FP_{n},[ID_{0}|IDs],C\right\rangle \left(\left[e_{0}|es\right]\right),s\right\rangle \rightarrow\left\langle new\ \left\langle FP_{n},IDs,C\right\rangle \left(\left[e_{0}'|es\right]\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle \left\langle FP_{n},IDs,C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle FP_{n},IDs',C'\right\rangle \left(es\right),s\right\rangle }{\left\langle new\ \left\langle FP_{n},IDs,C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle new\ \left\langle FP_{n},IDs',C'\right\rangle \left(es\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle OBJ_{n}\right\rangle \right),\left\langle C,OM,FP,\phi\right\rangle \right\rangle \rightarrow^{*}\left\langle nil,\left\langle V',OM',FP',T'\right\rangle \right\rangle }{\left\langle new\ \left\langle FP_{n},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle ,\left\langle V,OM'\left[n\mapsto T'\right],FP',T\right\rangle \right\rangle }}$
\end_inset

, 
\begin_inset Formula $n$
\end_inset

 is the next object number of 
\emph on
OM'
\end_layout

\begin_layout Subsubsection
Method calls
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle le,s\right\rangle \rightarrow\left\langle le',s'\right\rangle }{\left\langle le(\left[e\right]),s\right\rangle \rightarrow\left\langle le'(\left[e\right]),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID_{0}|ID],C\right\rangle \left(\left[con|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID],C\cup\left\{ ID_{0}=con\right\} \right\rangle \left(es\right),s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e_{0},s\right\rangle \rightarrow\left\langle e_{0}',s'\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID_{0}|ID],C\right\rangle \left(\left[e_{0}|es\right]\right),s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},[ID],C\right\rangle \left(\left[e_{0}'|es\right]\right),s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{OM\left(\left\langle OBJ_{n}\right\rangle \right)\left(ID\right)=\left\langle FP_{m},[ID']\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .ID\left(es\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .\dot{\left\langle FP_{m},[ID'],\phi\right\rangle \left(es\right),\left\langle V,OM,FP,T\right\rangle }\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle FP_{m}\right\rangle \right),\left\langle C,OM,FP,\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle \rightarrow^{*}\left\langle return\ con,\left\langle V',OM',FP',\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle con,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle FS\left(FP,\left\langle FP_{m}\right\rangle \right),\left\langle C,OM,FP,\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle \rightarrow^{*}\left\langle nil,\left\langle V',OM',FP',\left\langle OBJ_{n}\right\rangle \right\rangle \right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .\left\langle FP_{m},\phi,C\right\rangle \left(\phi\right),\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM',FP',T\right\rangle \right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsection
Statements
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle return\ con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle con,s\right\rangle \rightarrow\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle nil;S,s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle S_{0},s\right\rangle \rightarrow\left\langle S_{0}',s'\right\rangle }{\left\langle S_{0};S,s\right\rangle \rightarrow\left\langle S_{0}';S,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle return\ e;S,s\right\rangle \rightarrow\left\langle return\ e';S,s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle return\ con;S,s\right\rangle \rightarrow\left\langle return\ con,s\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Assignments
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle ID=Value,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V[\{ID=Value\}],OM,FP,T]\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle \left\langle OBJ_{n}\right\rangle .ID=Value,\left\langle V,OM,FP,T\right\rangle \right\rangle \rightarrow\left\langle nil,\left\langle V,OM[\{OM(\left\langle OBJ_{n}\right\rangle )(ID)=Value\}],FP,T\right\rangle \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle {\displaystyle \frac{\left\langle le,s\right\rangle \rightarrow\left\langle le',s'\right\rangle }{\left\langle le=e,s\right\rangle \rightarrow\left\langle le'=e,s'\right\rangle }}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle ID=e,s\right\rangle \rightarrow\left\langle ID=e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle \left\langle OBJ_{n}\right\rangle .ID=e,s\right\rangle \rightarrow\left\langle \left\langle OBJ_{n}\right\rangle .ID=e',s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Subsubsection

\lang english
Flow controls
\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle {\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle if\ e\ then\ S,s\right\rangle \rightarrow\left\langle if\ e'\ then\ S,s'\right\rangle }}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle if\ tt\ then\ S,s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\left\langle if\ ff\ then\ S,s\right\rangle \rightarrow\left\langle nil,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula ${\displaystyle \frac{\left\langle e,s\right\rangle \rightarrow\left\langle e',s'\right\rangle }{\left\langle if\ e\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle if\ e'\ then\ S\ else\ S_{0},s'\right\rangle }}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle if\ tt\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle S,s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\left\langle if\ ff\ then\ S\ else\ S_{0},s\right\rangle \rightarrow\left\langle S_{0},s\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle while\ e\ S,s\right\rangle \rightarrow\left\langle if\left(e\right)\ then\ S',s\right\rangle $
\end_inset

 where 
\begin_inset Formula $S'=S;while\ e\ S$
\end_inset


\end_layout

\begin_layout Part
Analysis
\end_layout

\begin_layout Section
Nodes and Edges
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
if
\emph default
(Expr) { S' }
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {succ(S), first(S')}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = {succ(S)} if S' not 
\emph on
return
\emph default
 
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
if
\emph default
(Expr) { S' } 
\emph on
else
\emph default
 { S'' } 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {first(S'), first(S'')}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = succ(S) if S' not 
\emph on
return
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S'')) = succ(S) if S'' not 
\emph on
return
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
while
\emph default
(Expr) { S' } 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = {first(S'}, succ(S)}
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
next(last(S')) = {S, succ(S)} if S' not 
\emph on
return
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
return
\emph default
 Expr
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
next(S) = 
\begin_inset Formula $\phi$
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Analysis
\end_layout

\begin_layout Standard
We define type in this analytic framework as thus
\end_layout

\begin_layout Standard
t = types = (number | boolean | OBJ
\begin_inset Formula $_{n}$
\end_inset

|FP
\begin_inset Formula $_{n,c}$
\end_inset

)
\end_layout

\begin_layout Standard
n_curried 
\begin_inset Formula $\in$
\end_inset

 [0, 
\begin_inset Formula $\propto$
\end_inset

)
\end_layout

\begin_layout Subsection
Program Invariants
\end_layout

\begin_layout Itemize
Functions = n
\begin_inset Formula $\mapsto$
\end_inset


\begin_inset Formula $\left\langle S,Params,Paramnames,EntryMemory,ReturnType,ReturnMemory,this\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
(nomenclature 
\begin_inset Formula $\phi=n\mapsto\left\langle S,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle $
\end_inset

)
\end_layout

\begin_layout Itemize
Params = 
\begin_inset Formula $\left[arg_{0}\mapsto\wp\left(types\right),\ldots\right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Set of types for each arguments to a function
\end_layout

\end_deeper
\begin_layout Itemize
Paramnames = 
\begin_inset Formula $\left[ID\right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
List of parameter names (used for constructing initial symbol tables for
 function entry points)
\end_layout

\end_deeper
\begin_layout Itemize
EntryMemory = 
\begin_inset Formula $n\mapsto Symmap$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
State of abstract memory when entering the function
\end_layout

\end_deeper
\begin_layout Itemize
ReturnType = 
\begin_inset Formula $\wp\left(types\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Set of possible return types
\end_layout

\end_deeper
\begin_layout Itemize
ReturnMemory=
\begin_inset Formula $n\mapsto Symmap$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
State of abstract memory when returning from the function
\end_layout

\end_deeper
\begin_layout Itemize
this = 
\begin_inset Formula $\wp\left(types\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Possible types of 
\emph on
this
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\emph on
global
\emph default
 
\begin_inset Formula $\mapsto$
\end_inset

OBJ
\begin_inset Formula $_{0}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{FP}_{0}\mapsto$
\end_inset

main function
\end_layout

\begin_layout Subsection
Program analysis
\end_layout

\begin_layout Standard
In analysing a program, first we traverse through the syntax tree and label
 following things.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Expr ::= 
\emph on
new
\begin_inset Formula $_{m}$
\end_inset


\emph default
 Lexpr([Expr[,Expr]*]?) 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
S ::= 
\emph on
function
\begin_inset Formula $_{n}$
\end_inset


\emph default
 ID ([ID [, ID]*]?) { Ss }
\end_layout

\begin_layout Standard
We also mark the entire program as a main function (function number 0).
\end_layout

\begin_layout Standard
Then, for each of the function declarations we encounter, we create an initial
 hypothesis.
\end_layout

\begin_layout Standard
\begin_inset Formula $\phi_{\bot}=n\mapsto\left\langle S_{n},\left\{ ID\mapsto\bot\right\} ,\left[ID\right],\left\{ OBJ_{m}\mapsto\bot\right\} ,\bot,\left\{ OBJ_{m}\mapsto\bot\right\} \bot,\bot\right\rangle $
\end_inset

where 
\begin_inset Formula $S_{n}$
\end_inset

is a body of function
\begin_inset Formula $_{n}$
\end_inset


\end_layout

\begin_layout Standard
We then perform a fixed point iteration over functions found in the program.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{P}\ \phi=_{\mbox{rec}}\phi\sqcup\phi_{0}\sqcup\phi_{1}\sqcup\phi_{2}\sqcup\cdots\sqcup\phi_{n}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\phi_{i}=\mathcal{F}\ i\ \phi,i\in\mathbb{N},0\le i\le n$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Function analysis
\end_layout

\begin_layout Standard
For each of the functions, we pass in parameter mapping as an initial symbol
 table, entry memory state as an initial abstract memory, current function
 pointers and a function number to evaluate function body.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{F}\ \gamma\ \phi_{0}=\phi$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle S_{0},\pi_{0},\nu_{0},\eta_{0},\tau_{0},\mu_{0},\theta_{0}\right\rangle =\phi_{0}\left(\gamma\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\mathcal{S}\ S_{0}\ \left\langle \pi_{0},\eta_{0},\phi_{0},\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Node Analysis
\end_layout

\begin_layout Subsubsection
Definitions
\end_layout

\begin_layout Itemize
Symmap = 
\begin_inset Formula $ID\mapsto\wp\left(types\right)$
\end_inset


\end_layout

\begin_layout Itemize
Absmem = 
\begin_inset Formula $OBJ_{n}\mapsto Symmap$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Env=\left\langle Symmap,Absmem,Functions,CurrentFunction\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
(nomenclature 
\begin_inset Formula $\left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $S::Stmt\rightarrow Env\rightarrow\left\langle Env,Terminating\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Terminating is a boolean value.
 Terminating is true if the next statement to Stmt is unreachable.
\end_layout

\end_deeper
\begin_layout Standard
Expression can alter abstract memory and functions (possible types of arguments
 to functions, to be specific)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}::Expr\rightarrow Env\rightarrow\left\langle \left\langle Absmem,Functions\right\rangle ,type\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Statement analysis
\end_layout

\begin_layout Standard
An empty statement simply returns the environment given.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ nil\ \rho=\rho$
\end_inset


\end_layout

\begin_layout Standard
When consecutive statements are given, evaluate the first statement and
 pass on the resulting environment to the next statement if the statement
 is not returning (thus we have a composed function).
 Otherwise, we only evaluate the first statement.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[S_{1};S_{2}\right]\rho=$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\mathcal{S}\ S_{2}\ \rho'$
\end_inset

if 
\begin_inset Formula $term$
\end_inset

 is not true
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{S}\ S_{1}$
\end_inset

 otherwise
\end_layout

\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho',term\right\rangle =\mathcal{S}\ S_{1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
When returning, we first evaluate expression being returned, and manipulate
 function pointers accordingly, by adding possible return types and return
 memory states to a current function.
 For abstract memory and symbols, we return a bottom set, so that when this
 branch is being merged, 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[\mathtt{return}\ e\right]\left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \bot,\bot,\phi\left[\gamma=\left\langle s,\pi,\nu,\eta,\tau\sqcup type,\mu\sqcup env',\theta\right\rangle \right],\gamma\right\rangle ,true\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle s,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle =\phi(\gamma)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle env',type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In an 
\emph on
if-else
\emph default
 statement, we first evaluate the expression and pass on a modified environment
 to each of statements, then unify resulting environments.
 This statement is deemed terminating only when both branches are terminating.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[if\left(e\right)S_{1}else\ S_{2}\right]\rho=\left\langle \rho_{1}\sqcup\rho_{2},term_{1}\wedge term_{2}\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho',t\right\rangle =\mathcal{E}\ e\ \rho$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho_{1},term_{1}\right\rangle =S\ S_{1}\rho'$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho_{2},term_{2}\right\rangle =S\ S_{2}\rho'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\emph on
if
\emph default
 statement is similar except the fact that we unify the resulting environment
 with the initial environment.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[if\left(e\right)S_{1}\right]\rho=\left\langle \rho'\sqcup\rho_{1},false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho',t\right\rangle =\mathcal{E}\ e\ \rho$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \rho_{1},term\right\rangle =S\ S_{1}\rho'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a simple assignment statement, we first evaluate the expression and take
 its updated environment, we then assign an id to possible set of types
 that a right expression can have.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[id=e\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma[id\mapsto t],\alpha',\phi',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,t\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a member assignment statement, we first evaluate the referred expression,
 then we evaluate right expression with updated environment, finally we
 add id pointing to possible types of right expression, to abstract memory
 entry of possible referred objects.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[e_{1}.id=e_{2}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma,\alpha''\left[OBJ_{n}=OBJ_{n}\left[id\mapsto type'\right]|OBJ_{n}\in type\right],\phi'',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e_{1}\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha'',\phi''\right\rangle ,type'\right\rangle =\mathcal{E}\ e_{2}\ \left\langle \sigma,\alpha',\phi',\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In a while statement, we first evaluate the expression, take the updated
 environment, then we recursively evaluate inner statement block with environmen
ts from its own evaluation.
 Then, we unify the resulting environment with the initial environment after
 expression evaluation, to cater for the scenario where the statement never
 runs.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[\mathtt{while}(e)S_{1}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma\sqcup\sigma'',\alpha'\sqcup\alpha'',\phi'',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
whererec
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \sigma'',\alpha'',\phi'',\gamma\right\rangle =\mathcal{S}\ S_{1}\ \left\langle \sigma\sqcup\sigma'',\alpha'\sqcup\alpha'',\phi'\sqcup\phi'',\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
In an output statement, we evaluate expression and take the updated environment
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[\mathtt{output}\ e\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma,\alpha',\phi',\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
When we declare a new function, we just map the function name to a corresponding
 function number, with zero curried argument.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{S}\ \left[\mathtt{function}_{n}\ id\left(ID*\right)S_{1}\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma\left[id\mapsto\left\{ FP_{n,0}\right\} \right],\alpha,\phi,\gamma\right\rangle ,false\right\rangle $
\end_inset


\end_layout

\begin_layout Subsubsection
Expressions
\end_layout

\begin_layout Standard
Left expression analysis returns possible types and updated environments
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathcal{L}::Env\rightarrow\left\langle \left\langle Absmem,Functions\right\rangle ,type\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
When an id is given, we simply 'look up' the ID from symbol table
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{L}\ \left[ID\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \alpha,\phi\right\rangle \sigma(ID)\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
When an expression is dereferenced, we first evaluate the expression, and
 for each of possible object types, we find a possible types of a member
 named ID
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{L}\ \left[e.ID\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \alpha',\phi'\right\rangle ,\bigsqcup\left\{ \alpha'\left(n\right)\left(ID\right)|OBJ_{n}\in type\right\} \sqcup\bot\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,type\right\rangle =\mathcal{E}\ e\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $n\in\left\{ n|OBJ_{n}\in type\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
When a constant is given, we simply return a type of such constant
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ number\ \rho=\left\langle \rho,\left\{ Number\right\} \right\rangle $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ boolean\ \rho=\left\langle \rho,\left\{ Boolean\right\} \right\rangle $
\end_inset


\end_layout

\begin_layout Standard
Global is always 
\begin_inset Formula $OBJ_{0}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ \mathtt{global}\ \rho=\left\langle \rho,\left\{ OBJ_{0}\right\} \right\rangle $
\end_inset


\end_layout

\begin_layout Standard
When left expression is given, we evaluate the expression
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ l\ \rho=\mathcal{L}\ l\ \rho$
\end_inset


\end_layout

\begin_layout Standard

\emph on
this
\emph default
 keyword refers to the 'this' type of the current function (
\begin_inset Formula $\gamma$
\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ \mathtt{this}\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma,\alpha,\phi,\gamma\right\rangle ,\theta\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
where
\end_layout

\begin_layout Standard
\begin_inset Formula $\left\langle S,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle =\phi(\gamma)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
A result of 
\emph on
input
\emph default
 expression is always a number
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ \mathtt{input}\ \rho=\left\langle \rho,\left\{ number\right\} \right\rangle $
\end_inset


\end_layout

\begin_layout Standard
For a function call, we first evaluate the left expression (1), then evaluate
 each of the expressions given as parameters, successively updating environments
 (2 and 3), then, for each of possible function types of the resulting types
 of (1), we update possible argument types of 
\begin_inset Formula $c+j^{\mbox{th}}$
\end_inset

argument in a function pointers (4 and 5).
 Resulting types are the union of return types of functions that are being
 called (i.e.
 functions where we provide exact number of parameters for the remaining
 non-curried parameter) and curried function pointers.
 Finally, we join resulting memory states to calculate the memory state
 after function call (6).
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ \left[l\left(e_{1},e_{2},\cdots,e_{k}\right)\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =$
\end_inset


\begin_inset Formula $\left\langle \left\langle \sigma,\alpha'',\phi'',\gamma\right\rangle ,\left\{ \tau_{n}|k+c=N\left(\nu_{k,n}\right)\right\} \cup\left\{ FP_{n,c+k}|k+c<N\left(\nu_{k,n}\right)\right\} \right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,FPS\right\rangle =\mathcal{L}\ l\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha_{1},\phi_{1}\right\rangle ,type_{1}\right\rangle =\mathcal{E}\ e_{1}\ \left\langle \sigma,\alpha',\phi',\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha_{i},\phi_{i}\right\rangle ,type_{i}\right\rangle =\mathcal{E}\ e_{i-1}\ \left\langle \sigma,\alpha_{i-1},\phi_{i-1},\gamma\right\rangle ,\ i\in\mathbb{N},1<i\leq k$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle S_{k,n},\pi{}_{k,n},\nu{}_{k,n},\eta_{k,n},\tau_{k,n},\mu_{k,n},\theta_{k,n}\right\rangle =\phi_{k}\left(n\right),\left\langle n,c\right\rangle \in\left\{ \left\langle n,c\right\rangle |FP_{n,c}\in FPS\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\phi''=\phi_{k}\left[n\mapsto\left\langle S_{k,n},\pi_{k,n}\left[arg_{c+j}\mapsto arg_{k_{c+j}}\sqcup type_{j},j\in\mathbb{N},1\le j\le k\right],\nu_{k,n},\eta_{k,n}\sqcup\alpha_{k,n},\tau_{k,n},\mu_{k,n},\theta_{k,n}\right\rangle \right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\mbox{for all}\ n$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $\alpha''=\alpha_{k}\sqcup\mu_{k,n}\mbox{ for all }n\in\left\{ n|k+c_{n}=N\left(\nu_{k,n}\right)\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Instantiation of an object is largely similar to the function call handling.
 Key differences are that we take the union of all possible 
\emph on
this
\emph default
 types of the function called, and we only take a function with all the
 parameters bound as a legitimate type of Lexpression.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}\ \left[\mathtt{new}_{n}\ l\left(e_{1},e_{2},\cdots,e_{k}\right)\right]\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\left\langle \left\langle \sigma,\alpha_{k}'',\phi'',\gamma\right\rangle ,\bigsqcup\theta_{k,n}\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
where
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha',\phi'\right\rangle ,FPS\right\rangle =\mathcal{L}\ l\ \left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha_{1},\phi_{1}\right\rangle ,type_{1}\right\rangle =\mathcal{E}\ e_{1}\ \left\langle \sigma,\alpha',\phi',\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\langle \alpha_{i},\phi_{i}\right\rangle ,type_{i}\right\rangle =\mathcal{E}\ e_{i-1}\ \left\langle \sigma,\alpha_{i-1},\phi_{i-1},\gamma\right\rangle ,\ i\in\mathbb{N},1<i\leq k$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle S_{k,n},\pi{}_{k,n},\nu{}_{k,n},\eta_{k,n},\tau_{k,n},\mu_{k,n},\theta_{k,n}\right\rangle =\phi_{k}\left(n\right),n\in\left\{ n|FP_{n,c}\in FPS,k+c=N\left(\tau_{k,n}\right)\right\} $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\phi''=\phi_{k}\left[n\mapsto\left\langle S_{k,n},\pi_{k,n}\left[arg_{c_{n}+j}\mapsto arg_{k_{c_{n}+j}}\sqcup type_{j},j\in\mathbb{N},1\le j\le k\right],\nu_{k,n},\eta_{k,n}\sqcup\alpha_{k,n},\tau_{k,n},\mu_{k,n},\theta_{k,n}\right\rangle \right]$
\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\mbox{for all}\ n$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $\alpha''=\alpha_{k}\sqcup\mu_{k,n}\mbox{ for all }n\in\left\{ n|k+c_{n}=N\left(\nu_{k,n}\right)\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Part
Correctness based on Operation Semantics (fail ☹)
\end_layout

\begin_layout Itemize
Recall that Vars : 
\begin_inset Formula $ID\rightarrow Value$
\end_inset

, Symmap : 
\begin_inset Formula $ID\rightarrow\wp\left(types\right)$
\end_inset


\end_layout

\begin_layout Itemize
Given Object Memory 
\begin_inset Formula $OM$
\end_inset

, Vars 
\begin_inset Formula $V$
\end_inset

, Abstract Memory 
\begin_inset Formula $\alpha$
\end_inset

 and Symmap 
\begin_inset Formula $\sigma$
\end_inset

, 
\begin_inset Formula $\left\langle V,OM\right\rangle \sqsubset\left\langle \sigma,\alpha,\phi\right\rangle $
\end_inset

 iff
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\forall s\in V:$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $number\in\sigma\left(s\right)$
\end_inset

when 
\begin_inset Formula $V\left(s\right)$
\end_inset

 is a number
\end_layout

\begin_layout Enumerate
\begin_inset Formula $bool\in\sigma\left(s\right)$
\end_inset

when 
\begin_inset Formula $V\left(s\right)$
\end_inset

 is a boolean value
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\exists j\in\left\{ j|OBJ_{j}\in\sigma\left(s\right)\right\} :\left\langle V\left(s\right),OM\right\rangle \sqsubset\left\langle OBJ_{j},\alpha\right\rangle $
\end_inset

when 
\begin_inset Formula $V\left(s\right)$
\end_inset

 is an object type (
\begin_inset Formula $\exists j$
\end_inset

 or 
\begin_inset Formula $\forall j$
\end_inset

?)
\end_layout

\begin_layout Enumerate
when 
\begin_inset Formula $V\left(s\right)$
\end_inset

 is a function type value 
\begin_inset Formula $\left\langle FP_{n},Args,C\right\rangle $
\end_inset

, 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\exists\left\langle m,c\right\rangle \in\left\{ \left\langle n,c\right\rangle |FP_{n,c}\in\alpha\left(s\right)\right\} :N\left(C\right)=c\wedge m=n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\forall i\in\mathbb{N},1\leq i\leq N\left(Args\right):\nu_{c+i}=Args_{i}$
\end_inset

 where 
\begin_inset Formula $\left\langle S,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle =\phi\left(n\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle C,OM\right\rangle \sqsubset\left\langle \pi,\alpha,\phi\right\rangle $
\end_inset

(may not necessarily be a desirable outcome)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Formula $\left\langle VM,OM,FP,T\right\rangle \sqsubset\left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset

 iff
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\left\langle VM,OM\right\rangle \sqsubset\left\langle \sigma,\alpha,\phi\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\left\langle \left\{ \mathtt{this}\mapsto T\right\} ,OM\right\rangle \sqsubset\left\langle \left\{ \mathtt{this}\mapsto\theta\right\} ,OM\right\rangle $
\end_inset

 where 
\begin_inset Formula $\left\langle S,\pi,\nu,\eta,\tau,\mu,\theta\right\rangle =\phi\left(\gamma\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
For all program state
\begin_inset Formula $\left\langle S,\left\langle VM,OM,FP,T\right\rangle \right\rangle $
\end_inset

occurring in the course of execution of an SDTL program P, there is a correspond
ing 
\begin_inset Formula $\left\langle \sigma,\alpha,\phi,\gamma\right\rangle =\mathcal{S}\ S\ \left\langle \sigma_{0},\alpha_{0},\phi_{0},\gamma_{0}\right\rangle $
\end_inset

 such that 
\begin_inset Formula $\left\langle VM,OM,FP,T\right\rangle \sqsubset\left\langle \sigma,\alpha,\phi,\gamma\right\rangle $
\end_inset


\end_layout

\begin_layout Part
Correctness (take 2)
\end_layout

\begin_layout Itemize
Order among supersets of values
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $v_{1}\preceq v_{2}$
\end_inset

 if 
\begin_inset Formula $v_{1}\subseteq v_{2}$
\end_inset

.
 Assume atomic values to be singleton sets for simplicity.
 E.g.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $20\preceq Number$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $True\preceq Boolean$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Given 
\begin_inset Formula $V=ID\rightarrow\wp\left(Value\right),OM=n\rightarrow\left(ID\rightarrow\wp\left(Value\right)\right)$
\end_inset

, 
\begin_inset Formula $\left\langle V_{1},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle V_{2},OM_{2}\right\rangle $
\end_inset

 if
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\forall ID\forall v\in V_{1}\left(ID\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $v\in Number\vee v\in Boolean\rightarrow V_{1}\left(ID\right)\preceq V_{2}\left(ID\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $v\in Object\rightarrow\left\langle V_{1}\left(v\right),OM_{1}\right\rangle \sqsubseteq_{D}\left\langle V_{2}\left(v\right),OM_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $v\in FunctionPointer\rightarrow$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left\langle FP_{n},C_{2}\right\rangle \in V_{2}\left(ID\right)\wedge$
\end_inset


\begin_inset Formula $\left\langle C_{1},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle C_{2},OM_{2}\right\rangle \wedge\left\langle C_{2},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle C_{1},OM_{2}\right\rangle $
\end_inset

 
\end_layout

\begin_layout Itemize
where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left\langle FP_{n},C_{1}\right\rangle =v$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
This works for acyclic graphs, but what about cyclic graphs?
\end_layout

\begin_layout Itemize
According to this definition, in the following programs, 
\begin_inset Formula $\left\langle V,OM\right\rangle $
\end_inset

 can be said to be equal, although graphically it is different.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a = new Object();
\end_layout

\begin_layout Plain Layout

a.self = a;
\end_layout

\begin_layout Plain Layout

b = new Object();
\end_layout

\begin_layout Plain Layout

b.self = b;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename abobj1.dot

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a = new Object();
\end_layout

\begin_layout Plain Layout

b = new Object();
\end_layout

\begin_layout Plain Layout

b.self = b;
\end_layout

\begin_layout Plain Layout

a.self = b;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename abobj2.dot

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle V_{1},OM_{1}\right\rangle =_{D}\left\langle V_{2},OM_{2}\right\rangle \mbox{if}_{\mbox{def}}$
\end_inset


\begin_inset Formula $\left\langle V_{1},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle V_{2},OM_{2}\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle V_{1},OM_{1}\right\rangle \sqsupseteq_{D}\left\langle V_{2},OM_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Itemize

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $\left\langle V_{1},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle V_{2},OM_{2}\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle V_{2},OM_{2}\right\rangle \sqsubseteq_{D}\left\langle V_{3},OM_{3}\right\rangle \implies\left\langle V_{1},OM_{1}\right\rangle \sqsubseteq_{D}\left\langle V_{3},OM_{3}\right\rangle $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
how?
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\left(\left\langle V,OM\right\rangle ,\sqsubseteq_{D}\right)$
\end_inset

 is a poset.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left(\wp\left(\left\langle V,OM\right\rangle \right),\sqsubseteq_{PD}\right)$
\end_inset

 is also a poset
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A\sqsubseteq_{PD}B$
\end_inset

 iff 
\begin_inset Formula $\forall a\in A\forall b\in B,a\sqsubseteq_{D}b$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Given 
\begin_inset Formula $\sigma=ID\rightarrow\wp\left(types\right),\alpha=n\rightarrow\left(ID\rightarrow\wp\left(types\right)\right)$
\end_inset

, 
\begin_inset Formula $\left\langle \sigma_{1},\alpha_{1}\right\rangle \sqsubseteq_{A}\left\langle \sigma_{2},\alpha_{2}\right\rangle $
\end_inset

 if
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\forall ID\forall t\in\sigma_{1}\left(ID\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $t=Number\vee t=Boolean\rightarrow t\in V_{2}\left(ID\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $t\in Object\rightarrow\left\langle \sigma_{1}\left(t\right),\alpha_{1}\right\rangle \sqsubseteq_{A}\left\langle \sigma_{2}\left(v\right),\alpha_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $t\in FunctionPointer\rightarrow$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $t\in\sigma_{2}\left(ID\right)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Similarly, 
\begin_inset Formula $\left(\wp\left(\left\langle \sigma,\alpha\right\rangle \right),\sqsubseteq_{PA}\right)$
\end_inset

 is a poset
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A\sqsubseteq_{PA}B$
\end_inset

 iff 
\begin_inset Formula $\forall a\in A\forall b\in B,a\sqsubseteq_{A}b$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $P:\wp\left(\left\langle VM,OM\right\rangle \right)\rightarrow\wp\left(\left\langle \sigma,\alpha\right\rangle \right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $P\left(D\right)=\left\{ a|a\in\left\langle \sigma,\alpha\right\rangle \forall d\in D,d\preceq_{p}a\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Q:\wp\left(\left\langle \sigma,\alpha\right\rangle \right)\rightarrow\wp\left(\left\langle VM,OM\right\rangle \right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Q\left(A\right)=\left\{ d|d\in\left\langle VM,OM\right\rangle \forall a\in A,d\preceq_{p}a\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left\langle VM,OM\right\rangle \preceq_{p}\left\langle \sigma,\alpha\right\rangle $
\end_inset

 if
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\forall ID\forall v\in V_{1}\left(ID\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $v\in Number\rightarrow Number\in\sigma\left(ID\right)$
\end_inset


\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $v\in Boolean\rightarrow Boolean\in\sigma\left(ID\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $v\in Object\rightarrow\left\langle V\left(v\right),OM\right\rangle \preceq_{p}\left\langle \sigma\left(v\right),\alpha\right\rangle $
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $v\in FunctionPointer\rightarrow\left\langle FP_{n},N\left(C\right)\right\rangle \in\sigma\left(ID\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
where
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\left\langle FP_{n},C\right\rangle =v$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
Then 
\begin_inset Formula $\left(P,Q\right)$
\end_inset

 forms a galois connection over 
\begin_inset Formula $\left(\sqsubseteq_{PD},\sqsubseteq_{PA}\right)$
\end_inset


\end_layout

\begin_layout Itemize
voilà
\end_layout

\end_body
\end_document
