#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass CRPITStyle
\begin_preamble
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{color}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\AtBeginDocument{\catcode`\_=8}

\newcommand{\dd}[1]{\llbracket#1\rrbracket}
\newcommand{\ds}[1]{\llbracket\left|#1\right|_s\rrbracket}
\newcommand{\de}[1]{\llbracket\left|#1\right|_e\rrbracket}

\newcommand{\bind}{\Yright}

\exhyphenpenalty=10000\hyphenpenalty=10000

\newcommand\conferencenameandplace{19th Computing: Australasian Theory Symposium (CATS 2013), Adelaide, Australia, January 2013}
\newcommand\volumenumber{xxx}
\newcommand\conferenceyear{2013}
\newcommand\editorname{Anthony Wirth}

\usepackage{hyperref}
\usepackage[all]{hypcap}
\end_preamble
\options fleqn
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement !t
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\small},comment={[l]{\#}},commentstyle={\color{purple}\ttfamily},frame=leftline,identifierstyle={\color{black}},keywords={new, function, return, if, while, else, output, input},keywordstyle={\bfseries\underline},ndkeywords={this, global, true, false},ndkeywordstyle={\bfseries},numbers=left,numbersep=10pt,numberstyle={\tiny},sensitive=false,tabsize=2,xleftmargin=20pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monadic Theory of Language Analysis and its Application in Type Analysis
 of Dynamic Language
\end_layout

\begin_layout Author
In-Ho Yi, Peter Schachte and Harald SÃ¸ndergaard
\begin_inset Newline newline
\end_inset

Department of Computing and Information Systems 
\begin_inset Newline newline
\end_inset

 The University of Melbourne, Victoria 3010, Australia 
\begin_inset Newline newline
\end_inset

 i.yi@student.unimelb.edu.au, schachte@unimelb.edu.au, harald@unimelb.edu.au
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
submittedstandard
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\st}[2]{\left|#1\right|_{s_{#2}}}
{#1_{\left[s#2\right]}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ex}[2]{\left|#1\right|_{e_{#2}}}
{#1_{\left[e#2\right]}}
\end_inset


\end_layout

\begin_layout Abstract
We present a novel approach in construction and formalisation of an analysis
 of a language, in which we formulate a polymorphic and parametric interpretatio
n of a language common to both denotational semantics and static analysis.
 We apply this in analysing a duck-typing, reflective and function currying
 language.
 We show the benefit of this new approach in term of its terseness and modularit
y, and a new research methodology in which we gradually build language features
 and analysis on top of a previous incarnation of the theory.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are two distinct needs for the development of the present work.
 First, there is a theoretician's need to have a simple and elegant way
 of presenting a formalised argument of a static analysis which enables
 one to focus on what is at the heart of the analysis - definitions of abstract
 domain and their relations to the concrete domain of a language semantics.
 Denotational semantics is a step towards such direction.
 In this paper we endeavour to further modularise the system to the point
 where formal presentation of semantics and analysis can share a common
 framework that mostly deals with linguistic aspects of a programming language.
\end_layout

\begin_layout Standard
Second, there is a practical need of analysing dynamic languages that are
 finding more popularity in recent years.
 Traditionally these languages were termed 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

 languages, as they were mainly used for automating tasks and processing
 strings.
 However, with the advent of Web environment, languages such as Perl and
 PHP gained popularity as languages for web application development.
 On a client side, web pages make heavy use of JavaScript, a dynamic typing
 language, to deliver dynamic contents to the browser.
 Recent years have seen an increasing use of JavaScript in a server side
 environment as well.
\end_layout

\begin_layout Standard
What these languages provide is an ability to rapidly prototype and validate
 application models in a real time REPL environment.
 Another strength comes from the fact that programmers do not need to have
 a class structure defined upfront.
 Rather, class structures and types of variables in general are dynamically
 built.
 This reduces an initial overhead of software design.
\end_layout

\begin_layout Standard
However, these features come at a cost.
 Lacking formal and static definition of type information makes dynamically
 typing languages harder to analyse.
 This difficulty causes several practical problems.
 
\end_layout

\begin_layout Itemize
As applications become more mature, more efforts are devoted to program
 unit testing or assertions to ensure type safety of systems.
 These extra overheads can sometimes outweigh the benefit of having a dynamicall
y typing language.
\end_layout

\begin_layout Itemize
Whereas programmers writing statically typed languages enjoy the abundance
 of development tools, choices of tools for aiding development of dynamically
 typed languages are limited, and lacking much of the power, largely due
 to the difficulty and sometimes infeasibility of conduct a type analysis.
\end_layout

\begin_layout Itemize
Not having a static type structure has a significant performance implication.
\end_layout

\begin_layout Standard
With these problems in mind, we design a model language that has a dynamism
 comparable to those in the aforementioned scripting languages, such as
 duck-typing, reflection and function currying.
 A notable omission is a closure scoping.
 However, allowing function currying gives enough expressive power to the
 language.
\end_layout

\begin_layout Standard
The two concerns are not distinct ones, but an interconnected dialectic.
 Theoretical need is there because of a difficulty of describing abstract
 and concrete meaning of dynamic languages which often allow side-effect
 causing, type-altering functions.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
On a theoretical side, denotational semantics is the starting point of our
 development of a theoretical system.
 The idea of incorporating monads in the denotational semantics is found
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998,Liang_Hudak:ESOP1996"

\end_inset

.
 Whereas these works modularise analytic framework by having multiple layers
 of monadic transformations, we instead parametrise the very definition
 of a program state.
 
\end_layout

\begin_layout Standard
Action semantics, as advanced in 
\begin_inset CommandInset citation
LatexCommand citet
key "Mosses1996TPA"

\end_inset

, shares the motivation that semantics ought to be pragmatic yet expressive
 enough to analyse a non-trivial feature-rich languages.
 While action semantics endeavour to devise a new semantics, we restrain
 ourself to the language of denotational semantics, and seek to devise a
 formalism whose idea is largely compatible with denotational semantics.
\end_layout

\begin_layout Standard
An idea of constructing formulae with parametric types can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "Wadler:1989:TF:99370.99404"

\end_inset

.
 The present work is a special application of the parametricity in the field
 of language semantics and analysis.
\end_layout

\begin_layout Standard
On the type analysis of dynamic languages, 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005,Guha:ESOP2011,Wrigstad:POPL2010"

\end_inset

 devise model languages and their semantics for the purpose of static analysis
 of dynamic languages.
 A major difference between them and the model language presented in this
 paper is that our model language is designed to capture the feature of
 real world languages that functions alter types through a side-effect causing
 statements.
 Similarities and differences of this work compared to the cited works are
 given as we encounter them in this paper.
\end_layout

\begin_layout Standard
Type analysis plays a crucial part in compiling scripting languages, mainly
 to improve performance.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ancona:2007:RST:1297081.1297091,Dufour:2006"

\end_inset

 design restricted versions of a scripting language so that a static inference
 of types can be performed.
 Some techniques employed in those projects can also be found in this paper,
 the use of allocation sites as static references is an example.
\end_layout

\begin_layout Standard
An important use case of functions in dynamic typing language is 
\begin_inset Quotes eld
\end_inset

mixin
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand cite
key "Bracha:1990:MI:97946.97982"

\end_inset

) functions, where, by passing argument to such function the variable, the
 object is extended with extra methods.
 There are model languages and formalisations of mixin functions (
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Vub-prog-tr96aformalisation"

\end_inset

).
 Where those works seek to find a functional models for mixins, we model
 a language with side-effect causing functions that is expressive enough
 to program a mixin inheritance.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Jensen:SAS2009"

\end_inset

 built a feature-complete analyser for JavaScript language.
 Our work can be progressed further to become a theoretical counterpart
 of the analyser.
 Furthermore, such attempt at formalising the analysis might pave a way
 for a further refinement and improvement.
\end_layout

\begin_layout Section
Analytic framework
\end_layout

\begin_layout Standard
We first describe a monadic framework for language analysis.
 In this section we produce a particular monadic construct, specifically
 designed for the purpose of analysis.
 We then introduce polymorphic auxiliary functions that are useful in expending
 theories in a modular manner.
\end_layout

\begin_layout Subsection
Monad
\end_layout

\begin_layout Standard
We define the monadic constructions.
 We define a type constructor 
\begin_inset Formula $M$
\end_inset

 and a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Type constructor
\end_layout

\end_inset

 Type constructor 
\begin_inset Formula $M_{E}$
\end_inset

 and 
\begin_inset Formula $M_{S}$
\end_inset

 gives the following polymorphic type.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
M_{E}\ a & = & \beta\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)\\
M_{S} & = & \beta\rightarrow State\rightarrow\wp\left(State\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\beta$
\end_inset

 is a program-wide invariant.
 As we shall see in the next section, having a program-wide invariant in
 this formula is vital in modelling function calls in a program.
\end_layout

\begin_layout Definition
Note that we are essentially modelling a non-deterministic state transformation.
 Allowing non-determinism helps (or enables) defining abstract interpretation
 of a language in the exact same framework on which concrete interpretation
 is defined.
\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Bind operator
\end_layout

\end_inset

We define a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M_{E}\ a\rightarrow\left(a\rightarrow M_{E}\ b\right)\rightarrow M_{E}\ b$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
T\ \bind\ U & = & \lambda f,s.\mathbf{let}\ S=T\ f\ s\ \mathbf{in}\\
 &  & \underset{\left\langle s',a\right\rangle \in S}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s'\right)\\
\mbox{then}\ \left\{ \left\langle s',\bot\right\rangle \right\} \\
\mbox{else}\ U\ a\ f\ s'
\end{gathered}
\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M_{E}\ a\rightarrow\left(a\rightarrow M_{S}\right)\rightarrow M_{S}$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
T\ \bind\ U & = & \lambda f,s.\mathbf{let}\ S=T\ f\ s\ \mathbf{in}\\
 &  & \underset{\left\langle s',a\right\rangle \in S}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s'\right)\\
\mbox{then}\ \left\{ s'\right\} \\
\mbox{else}\ U\ a\ f\ s'
\end{gathered}
\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M_{S}\rightarrow M_{S}\rightarrow M_{S}$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
T\ \bind\ U & = & \lambda f,s.\mathbf{let}\ S=T\ f\ s\ \mathbf{in}\\
 &  & \underset{s'\in S}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s'\right)\ \\
\mbox{then}\ \left\{ s'\right\} \ \\
\mbox{else}\ U\ f\ s'
\end{gathered}
\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we define monadic functions in order to provide modularity.
 For example, if a particular parametrised operation takes a state but only
 produces a value, it would be redundant to include a state as a part of
 returning type, to match the definition of monadic binding.
 In such case, we take a function that returns only a value, then lift such
 function to be used in the monadic binding.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Monadic functions
\end_layout

\end_inset

We define following auxiliary functions to incorporate non-monadic functions
 as a part of monadic transformation:
\end_layout

\begin_deeper
\begin_layout Itemize
(return for 
\begin_inset Formula $M_{E}$
\end_inset

) 
\begin_inset Formula $I_{A}$
\end_inset

 is an identity state transformer that takes a constant and lifts it to
 an identity state transformer with the constant as a return value
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $I_{A}:a\rightarrow M_{E}\ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I_{A}\ v=\lambda f,r.\left\{ \left\langle r,v\right\rangle \right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
(lift for 
\begin_inset Formula $M_{E}$
\end_inset

) 
\begin_inset Formula $I_{V}$
\end_inset

 lifts a function that takes a state and returns a value to a monadic function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $I_{V}:\left(State\rightarrow a\right)\rightarrow M_{E}\ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I_{V}\ t=\lambda f,r.\left\langle \left\{ \left\langle r,t\ r\right\rangle \right\} ,\phi\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
(unit operation for 
\begin_inset Formula $M_{S}$
\end_inset

) 
\begin_inset Formula $\mathtt{noop}$
\end_inset

 is a function that does nothing.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\mathtt{noop}=\lambda x.\left\{ x\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Polymorphic transformers
\end_layout

\end_inset

 We define following polymorphic transformers that takes a monadic operators
 defined for a subspace and transforms into an operator at a higher domain,
 where traces of transformations at a subspace is preserved while other
 orthogonal components remain identical.
 
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\Upsilon & : & \left(A\rightarrow A\right)\rightarrow\left(B\rightarrow B\right)\\
\Psi & : & \left(A\rightarrow A\times a\right)\rightarrow\left(B\rightarrow B\times a\right)\\
\Theta & : & \left(A\rightarrow a\right)\rightarrow\left(B\rightarrow a\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
where 
\begin_inset Formula $A$
\end_inset

 is a subspace of 
\begin_inset Formula $B$
\end_inset

.
\end_layout

\begin_layout Definition
Another commonly occurring pattern is that functions often return a singleton.
 We define a function that takes a function returning a value and lifts
 it to be a function that returns a singleton set.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\Gamma & : & \left(A\rightarrow B\right)\rightarrow\left(A\rightarrow\wp\left(B\right)\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
We compose this function with the other transformers.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\bar{\Upsilon} & = & \Gamma\circ\Upsilon\\
\bar{\Psi} & = & \Gamma\circ\Psi\\
\bar{\Theta} & = & \Gamma\circ\Theta
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We now have monadic constructs and auxiliary functions to describe a semantic
 functions of the model language.
 We can proceed to define following semantic functions of the language.
\end_layout

\begin_layout Section
Language Analysis
\end_layout

\begin_layout Subsection
Augmented syntax tree
\end_layout

\begin_layout Standard
We use syntax nodes as references to various items constituting program
 environment.
 For that purpose, we define the following syntactic nodes and unique identifier
 spaces.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Stmt$
\end_inset

 is a statement node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Expr$
\end_inset

 is an expression node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $LExpr$
\end_inset

 is a left-expression node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Sid$
\end_inset

 is a statement id.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Eid$
\end_inset

 is an expression id.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $id$
\end_inset

 is an alphaneumeric identifier.
\end_layout

\begin_layout Standard
We define following auxiliary functions to describe the use of the augmented
 values.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{stmt} & : & Sid\rightarrow Stmt\\
\mathtt{param} & : & Sid\rightarrow\left[id\right]\\
\mathtt{arity} & : & Sid\rightarrow\mathbb{N}\cup\left\{ 0\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Note that we use an sid of a function declaration statement as a reference
 point for the function defined.
 
\begin_inset Formula $\mathtt{param}$
\end_inset

 and 
\begin_inset Formula $\mathtt{arity}$
\end_inset

 functions take such sid and returns a list of parameter names and the arity
 of the function.
\end_layout

\begin_layout Standard
We write 
\begin_inset Formula $\ds{S}$
\end_inset

 to mean a statement 
\begin_inset Formula $S$
\end_inset

 with sid 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
Semantic functions
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semantic functions
\end_layout

\end_inset

The analytic framework contains following semantic functions.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
F & = & Sid\rightarrow State\rightarrow\wp\left(State\right)\\
\mathcal{S} & : & Stmt\rightarrow F\rightarrow State\rightarrow\wp\left(State\right)\\
\mathcal{E} & : & Expr\rightarrow F\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)\\
\mathcal{L} & : & LExpr\rightarrow F\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 functions are semantics functions for statements, expressions and left
 expressions, respectively.
 
\begin_inset Formula $F$
\end_inset

 is a function that models functions in a program, given the 
\begin_inset Formula $Sid$
\end_inset

 of a function declaration site, it gives a state transformer.
 Note that in this picture a function 
\begin_inset Quotes eld
\end_inset

returns
\begin_inset Quotes erd
\end_inset

 a value by giving a state transformation.
 Incorporating such concept as a return value in a 
\begin_inset Formula $State$
\end_inset

 itself provides a greater flexibility in describing the effects of executing
 a statement or an expression at a particular program point.
\end_layout

\begin_layout Section
Model language
\end_layout

\begin_layout Subsection
Procedural language
\end_layout

\begin_layout Standard
We start off with a procedural language with C-like syntax.
 Notably, this language supports higher-order functions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<con> ::= Number | Boolean
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= <con> | <Lexpr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Expr> <binop> <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  `(' <Expr> `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<binop> ::= `+' | `-' | `*' | `/' | `>' | `<' | `=='
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= nil | <Stmt> `;' <Stmt> | <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `output' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt <LExpr> `=' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}' `else' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `while' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `function' ID `(' [ID [, ID]*]? `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `return' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Semantic functions for the language is defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semantic"

\end_inset

.
 We use auxiliary functions 
\begin_inset Formula $\mathtt{evalParam}$
\end_inset

 and 
\begin_inset Formula $\mathtt{call}$
\end_inset

 to describe a function call.
 These functions are defined as following:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{call}\left(n,p\right) & = & \lambda f,\rho.\left\{ \bar{\kappa}\ \rho\ \rho'\mid\rho'\in S\right\} \ \mbox{where}\\
 &  & S=f\ n\ \left(\kappa\ \rho\ p\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathtt{evalParam}:\left[Expr\right]\times\left[a\right]\times F\times State\rightarrow\\
\wp\left(State\times\left[a\right]\right)\\
\mathtt{evalParam}\ \phi\ ps\ f\ \rho=\left\langle \rho,ps\right\rangle \\
\mathtt{evalParam}\ \left[\dd{\ex E{}}\mid Exprs\right]\ ps\ f\ \rho=\\
\underset{\left\langle \rho',con\right\rangle \in S}{\bigcup}\left\{ \mathtt{evalParam}\ Exprs\ \left[ps\mid con\right]\ f\ \rho'\right\} \\
\ \ \mbox{where}S=\mathcal{E}\ \dd{\ex E{}}\ f\ \rho
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & F & = & Y\lambda f.\lambda n.\mathcal{S}\ \dd{\mathtt{Stmt}\left(n\right)}\ n\ f\\
 & \mathcal{S}\ds{\epsilon} & = & \mathtt{noop}\\
 & \mathcal{S}\ds{\st{S_{1}}1;\st{S_{2}}2} & = & \left(\begin{aligned}\mathcal{S}\ \dd{\st{S_{1}}1} & \bind\mathcal{S}\ \dd{\st{S_{2}}2}\end{aligned}
\right)\\
 & \mathcal{S}\ds{\mathtt{return}\ \ex E1} & = & \left(\mathcal{E}\ \dd{\ex E1}\right)\\
 & \mathcal{S}\ds{\mathtt{if}\left(\ex E1\right)\st{S_{1}}1} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex E1} & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ \dd{\st{S_{1}}1},\mathtt{noop}\right)
\end{aligned}
\right)\\
 & \mathcal{S}\ds{\mathtt{if}\left(\ex E1\right)\st{S_{1}}1\mathtt{else}\st{S_{2}}2} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex E1} & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ \dd{\st{S_{1}}1},\mathcal{S}\ \dd{\st{S_{1}}1}\right)
\end{aligned}
\right)\\
 & \mathcal{S}\ds{id=\ex E1} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex e1} & \bind\lambda v.\mathtt{asg}\left(id,v\right)\end{aligned}
\right)\\
 & \mathcal{S}\ds{\mathtt{while}\left(\ex E1\right)\st{S_{1}}1} & = & \left(Y\lambda x.\lambda r,\gamma.\left(\begin{aligned}\mathcal{E}\ \dd{\ex E1}\bind\lambda v.\\
\mathtt{cond}\left(\begin{gathered}v,\\
\left(\mathcal{S}\ \dd{\st{S_{1}}1}\right)\bind x,\\
\mathtt{noop}
\end{gathered}
\right)
\end{aligned}
\right)\right)\\
 & \mathcal{S}\ds{\mathtt{output}\ \ex E1} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex E1} & \bind\lambda v.\\
\mathtt{output}\left(v\right)
\end{aligned}
\right)\\
 & S\ds{\mathtt{function}\ id\left(IDs\right)\ \st{S_{1}}1} & = & \mathtt{fundecl}\left(id,s\right)\\
 & \mathcal{E}\de{con} & = & I_{A}\ \mathtt{conval}\left(con\right)\\
 & \mathcal{E}\de{L} & = & \mathcal{L}\ \dd{L}\\
 & \mathcal{E}\de{\mathtt{input}} & = & I_{V}\ \mathtt{getinput}\\
 & \mathcal{E}\de{L\left(E^{*}\right)} & = & \left(\begin{aligned}\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E^{*}\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p\right)
\end{aligned}
\right)\\
 & \mathcal{E}\de{\ex{E_{1}}1\ binop\ \ex{E_{2}}2} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex{E_{1}}1} & \bind\lambda c_{1}.\\
\mathcal{E}\ \dd{\ex{E_{2}}2} & \bind\lambda c_{2}.\\
I_{A}\ \mathtt{bin}\left(binop,c_{0},c_{1}\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{id} & = & \left(I_{A}\ \mathtt{val}\left(id\right)\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "semantic"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Semantic functions for a procedural language
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ true,false\right\} \\
 &  & \cup FunctionPointer\\
FunctionPointer & = & Sid\\
Var & = & id\rightarrow Value\\
Return & = & Value\cup\left\{ Void\right\} \\
CState & = & Var\times IO\times Return
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $n$
\end_inset

 is a function identifier.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \bar{\Theta}\ \lambda R:Return.\left(R=Void\right)\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \begin{cases}
s_{1} & v=true\\
s_{2} & v=false
\end{cases}\\
\mathtt{asg}\left(id,v\right) & = & \bar{\Upsilon}\ \lambda V:Var.V\left[id\mapsto v\right]\\
\mathtt{val}\left(id\right) & = & \bar{\Upsilon}\ \lambda V:Var.V\left(id\right)\\
\mathtt{conval}\left(con\right) & = & con\\
\mathtt{getinput\left(\rho\right)} & = & \bar{\Psi}\ \lambda O:IO.\left\langle O',z\in\mathbb{N}\right\rangle \mbox{see note}\\
\mathtt{dooutput}\left(v\right) & = & \bar{\Upsilon}\ \lambda O:IO.O'\mbox{see note}\\
\\
\\
\mathtt{fundecl}(id,n) & = & \bar{\Upsilon}\ \lambda V:Var.V\left[id\mapsto FP_{n}\right]\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \mbox{perform binary operation }\\
 &  & \mbox{between two constants}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
We omit a detailed description of IO environment.
 Normally, IO can be modelled as a queue of inputs and outputs as they are
 given and produced during the execution of a program.
\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
FunPointer & = & Sid\\
AVal & = & \left\{ Number,Boolean\right\} \cup FunPointer\\
AVar & = & id\rightarrow AVal\\
AReturn & = & AVal\cup\left\{ Void\right\} \\
AState & = & AVar\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \bar{\Theta}\ \lambda R:AReturn.\left(R=Void\right)\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\eta.\left(s_{1}\ f\ \eta\right)\cup\left(s_{2}\ f\ \eta\right)\\
\mathtt{asg}\left(id,v\right) & = & \bar{\Upsilon}\ \lambda\sigma:AVar.\sigma\left[id=v\right]\\
\mathtt{val}\left(id,v\right) & = & \bar{\Upsilon}\ \lambda\sigma:AVar.\sigma\left(id\right)\\
\mathtt{conval}\left(con\right) & = & \Gamma\ \begin{cases}
Number & con\in\mathbb{N}\\
Boolean & con\in\mathbb{B}
\end{cases}\\
\mathtt{getinput} & = & \Gamma\ \lambda\eta.\left\langle \eta,Number\right\rangle \\
\mathtt{dooutput}\left(v\right) & = & \Gamma\ \lambda\eta.\eta\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \Gamma\ \begin{cases}
Number & binop\in{\scriptstyle \left\{ +,-,*,/\right\} }\\
Boolean & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \bar{\Upsilon}\ \lambda\sigma:AVar.\sigma\left[id\mapsto n\right]
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection
Function currying
\end_layout

\begin_layout Standard
There is no inherent semantic function change required in this case.
 However, we do extend call function to include an eid as an input, for
 the reason explained in the abstract domain paragraph.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{E}\de{L\left(E^{*}\right)}=\left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E^{*}\ \phi & \bind\lambda p.\\
\mathtt{apply}\left(n,p,e\right)
\end{aligned}
\right)$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula $FunctionPointer=Sid\times\left[Value\right]$
\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathtt{apply}\left(\left\langle n,C\right\rangle ,p,\_\right)=\\
\begin{cases}
\mathtt{call}\left(n,\left[C\mid p\right]\right) & \begin{gathered}N\left(\left[C\mid p\right]\right)\\
=\mathtt{arity}\left(n\right)
\end{gathered}
\\
\lambda f,\rho.\left\{ \left\langle \rho,\left\langle n,\left[C\mid p\right]\right\rangle \right\rangle \right\}  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}(id,n)=\bar{\Upsilon}\ \lambda V:Aval.V\left[id\mapsto\left\langle n,\phi\right\rangle \right]
\end{gather*}

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract
\end_layout

\begin_layout Standard
Curried functions introduce an infinitely large concrete domain.
\end_layout

\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Currying loop
\end_layout

\end_inset

 Consider the following program.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function foo(a,b) {
\end_layout

\begin_layout Plain Layout

	return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x = 0;
\end_layout

\begin_layout Plain Layout

while(input < 30) {
\end_layout

\begin_layout Plain Layout

	x = foo(x);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, variable 
\begin_inset Formula $\mathtt{x}$
\end_inset

 could refer to an undetermined number of currying of a function.
 A solution to this problem is to have a curried function anchored to a
 particular language construct.
 In this case, we can use an eid of a currying expression as a point of
 reference (or '0' if not curried).
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
FunPointer & = & Sid\times c\times\left(Eid\cup\left\{ 0\right\} \right)\\
Curried & = & Sid\times c\times Eid\rightarrow\left[AVal\right]\\
 &  & \mbox{where}\\
 &  & c\mbox{ is a number of parameters curried}\\
AState & = & AVar\times Curried\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
Definitions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-curry"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{apply}\left(\left\langle n,c,e\right\rangle ,p,e\right) & = & \begin{cases}
\Theta\ \lambda\nu:Curried.\underset{C\in\nu\left(n,c,e\right)}{\bigcup}\mathtt{call}\left(n,\left[C\mid p\right]\right) & \begin{gathered}c+N\left(p\right)\\
=\mathtt{arity}\left(n\right)
\end{gathered}
\\
\bar{\Psi}\ \lambda\nu:Curried.\left\langle \nu\left[\left\langle n,c+N\left(p\right),e\right\rangle \mapsto\left[C\mid p\right]\right],\left\langle n,c+N\left(p\right),e\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \bar{\Upsilon}\ \lambda\sigma:AVar.\sigma\left[id\mapsto\left\langle n,0,0\right\rangle \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for curried functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-curry"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object Oriented
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= <Expr> `.' ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= `global' | `this'
\end_layout

\begin_layout Plain Layout


\backslash
alt  `new' <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Definitions for semantic functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semmon-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \mathcal{S}\ds{\ex{E_{1}}1.id=\ex{E_{2}}2} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex{E_{1}}1} & \bind\lambda v.\\
\mathcal{E}\ \dd{\ex{E_{2}}2} & \bind\lambda r.\\
\mathtt{set}\left(r,id,v\right)
\end{aligned}
\right)\\
 & \mathcal{E}\de{\mathtt{global}} & = & I_{V}\ \mathtt{obj}\left(0\right)\\
 & \mathcal{E}\de{\mathtt{this}} & = & I_{V}\ \mathtt{getthis}\\
 & \mathcal{E}\de{L\left(E*\right)} & = & \left(\begin{aligned}\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{apply}\left(n,p,\mathtt{obj}\left(0,\rho\right),e\right)
\end{aligned}
\right)\\
 & \mathcal{E}\de{\mathtt{new}\ L\left(E*\right)} & = & \left(\begin{aligned}\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{newobj}\left(e\right) & \bind\lambda m.\\
\mathtt{apply}\left(n,p,m,e\right) & \bind\lambda\_.\\
I_{A}\ m
\end{aligned}
\right)\\
 & \mathcal{E}\de{\ex{E_{1}}1.L\left(E*\right)} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex{E_{1}}1} & \bind\lambda t.\\
\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{apply}\left(n,p,t,e\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{\ex{E_{1}}1.id} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex{E_{1}}1} & \bind\lambda v.\\
I_{V}\ \mathtt{get}\left(v,id\right)
\end{aligned}
\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Semantic functions for object-oriented extension of the language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "semmon-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We redefine 
\begin_inset Formula $\mathtt{call}$
\end_inset

 function to include receiver object reference, and to account for side-effects
 that functions can have on object memories.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{call}\left(n,p,t\right)=\begin{gathered}\lambda f,\rho,\gamma.\Omega\ \left\langle \left\{ \bar{\kappa}\ \rho\ \rho'\mid\rho'\in S\right\} ,\gamma'\right\rangle \\
\mbox{where}\left\langle S,\gamma'\right\rangle =f\ n\ \left(\kappa\ \rho\ \left\langle p,t\right\rangle \ n\right)\ \gamma
\end{gathered}
$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ T,F\right\} \cup Object\cup\\
 &  & FunctionPointer\\
Object & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
ObjMem & = & n\rightarrow V\\
CState & = & Var\times ObjMem\times\\
 &  & Object\times Return
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,OM:ObjMem,\_,\_\right\rangle ,\\
 &  & \left\langle P:\left[con\right],T':Object\right\rangle ,n:Sid.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],OM,T',Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V:Var,\_,T:Object,\_\right\rangle ,\\
 &  & \left\langle \_,OM':ObjMem,r:Return\right\rangle .\\
 &  & \ \left\langle \left\langle V,OM',T,Void\right\rangle ,r\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "concfunc-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,id\right) & = & \bar{\Theta}\ \lambda OM:ObjMem.OM\left(n\right)\left(id\right)\\
\mathtt{set}\left(n,id,v\right) & = & \bar{\Upsilon}\ \lambda OM:ObjMem.OM\left[n\mapsto OM\left(n\right)\left[id\mapsto v\right]\right]\\
\mathtt{obj}\left(n\right) & = & \bar{\Theta}\ \lambda OM:ObjMem.OM\left(n\right)\\
\mathtt{getthis} & = & \bar{\Theta}\ \lambda T:Object.T\\
\mathtt{apply}\left(\left\langle n,C\right\rangle ,p,t,\_\right) & = & \begin{cases}
\mathtt{call}\left(n,\left[C\mid p\right],t\right) & \begin{gathered}N\left(\left[C\mid p\right]\right)\\
=\mathtt{arity}\left(n\right)
\end{gathered}
\\
\Gamma\ \lambda f,\rho.\left\langle \rho,\left\langle n,\left[C\mid p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{newobj}\left(\_\right) & = & \bar{\Psi}\ \lambda OM:ObjMem.\left\langle OM\left[n\mapsto\phi\right],n\right\rangle \ \mbox{where}\ n=N\left(OM\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Concrete functions for object-oriented language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "concfunc-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AObj & = & \left\{ 0\right\} \cup Eid\\
AVal & = & P\cup AObj\cup FunPointer\\
AObjMem & = & Eid\rightarrow AVar\\
AState & = & AVar\times AObjMem\times\\
 &  & AObj\times Curried\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,\alpha:AObjMem,\_,\nu:Curried\right\rangle ,\\
 &  & \left\langle P:\left[con\right],\tau':Object\right\rangle ,n:Sid.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],\alpha,\tau',\nu\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle \sigma:AVar,\_,\tau:AObj,\_,r:AReturn\right\rangle ,\\
 &  & \left\langle \_,\alpha':AObjMem,\_,\nu':Curried,r':AReturn\right\rangle .\\
 &  & \ \left\langle \left\langle \sigma,\alpha',\tau,\nu',r\right\rangle ,r'\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,id\right) & = & \bar{\Theta}\ \lambda\alpha:AObjMem.\alpha\left(n\right)\\
\mathtt{set}\left(n,id,v\right) & = & \bar{\Upsilon}\ \lambda\alpha:AObjMem.\alpha\left(n\right)\left[id\mapsto v\right]\\
\mathtt{obj}\left(j\right) & = & \bar{\Theta}\ \lambda\alpha:AObjMem.\alpha\left(j\right)\\
\mathtt{getthis} & = & \bar{\Theta}\ \lambda\tau:AObj.\tau\\
\mathtt{newobj}\left(n\right) & = & \bar{\Psi}\ \lambda\alpha:AObjMem.\left\langle \alpha\left[n\mapsto\phi\right],n\right\rangle \\
\mathtt{apply}\left(\left\langle n,c,e\right\rangle ,p,t,e\right) & = & \begin{cases}
\Theta\ \lambda\nu:Curried.\underset{C\in\nu\left(n,c,e\right)}{\bigcup}\mathtt{call}\left(n,\left[C\mid p\right],t\right) & \begin{gathered}c+N\left(p\right)\\
=\mathtt{arity}\left(n\right)
\end{gathered}
\\
\bar{\Psi}\ \lambda\nu:Curried.\left\langle \nu\left[\left\langle n,c+N\left(p\right),e\right\rangle \mapsto\left[C\mid p\right]\right],\left\langle n,c+N\left(p\right),e\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for object-oriented language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exception handling
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= `try' `{' <Stmt> `}' `catch' `(' id `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `throw' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathcal{S}\ds{\mathtt{try}\ \st{S_{1}}1\ \mathtt{catch}\left(id\right)\ \st{S_{2}}2}=\\
\left(\begin{aligned}\mathcal{S}\ \dd{\st{S_{1}}1} & \bind\\
\mathtt{trycatch}\left(id,\mathcal{S}\ \dd{\st{S_{2}}2}\right)
\end{aligned}
\right)
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{S}\ds{\mathtt{throw}\ \ex E1}=\left(\begin{aligned}\mathcal{E}\ \dd{\ex E1} & \bind\lambda v.\\
\mathtt{throw}\left(v\right)
\end{aligned}
\right)$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Ex & = & Var\cup\left\{ Void\right\} \\
CState & = & Var\times ObjMem\times\\
 &  & Object\times Return\times Ex
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \Theta\ \lambda R:Return,E:Ex.\\
 &  & \left(R=Void\right)\wedge\left(E=Void\right)\\
\mathtt{throw}\left(v\right) & = & \bar{\Upsilon}\ \lambda E:Ex.v\\
\mathtt{trycatch}\left(id,s\right) & = & \Theta\ \lambda E:Ex.\\
 &  & \begin{cases}
\mathtt{noop} & E=Void\\
\lambda f,r.s\ f\ \mathtt{exs}\left(\rho,id\right) & \mbox{otherwise}
\end{cases}\\
\mathtt{exs}\left(id\right) & = & \Upsilon\ \lambda V:Vars,E:Ex.\\
 &  & \left\langle V\left[id\mapsto E\right],Void\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AEx & = & AVar\cup\left\{ Void\right\} \\
AState & = & AVar\times AObjMem\times AObj\\
 &  & Curried\times AReturn\times AEx
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \Theta\ \lambda R:AReturn,E:AEx.\\
 &  & \left(R=Void\right)\wedge\left(E=Void\right)\\
\mathtt{throw}\left(v\right) & = & \bar{\Upsilon}\ \lambda E:AEx.v\\
\mathtt{trycatch}\left(id,s\right) & = & \Theta\ \lambda E:AEx.\\
 &  & \begin{cases}
\mathtt{noop} & E=Void\\
\lambda f,\eta.s\ f\ \mathtt{exs}\left(\eta,id\right) & \mbox{otherwise}
\end{cases}\\
\mathtt{exs}\left(id\right) & = & \Upsilon\ \lambda\sigma:AVars,E:AEx.\\
 &  & \left\langle \sigma\left[id\mapsto E\right],Void\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
Existence of fixed point
\end_layout

\begin_layout Standard
In order to argue soundness of an analysis, we first argue finiteness of
 the abstract domain.
\end_layout

\begin_layout Theorem
\begin_inset Formula $AState$
\end_inset

 is a finite domain.
\end_layout

\begin_layout Standard
We now define a partial ordering between abstract states
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering
\end_layout

\end_inset


\begin_inset Formula $\forall\eta_{1},\eta_{2}\in AState,\eta_{1}\sqsubseteq\eta_{2}$
\end_inset

 if 
\begin_inset Formula $AVar,AObjMem,Curried$
\end_inset

 components of 
\begin_inset Formula $\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\eta_{2}$
\end_inset

 are point-wise ordered, and 
\begin_inset Formula $AObj,AReturn,AEx$
\end_inset

 components are identical.
\end_layout

\begin_layout Standard
We also define an ordering between powersets of abstract states.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering of powersets
\end_layout

\end_inset


\begin_inset Formula $\forall p_{1},p_{2}\in\wp\left(AState\right),p_{1}\sqsubseteq p_{2}$
\end_inset

 if 
\begin_inset Formula $\forall\eta_{1}\in p_{1}\exists\eta_{2}\in p_{2}$
\end_inset

 such that 
\begin_inset Formula $\eta_{1}\sqsubseteq\eta_{2}$
\end_inset

.
 
\begin_inset Formula $\forall e_{1},e_{2}\in\wp\left(AState\times a\right),e_{1}\sqsubseteq e_{2}$
\end_inset

 if 
\begin_inset Formula $\forall\left\langle \eta_{1},a_{1}\right\rangle \in e_{1}\exists\left\langle \eta_{2},a_{2}\right\rangle \in e_{2}$
\end_inset

 such that 
\begin_inset Formula $\eta_{1}\sqsubseteq\eta_{2}\wedge a_{1}=a_{2}$
\end_inset


\end_layout

\begin_layout Standard
Then we argue that the abstract interpretation is a monotonic framework.
 First, observe that the bind operation preserves the monotonicity when
 binding two monotonic functions.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:bindmono"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Monotonicity of bind operation
\end_layout

\end_inset

Given two monotonous functions 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 is also a monotonous function.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $p_{1}=F\ f\ \eta_{1}$
\end_inset

, 
\begin_inset Formula $p_{2}=F\ f\ \eta_{2}$
\end_inset

 such that 
\begin_inset Formula $\eta_{1}\sqsubseteq\eta_{2},p_{1}\sqsubseteq p_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $q_{1}=F\bind G\ f\ \eta_{1}=\underset{s\in p_{1}}{\bigcup}\left(\begin{gathered}\mbox{if}\ isterm\left(s\right)\ \\
\mbox{then}\ \left\{ s\right\} \ \\
\mbox{else}\ G\ f\ s
\end{gathered}
\right)$
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $q_{2}=F\bind G\ f\ \eta_{2}=\underset{s\in p_{2}}{\bigcup}\left(\begin{gathered}\mbox{if}\ isterm\left(s\right)\ \\
\mbox{then}\ \left\{ s\right\} \ \\
\mbox{else}\ G\ f\ s
\end{gathered}
\right)$
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $\forall q\in q_{1}$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $isterm\left(q\right)$
\end_inset

 is true, then it is immediately shown that 
\begin_inset Formula $\exists q'\in q_{2},q\sqsubseteq q'$
\end_inset

 from the fact that 
\begin_inset Formula $p_{1}\sqsubseteq p_{2}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Otherwise, let 
\begin_inset Formula $p$
\end_inset

 be an element in 
\begin_inset Formula $p_{1}$
\end_inset

 such that 
\begin_inset Formula $q\in G\ f\ p$
\end_inset

.
 Monotonicity of 
\begin_inset Formula $F$
\end_inset

 function provides the existence of 
\begin_inset Formula $p'$
\end_inset

 such that 
\begin_inset Formula $p\sqsubseteq p'$
\end_inset

.
 Then, monotonicity of 
\begin_inset Formula $G$
\end_inset

 provides the existence of 
\begin_inset Formula $q'\in G\ f\ q$
\end_inset

 such that 
\begin_inset Formula $q\sqsubseteq q'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we turn to examine each of the abstract functions that we have devised.
 We omit a detailed function-by-function argument.
 Generally, observe that those functions can be categorised and argued as
 thus:
\end_layout

\begin_layout Enumerate
For the functions calculating values from given environment, an increase
 in the environment implies that the resulting environment is also increased.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an increase
 in the environment implies an increase in the updated environment.
\end_layout

\begin_layout Standard
With all the foregoing arguments, it stands to argue that the analytic framework
 is a monotonic framework.
 This result sufficiently proves the existence of the fixed point.
\end_layout

\begin_layout Section
Correctness
\end_layout

\begin_layout Standard
We define an abstraction relation 
\begin_inset Formula $\succ$
\end_inset

between concrete and abstract states.
 
\end_layout

\begin_layout Subsection
Definition of correct abstraction
\end_layout

\begin_layout Standard
First, we define an abstraction between values and other components of the
 states.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction of primitive values
\end_layout

\end_inset


\begin_inset Formula $Number\succ\mathbb{N}$
\end_inset

, 
\begin_inset Formula $Boolean\succ\mathbb{B}$
\end_inset

, 
\begin_inset Formula $Void\succ Void$
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction of objects and symbol maps
\end_layout

\end_inset


\begin_inset Formula $\alpha,OM\vdash n\succ m$
\end_inset

 if 
\begin_inset Formula $\alpha\left(n\right)\succ OM\left(m\right)$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\sigma:AVars\succ V:Vars$
\end_inset

 if 
\begin_inset Formula $\forall id\in V,\sigma\left(id\right)\succ V\left(id\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Function pointers
\end_layout

\end_inset


\begin_inset Formula $C:Curried\vdash\left\langle n,c,e\right\rangle \succ\left\langle m,P\right\rangle $
\end_inset

 if 
\end_layout

\begin_layout Definition
\begin_inset Formula $n=m$
\end_inset

, 
\begin_inset Formula $c=N\left(P\right)$
\end_inset

 and 
\end_layout

\begin_layout Definition
\begin_inset Formula $\exists A\in C\left(n,c,e\right),A_{k}\succ P_{k}$
\end_inset

 for 
\begin_inset Formula $1\leq k\leq c$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Now we are ready to define an abstraction between concrete and abstract
 states.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction relation
\end_layout

\end_inset

Given 
\begin_inset Formula $\rho\in CState$
\end_inset

, 
\begin_inset Formula $\eta\in AState$
\end_inset

, 
\begin_inset Formula $\eta\succ\rho$
\end_inset

 if
\end_layout

\begin_layout Definition
when 
\end_layout

\begin_layout Definition
\begin_inset Formula $\rho=\left\langle \begin{gathered}V:Var,OM:ObjMem,T:Object,\\
R:Return,E:Ex
\end{gathered}
\right\rangle $
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\eta=\left\langle \begin{gathered}\sigma:AVar,\alpha:AObjMem,\tau:AObj\\
C:AObjCurried,r:AReturn,e:AEx
\end{gathered}
\right\rangle $
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{align*}
\sigma\succ V & \wedge\\
\forall m\in OM\exists n\in\alpha,OM\left(m\right)\succ\alpha\left(n\right) & \wedge\\
\tau\succ T\wedge r\succ R\wedge e\succ E
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction between powersets
\end_layout

\end_inset

Given 
\begin_inset Formula $p\in\wp\left(AState\right),q\in\wp\left(CState\right),p\succ q$
\end_inset

 if
\end_layout

\begin_layout Definition
\begin_inset Formula $\forall\rho\in q\exists\eta\in p,\eta\succ\rho$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Morphism
\end_layout

\begin_layout Standard
First, we observe that the bind operation preserves morphisms of the functions
\end_layout

\begin_layout Definition
a pair of functions
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 shows a morphism over 
\begin_inset Formula $\succ$
\end_inset

 if the following condition is met
\end_layout

\begin_layout Definition
\begin_inset Formula $a\succ b\implies F'\left(a\right)\succ F\left(b\right)$
\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

 are such pairs of functions that shows a morphism over 
\begin_inset Formula $\succ$
\end_inset

, then 
\begin_inset Formula $\left\langle F\bind G,F'\bind G'\right\rangle $
\end_inset

 is also such pair.
\end_layout

\begin_layout Proof
\begin_inset Formula $\forall\rho\in CState$
\end_inset

, let 
\begin_inset Formula $p=F\left(\rho\right)$
\end_inset

,
\begin_inset Formula $p'=F\bind G\left(\rho\right)$
\end_inset

, 
\begin_inset Formula $\eta\in AState\mbox{ such that }\eta\succ\rho,$
\end_inset


\begin_inset Formula $q=F'\left(\eta\right)$
\end_inset

,
\begin_inset Formula $q'=F'\bind G'\left(\eta\right)$
\end_inset

, 
\begin_inset Formula $\forall p_{1}\in p,$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
when 
\begin_inset Formula $isterm\left(p_{1}\right)$
\end_inset

 is true, then the morphism and 
\begin_inset Formula $\succ$
\end_inset

 relation imply that 
\begin_inset Formula $\exists q_{1}\in q,isterm\left(q_{1}\right)$
\end_inset

.
 Given the definition of 
\begin_inset Formula $\bind$
\end_inset

 operation, 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $q_{1}$
\end_inset

are also elements of 
\begin_inset Formula $p'$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset


\end_layout

\begin_layout Enumerate
otherwise, morphism of 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

 gives that 
\begin_inset Formula $\forall p_{2}\in G\left(p_{1}\right)\exists q_{2}\in G'\left(q_{1}\right)\mbox{ such that }q_{2}\succ p_{2}$
\end_inset

.
 Such entities also exist in 
\begin_inset Formula $q'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Finally, we observe that operations resulting from abstract functions and
 their corresponding concrete functions form such a morphism over 
\begin_inset Formula $\succ$
\end_inset

.
 As with the monotonicity argument, we omit function-by-function proof.
\end_layout

\begin_layout Section
Conclusion and Future Direction
\end_layout

\begin_layout Standard
As we have noted in the introduction, this work is a snapshot of an ongoing
 dialect between theory and practice, positively informing each other to
 gradually move towards a better theorisation (and practical implementation)
 of a difficult task of analysing dynamic languages.
 We sought to modularise the theoretic framework so that we can take an
 evolutionary approach.
 We anticipate that, as a result of having such theory, adding new features
 to the current model language while maintaining formality and rigour will
 be considerably less laborious than to invent a new incarnation of a more
 feature-complete model language and produce theory for it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "duck"
options "elsarticle-harv"

\end_inset


\end_layout

\end_body
\end_document
