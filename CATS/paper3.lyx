#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass CRPITStyle
\begin_preamble
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{color}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\AtBeginDocument{\catcode`\_=8}

\newcommand{\dd}[1]{\llbracket#1\rrbracket}
\newcommand{\bind}{\Yright}

\exhyphenpenalty=10000\hyphenpenalty=10000

\newcommand\conferencenameandplace{19th Computing: Australasian Theory Symposium (CATS 2013), Adelaide, Australia, January 2013}
\newcommand\volumenumber{xxx}
\newcommand\conferenceyear{2013}
\newcommand\editorname{Anthony Wirth}

\usepackage{hyperref}
\usepackage[all]{hypcap}
\end_preamble
\options fleqn
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\small},comment={[l]{\#}},commentstyle={\color{purple}\ttfamily},frame=leftline,identifierstyle={\color{black}},keywords={new, function, return, if, while, else, output, input},keywordstyle={\bfseries\underline},ndkeywords={this, global, true, false},ndkeywordstyle={\bfseries},numbers=left,numbersep=10pt,numberstyle={\tiny},sensitive=false,tabsize=2,xleftmargin=20pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monadic Theory of Language Analysis and its Application in Type Analysis
 of Dynamic Language
\end_layout

\begin_layout Author
In-Ho Yi, Peter Schachte and Harald SÃ¸ndergaard
\begin_inset Newline newline
\end_inset

Department of Computing and Information Systems 
\begin_inset Newline newline
\end_inset

 The University of Melbourne, Victoria 3010, Australia 
\begin_inset Newline newline
\end_inset

 i.yi@student.unimelb.edu.au, schachte@unimelb.edu.au, harald@unimelb.edu.au
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
submittedstandard
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a novel approach in construction and formalisation of a static
 analysis of a language, in which we formulate a polymorphic and parametric
 interpretation of a language common to both denotational semantics and
 static analysis.
 We apply this in analysing a duck-typing, reflective and function currying
 language.
 We show the benefit of this new approach in term of its terseness and modularit
y, and a new research methodology in which we gradually build language features
 and analysis on top of a previous incarnation of the theory.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are two distinct needs for the development of the present work.
 First, there is a theoretician's need to have a simple and elegant way
 of presenting a formalised argument of a static analysis which enables
 one to focus on what is at the heart of the analysis - definitions of abstract
 domain and their relations to the concrete domain of a language semantics.
 Denotational semantics is a step towards such direction.
 In this paper we endeavour to further modularise the system to the point
 where formal presentation of semantics and analysis can share a common
 framework that mostly deals with linguistic aspects of a programming language.
\end_layout

\begin_layout Standard
Second, there is a practical need of analysing dynamic languages that are
 finding more popularity in recent years.
 Traditionally these languages were termed 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

 languages, as they were mainly used for automating tasks and processing
 strings.
 However, with the advent of Web environment, languages such as Perl and
 PHP gained popularity as languages for web application development.
 On a client side, web pages make heavy use of JavaScript, a dynamic typing
 language, to deliver dynamic contents to the browser.
 Recent years have seen an increasing use of JavaScript in a server side
 environment as well.
\end_layout

\begin_layout Standard
What these languages provide is an ability to rapidly prototype and validate
 application models in a real time REPL environment.
 Another strength comes from the fact that programmers do not need to have
 a class structure defined upfront.
 Rather, class structures and types of variables in general are dynamically
 built.
 This reduces an initial overhead of software design.
\end_layout

\begin_layout Standard
However, these features come at a cost.
 Lacking formal and static definition of type information makes dynamically
 typing languages harder to analyse.
 This difficulty causes several practical problems.
 
\end_layout

\begin_layout Itemize
As applications become more mature, more efforts are devoted to program
 unit testing or assertions to ensure type safety of systems.
 These extra overheads can sometimes outweigh the benefit of having a dynamicall
y typing language.
\end_layout

\begin_layout Itemize
Whereas programmers writing statically typed languages enjoy the abundance
 of development tools, choices of tools for aiding development of dynamically
 typed languages are limited, and lacking much of the power, largely due
 to the difficulty and sometimes infeasibility of conduct a type analysis.
\end_layout

\begin_layout Itemize
Not having a static type structure has a significant performance implication.
\end_layout

\begin_layout Standard
With these problems in mind, we design a model language that has a dynamism
 comparable to those in the aforementioned scripting languages, such as
 duck-typing, reflection and function currying.
 A notable omission is a closure scoping.
 However, allowing function currying gives enough expressive power to the
 language.
\end_layout

\begin_layout Standard
The two concerns are not distinct ones, but an interconnected dialectic.
 Theoretical need is there because of a difficulty of describing abstract
 and concrete meaning of dynamic languages which often allow side-effect
 causing, type-altering functions.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
On a theoretical side, denotational semantics is the starting point of our
 development of a theoretical system.
 The idea of incorporating monads in the denotational semantics, as presented
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998,Liang_Hudak:ESOP1996"

\end_inset

, directly inspired the present work.
 We extend the idea to the static analysis of a language.
\end_layout

\begin_layout Standard
An idea of constructing formulae with parametric types can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "Wadler:1989:TF:99370.99404"

\end_inset

.
 This work is a special application of the parametricity in the field of
 language semantics and analysis.
\end_layout

\begin_layout Standard
On the type analysis of dynamic languages, 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005,Guha:ESOP2011,Wrigstad:POPL2010"

\end_inset

 devise model languages and their semantics for the purpose of static analysis
 of dynamic languages.
 A major difference between them and the model language presented in this
 paper is that our model language is designed to capture the feature of
 real world languages that functions alter types through a side-effect causing
 statements.
 Similarities and differences of this work compared to the cited works are
 given as we encounter them in this paper.
\end_layout

\begin_layout Standard
Type analysis plays a crucial part in compiling scripting languages, mainly
 to improve performance.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ancona:2007:RST:1297081.1297091,Dufour:2006"

\end_inset

 design restricted versions of a scripting language so that a static inference
 of types can be performed.
 Some techniques employed in those projects can also be found in this paper,
 the use of allocation sites as static references is an example.
\end_layout

\begin_layout Standard
An important use case of functions in dynamic typing language is 
\begin_inset Quotes eld
\end_inset

mixin
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand cite
key "Bracha:1990:MI:97946.97982"

\end_inset

) functions, where, by passing argument to such function the variable, the
 object is extended with extra methods.
 There are model languages and formalisations of mixin functions (
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Vub-prog-tr96aformalisation"

\end_inset

).
 Where those works seek to find a functional models for mixins, we model
 a language with side-effect causing functions that is expressive enough
 to program a mixin inheritance.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Jensen:SAS2009"

\end_inset

 built a feature-complete analyser for JavaScript language.
 Our work can be progressed further to become a theoretical counterpart
 of the analyser.
 Furthermore, such attempt at formalising the analysis might pave a way
 for a further refinement and improvement.
\end_layout

\begin_layout Section
Analytic framework
\end_layout

\begin_layout Standard
We first describe a monadic theory of language analysis.
 In this section we produce a particular monadic construct, specifically
 designed for the purpose of analysis.
 We then examine key properties of such construct that is vital to our theory.
\end_layout

\begin_layout Subsection
State collection
\end_layout

\begin_layout Standard
We design a system that collects state transitions from one to another,
 as has occurred in a particular execution point.
 We augment a syntax tree by giving each nodes its unique ID.
 Then, the type of the end product that the system is collecting can be
 described as thus:
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
State Collection
\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $StateCol:Stmt\rightarrow State\rightarrow State$
\end_inset


\end_layout

\begin_layout Subsection
Monad
\end_layout

\begin_layout Standard
We define the monadic constructions.
 We define a type constructor 
\begin_inset Formula $M$
\end_inset

 and a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Type constructor
\end_layout

\end_inset

 Type constructor 
\begin_inset Formula $M$
\end_inset

 gives the following polymorphic type.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{multline*}
M\ a=Func\rightarrow\left(State\times StateCol\right)\rightarrow\\
\left(State\times StateCol\times a\right)
\end{multline*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Bind operator
\end_layout

\end_inset

We define a bind operator 
\begin_inset Formula $\bind$
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M\ a\rightarrow\left(a\rightarrow M\ b\right)\rightarrow M\ b$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $T\ \bind\ U=\lambda f,r,s.U\ t\ f\ r'\ s'$
\end_inset

 
\end_layout

\begin_layout Definition
\begin_inset Formula $\ \ $
\end_inset

where 
\begin_inset Formula $\left\langle r',s',t\right\rangle =T\ f\ r\ s$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we define a series of lift functions in order to provide modularity.
 For example, if a particular parametrised operation takes a state but only
 produces a value, it would be redundant to include a state as a part of
 returning type, to match the definition of monadic binding.
 In such case, we take a function that returns only a value, then lift such
 function to be used in the monadic binding.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Lift functions
\end_layout

\end_inset

We define following lift functions to incorporate non-monadic functions
 as a part of monadic transformation:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $I_{A}$
\end_inset

 is an identity state transformer that takes a constant and lifts it to
 an identity state transformer with the constant as a return value
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{A}:a\rightarrow M\ a\\
I_{A}\ v=\lambda f,r,\gamma.\left\langle r,\gamma,v\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{T}$
\end_inset

 lifts a state transformer with a return value to a monadic function
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{T}:\left(State\rightarrow State\times a\right)\rightarrow M\ a\\
I_{T}\ t=\lambda f,r,\gamma.\left\langle r',\gamma,a\right\rangle \ \mbox{where}\ \left\langle r',a\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{V}$
\end_inset

 lifts a function that takes a state and returns a value to a monadic function
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{V}:\left(State\rightarrow a\right)\rightarrow M\ a\\
I_{V}\ t=\lambda f,r,\gamma.\left\langle r,\gamma,t\ r\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{0}$
\end_inset

 takes a state transformation with no return value and attaches 
\begin_inset Formula $Void$
\end_inset

 return value to it
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{0}:\left(State\rightarrow State\right)\rightarrow M\ a\\
I_{0}\ t=\lambda f,r,\gamma.\left\langle r',\gamma,Void\right\rangle \ \mbox{where}\ \left\langle r'\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we turn to examine properties of the monad.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998"

\end_inset

 gives a survey of mathematical properties that monadic constructs exhibit.
 For the purpose our discussion, we limit ourselves to the discussion of
 properties of monads that are crucial in proving correctness of the system.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Monadic transformers
\end_layout

\end_inset

 We define following polymorphic transformers that takes a monadic operators
 defined for a subspace and transforms into an operator at a higher domain,
 where traces of transformations at a subspace is preserved while other
 orthogonal components remain identical.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\Upsilon & : & \left(A\rightarrow A\right)\rightarrow\left(B\rightarrow B\right)\\
\Psi & : & \left(A\rightarrow A\times a\right)\rightarrow\left(B\rightarrow B\times a\right)\\
\Theta & : & \left(A\rightarrow a\right)\rightarrow\left(B\rightarrow a\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:bindmono"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Monotonicity of bind operation
\end_layout

\end_inset

Given two monotonous functions 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 is also a monotonous function.
\end_layout

\begin_layout Proof
For state and state collection arguments, 
\begin_inset Formula $F\bind G$
\end_inset

 is a series of monotonic transformation.
 Since the composition of two monotonic functions is also monotonic, state
 and state collection are monotonic.
\end_layout

\begin_layout Proof
For the result of 
\begin_inset Formula $F$
\end_inset

 passed on to 
\begin_inset Formula $G$
\end_inset

 as a bound variable, a return value from 
\begin_inset Formula $F$
\end_inset

 is monotonous to the input.
 The return value, then becomes part of input to the 
\begin_inset Formula $G$
\end_inset

 function, whose return value is also monotonous.
\end_layout

\begin_layout Theorem
Given two pairs of isomorphic functions 
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $F\left(\rho_{0}\right)=\left\langle \rho_{1},\alpha_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G\left(\rho_{1},\alpha_{1}\right)=\left\langle \rho_{2},\alpha_{2}\right\rangle $
\end_inset

, 
\begin_inset Formula $F'\left(\eta_{0}\right)=\left\langle \eta_{1},\upsilon_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G'\left(\eta_{1},\upsilon_{1}\right)=\left\langle \eta_{2},\upsilon_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Proof
If there are defined relationship 
\begin_inset Formula $\prec$
\end_inset

between two different domains that two pairs of functions are isomorphic
 with, isomorphicity of 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F'$
\end_inset

 provides that 
\begin_inset Formula $\rho_{0}\prec\eta_{0}$
\end_inset

, 
\begin_inset Formula $\rho_{1}\prec\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\alpha_{1}\prec\upsilon_{1}$
\end_inset

.
 Isomorphicity of 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

 gives 
\begin_inset Formula $\rho_{2}\prec\eta_{2}$
\end_inset

 and 
\begin_inset Formula $\alpha_{2}\prec\upsilon_{2}$
\end_inset

.
 Therefore 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Standard
Finally, we define a state collection helper function 
\begin_inset Formula $T_{S}$
\end_inset

, which takes a state transformation and appends to the transformation a
 new association of state transformation from initial state to the final
 state for a given statement.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
State collection helper function
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{alignat*}{2}
 & T_{S} & : & M\ a\rightarrow s\rightarrow M\ a\\
 & T_{S}\ X\ z & = & \lambda f,r,s.\left\langle r',s'',a\right\rangle \\
 &  &  & \begin{aligned}\mbox{where} & \left\langle r',s',a\right\rangle =X\ f\ r\ s\\
 & s''=s'\left[z\times r\mapsto r'\right]
\end{aligned}
\end{alignat*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We now have monadic constructs and auxiliary functions to describe a semantic
 functions of the model language.
\end_layout

\begin_layout Section
Model language
\end_layout

\begin_layout Standard
In this section we gradually develop the model language from a simple procedural
 language to a full-blown duck-typing object-oriented language.
\end_layout

\begin_layout Subsection
Procedural language
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<con> ::= Number | Boolean
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= <con> | <Lexpr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Expr> <binop> <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  `(' <Expr> `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<binop> ::= `+' | `-' | `*' | `/' | `>' | `<' | `=='
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= nil | <Stmt> `;' <Stmt> | <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `output' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt <LExpr> `=' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}' `else' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `while' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `function' ID `(' [ID [, ID]*]? `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `return' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & F & = &  &  & Y\lambda f.\lambda n.\mathcal{S}\ \dd{\mathtt{Stmt}_{n}}\ \mathtt{sid}\left(\mathtt{Stmt}_{n}\right)\ f\\
 & \mathcal{S}\dd{S_{1};S_{2}} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{S}\ \dd{S_{1}}\ \mathtt{sid}\left(S_{1}\right) & \bind\lambda r.\\
\mathtt{isterm}\left(r,\mathcal{S}\ \dd{S_{2}}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{return}\ e} & = &  &  & T_{S}\ \left(\mathcal{E}\ \dd{e}\ \mathtt{eid}\left(e\right)\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{E}\ \dd{e}\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ \dd{S_{1}}\ \mathtt{sid}\left(S_{1}\right),I_{A}\ Void\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}\mathtt{else}S_{2}} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{E}\ \dd{e}\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ \dd{S_{1}}\ \mathtt{sid}\left(S_{1}\right),\mathcal{S}\ \dd{S_{2}}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{id=e} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{E}\ \dd{e}\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
I_{0}\ \mathtt{asg}\left(id,v\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{while}\left(e\right)S_{1}} & = &  &  & T_{S}\ \left(Y\lambda x.\lambda f,r,\gamma.\left(\begin{aligned}\mathcal{E}\ \dd{e}\ \mathtt{eid}\left(e\right)\bind\lambda v.\\
{\scriptstyle \begin{gathered}\mathtt{cond}\left(\begin{gathered}v,\\
\left(\mathcal{S}\ \dd{S_{1}}\ \mathtt{sid}\left(S_{1}\right)\right)\bind\lambda a.\mathtt{isterm}\left(a,x\right),\\
\left(I_{A}\ Void\right)
\end{gathered}
\right)\end{gathered}
}
\end{aligned}
\right)\right)\\
 & \mathcal{S}\dd{\mathtt{output}\ e} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{E}\ \dd{e}\ eid\left(e\right) & \bind\lambda v.\\
I_{0}\ \mathtt{output}\left(v\right)
\end{aligned}
\right)\\
 & S\dd{{\scriptstyle \mathtt{function}}\ id\left(IDs\right)\ S_{1}}\ \mathtt{sid} & = &  &  & T_{S}\ \left(\begin{aligned}I_{0}\ \mathtt{fundecl}\left(id,\mathtt{sid}\right)\end{aligned}
\right)\ \mathtt{sid}\\
 & \mathcal{E}\dd{con}\ \mathtt{eid} & = &  &  & I_{A}\ \mathtt{conval}\left(con\right)\\
 & \mathcal{E}\dd{L}\ \mathtt{eid} & = &  &  & \mathcal{L}\ \dd{L}\\
 & \mathcal{E}\dd{\mathtt{input}}\ \mathtt{eid} & = &  &  & I_{T}\ \mathtt{getinput}\\
 & \mathcal{E}\dd{L\left(E*\right)}\ \mathtt{eid} & = &  &  & \left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
I_{A}\ \mathtt{call}\left(n,p\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}\ binop\ e_{1}}\ \mathtt{eid} & = &  &  & \left(\begin{aligned}\mathcal{E}\ \dd{e_{0}}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda c_{0}.\\
\mathcal{E}\ \dd{e_{1}}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda c_{1}.\\
I_{V}\ \mathtt{bin}\left(binop,c_{0},c_{1}\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{id} & = &  &  & \left(I_{V}\ \mathtt{val}\left(id\right)\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Semantic functions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ true,false\right\} \\
 &  & \cup FunctionPointer\\
FunctionPointer & = & FP_{n}\\
CState & = & Var\times IO\\
Var & = & id\rightarrow Value
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $n$
\end_inset

 is a function identifier.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \begin{cases}
s & v=Void\\
I_{A}\ v & \mbox{otherwise}
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \begin{cases}
s_{1} & v=true\\
s_{2} & v=false
\end{cases}\\
\mathtt{asg}\left(id,v\right) & = & \Upsilon\ \lambda V:Var.V\left[id\mapsto v\right]\\
\mathtt{val}\left(id\right) & = & \Upsilon\ \lambda V:Var.V\left(id\right)\\
\mathtt{conval}\left(con\right) & = & con\\
\mathtt{getinput\left(\rho\right)} & = & \Psi\ \lambda O:IO.\left\langle O',z\in\mathbb{N}\right\rangle \mbox{see note}\\
\mathtt{dooutput}\left(v\right) & = & \Upsilon\ \lambda O:IO.O'\mbox{see note}\\
\mathtt{call}\left(FP_{n},p\right) & = & \lambda f,\rho,\gamma.\left\langle \bar{\kappa}\ \rho\ \rho',\gamma',r\right\rangle \ \mbox{where}\\
 &  & \left\langle \rho',\gamma',r\right\rangle =f\ n\ \left(\kappa\ \rho\ p\right)\ \gamma\\
\mathtt{fundecl}(id,n) & = & \Upsilon\ \lambda V:Var.V\left[id\mapsto FP_{n}\right]\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \mbox{perform binary operation }\\
 &  & \mbox{between two constants}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
We omit a detailed description of IO environment.
 Normally, IO can be modelled as a queue of inputs and outputs as they are
 given and produced during the execution of a program.
\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & AVar\\
P & = & \left\{ Number,Boolean\right\} \\
FunPointer & = & FP_{n}\\
AVal & = & P\cup FunPointer\\
AVar & = & id\rightarrow\wp\left(AVal\right)\\
 &  & \mbox{where \emph{n} is a function identifier}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
Definitions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-proc"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \lambda f,\eta,\gamma.\begin{cases}
s\ f\ \eta\ \gamma & v=\left\{ Void\right\} \\
\left(s\ f\ \eta\ \gamma\right)\sqcup\left(I_{A}\ v\right) & Void\in v,N\left(v\right)>1\\
I_{A}\ v & \mbox{otherwise}\left(\mbox{i.e.}\ Void\notin v\right)
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\eta,\gamma.\left(s_{1}\ f\ \eta\ \gamma\right)\sqcup\left(s_{2}\ f\ \eta\ \gamma\right)\\
\mathtt{asg}\left(id,v\right) & = & \Upsilon\ \lambda\sigma:AVar.\sigma\left[id=v\right]\\
\mathtt{val}\left(id,v\right) & = & \Upsilon\ \lambda\sigma:AVar.\sigma\left(id\right)\\
\mathtt{conval}\left(con\right) & = & \begin{cases}
Number & con\in\mathbb{N}\\
Boolean & con\in\left\{ true,false\right\} 
\end{cases}\\
\mathtt{getinput} & = & \lambda\eta.\left\langle \eta,\left\{ Number\right\} \right\rangle \\
\mathtt{dooutput}\left(v\right) & = & \lambda\eta.\eta\\
\mathtt{call}\left(n,p\right) & = & \lambda f,\eta,\gamma.\underset{FP_{x}\in n}{\bigsqcup}\mathtt{scall}\left(FP_{x},p,f,\eta,\gamma\right)\\
\mathtt{scall}\left(FP_{n},p,f,\eta,\gamma\right) & = & \left\langle \bar{\kappa}\ \eta\ \eta',r,\gamma'\right\rangle \ \mbox{where}\ \\
 &  & \left\langle \eta',r,\gamma'\right\rangle =f\ n\ \left(\kappa\ \eta\ p\right)\ \gamma\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \begin{cases}
\left\{ Number\right\}  & binop\in\left\{ '+','-','*','/'\right\} \\
\left\{ Boolean\right\}  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \Upsilon\ \lambda\sigma:AVar.\sigma\left[id\mapsto\left\{ FP_{n}\right\} \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for the procedural model language
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "absfun-proc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Function currying
\end_layout

\begin_layout Standard
There is no inherent semantic function change required in this case.
 However, we do extend call function to include an eid as an input, for
 the reason explained in the abstract domain paragraph.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{E}\dd{L\left(E*\right)}\ \mathtt{eid}=\left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,\mathtt{eid}\right)
\end{aligned}
\right)$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula $FunctionPointer=\left\langle FP_{n},\left[Value\right]\right\rangle $
\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathtt{call}\left(\left\langle FP_{n},C\right\rangle ,p,\_\right)=\\
\lambda f,\rho,\gamma.\begin{cases}
\begin{gathered}\begin{gathered}\left\langle \bar{\kappa}\ \rho\ \rho',\gamma',r\right\rangle \mbox{where}\\
\left\langle \rho',\gamma',r\right\rangle =\\
f\ n\ \left(\kappa\ \rho\ p\right)\ \gamma
\end{gathered}
\end{gathered}
 & \begin{gathered}N\left(\left[C|p\right]\right)\\
=arity_{n}
\end{gathered}
\\
\left\langle \rho,\gamma,\left\langle FP_{n},\left[C|p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}(id,n)=\Upsilon\ \lambda V.V\left[id\mapsto\left\langle FP_{n},\phi\right\rangle \right]
\end{gather*}

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract
\end_layout

\begin_layout Standard
Curried functions introduce an infinitely large concrete domain.
\end_layout

\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Currying loop
\end_layout

\end_inset

 Consider the following SDTL program.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function foo(a,b) {
\end_layout

\begin_layout Plain Layout

	return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x = 0;
\end_layout

\begin_layout Plain Layout

while(input < 30) {
\end_layout

\begin_layout Plain Layout

	x = foo(x);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, variable 
\begin_inset Formula $\mathtt{x}$
\end_inset

 could refer to an undetermined number of currying of a function.
 A solution to this problem is to have a curried function anchored to a
 particular language construct.
 In this case, we can use an eid of a currying expression as a point of
 reference.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & AVar\times Curried\\
FunPointer & = & FP_{fid}\times\left[\wp\left(\begin{gathered}\left(AVal-FunPointer\right)\\
\cup FC\times n\times c\times eid
\end{gathered}
\right)\right]\\
Curried & = & n\times c\times eid\rightarrow\\
 &  & \left[\wp\left(\begin{gathered}\left(AVal-FunPointer\right)\\
\cup FC\times n\times c\times eid
\end{gathered}
\right)\right]\\
 &  & \mbox{where \emph{n} is a function identifier}\\
 &  & \ \ c\mbox{ is a number of parameters curried}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
Definitions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-curry"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{call}\left(n,p,e\right) & = & \lambda f,\eta,\gamma.\underset{\left\langle FP_{x},C\right\rangle \in n}{\bigsqcup}\mathtt{scall}\left(\left\langle FP_{x},C\right\rangle ,p,f,\eta,\gamma,e\right)\\
\mathtt{scall}\left(\left\langle FP_{n},C\right\rangle ,p,f,\eta,\gamma,e\right) & = & \begin{cases}
\begin{gathered}\left\langle \bar{\kappa}\ \eta\ \eta',r',\gamma',\nu'\right\rangle \ \mbox{where}\\
\left\langle \eta',r,\gamma',\nu'\right\rangle =f\ n\ \left(\kappa\ \eta\ p\right)\ \gamma
\end{gathered}
 & \begin{gathered}N\left(\left[C|p\right]\right)\\
=arity_{n}
\end{gathered}
\\
{\scriptstyle \left\langle \Upsilon\ \lambda\nu:Curried.\nu\left[\left\langle e,n,N\left(\left[C|p\right]\right)\right\rangle \mapsto\left[C|p\right]\right],\gamma,\left\langle FP_{n},\left[C|p\right],e\right\rangle \right\rangle } & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \Upsilon\ \lambda\sigma:AVar.\sigma\left[id\mapsto\left\langle FP_{n},\phi,n\right\rangle \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for curried functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-curry"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object Oriented
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= <Expr> `.' ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= `global' | `this'
\end_layout

\begin_layout Plain Layout


\backslash
alt  `new' <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Definitions for semantic functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semmon-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \mathcal{S}\dd{e_{0}.id=e_{1}} & = &  &  & T_{S}\ \left(\begin{aligned}\mathcal{E}\ \dd{e_{0}}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
\mathcal{E}\ \dd{e_{1}}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda r.\\
I_{0}\ \mathtt{set}\left(r,id,v\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{\mathtt{global}}\ \mathtt{eid} & = &  &  & I_{V}\ \mathtt{obj}\left(0\right)\\
 & \mathcal{E}\dd{\mathtt{this}}\ \mathtt{eid} & = &  &  & I_{V}\ \mathtt{getthis}\\
 & \mathcal{E}\dd{L\left(E*\right)}\ \mathtt{eid} & = &  &  & \left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,\mathtt{obj}\left(0,\rho\right),\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{\mathtt{new}\ L\left(E*\right)}\ \mathtt{eid} & = &  &  & \left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
I_{T}\ \mathtt{newobj} & \bind\lambda m.\\
\mathtt{call}\left(n,p,m,\mathtt{eid}\right) & \bind\lambda\_.\\
I_{A}\ m
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}.L\left(E*\right)}\ \mathtt{eid} & = &  &  & \left(\begin{aligned}\mathcal{E}\ \dd{e_{0}}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda t.\\
\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,t,\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{e_{0}.id} & = &  &  & \left(\begin{aligned}\mathcal{E}\ \dd{e_{0}}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
I_{V}\ \mathtt{get}\left(v,id\right)
\end{aligned}
\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Object-oriented extension of the model language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "semmon-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ T,F\right\} \cup Object\cup\\
 &  & FunctionPointer\\
Object & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
CState & = & Var\times ObjMem\times Object\\
ObjMem & = & n\rightarrow V
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,OM:ObjMem,\_\right\rangle ,\\
 &  & \left\langle P:\left[con\right],T':Object\right\rangle ,n:Fid.\\
 &  & \ \left\langle \left[param_{n,k}\mapsto P_{k}\right],OM,T'\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V:Var,\_,T:Object\right\rangle ,\\
 &  & \left\langle \_,OM':ObjMem,\_\right\rangle .\\
 &  & \ \left\langle V,OM',T\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "concfunc-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(OBJ_{n},id\right) & = & \Theta\ \lambda OM:ObjMem.OM\left(n\right)\left(id\right)\\
\mathtt{set}\left(OBJ_{n},id,v\right) & = & \Upsilon\ \lambda OM:ObjMem.OM\left[OBJ_{n}\left[id\mapsto v\right]\right]\\
\mathtt{obj}\left(n\right) & = & \Theta\ \lambda OM:ObjMem.OM\left(n\right)\\
\mathtt{getthis} & = & \Theta\ \lambda T:Object.T\\
\mathtt{call}\left(\left\langle FP_{n},C\right\rangle ,p,t,\_\right) & = & \lambda f,\rho,\gamma.\begin{cases}
\begin{gathered}\left\langle \bar{\kappa}\ \rho\ \rho',\gamma',r\right\rangle \mbox{where}\left\langle \rho',\gamma',r\right\rangle =\\
f\ n\ \left(\kappa\ \rho\ \left\langle p,t\right\rangle \ n\right)\ \gamma
\end{gathered}
 & \begin{gathered}N\left(\left[C|p\right]\right)\\
=arity_{n}
\end{gathered}
\\
\left\langle \rho,\gamma,\left\langle FP_{n},\left[C|p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{newobj} & = & \Psi\ \lambda OM:ObjMem.\left\langle OM\left[n\mapsto\phi\right],OBJ_{n}\right\rangle \ \mbox{where}\ n=N\left(OM\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Concrete functions for object-oriented function
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "concfunc-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & AVar\times AObjMem\times\wp\left(AObj\right)\times Curried\\
AObj & = & \left\{ 0\right\} \cup Eid\\
AVal & = & P\cup AObj\cup FunPointer\\
AObjMem & = & n\rightarrow AVar
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset Formula $OBJ_{n}$
\end_inset

:
\end_layout

\begin_layout Standard
We number each of the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expressions as we parse the program.
 The number n corresponds to the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expression number.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,\alpha:AObjMem,\_,\nu:Curried\right\rangle ,\\
 &  & \left\langle P:\left[con\right],\tau':Object\right\rangle ,n:Fid.\\
 &  & \ \left\langle \left[param_{n,k}\mapsto P_{k}\right],\alpha,\tau',\nu\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle \sigma:AVar,\_,\tau:AObj,\_\right\rangle ,\\
 &  & \left\langle \_,\alpha':AObjMem,\_,\nu':Curried\right\rangle .\\
 &  & \ \left\langle \sigma,\alpha',\tau,\nu'\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,id\right) & = & \Theta\ \lambda\alpha:AObjMem.\left\{ \alpha\left(x\right)\mid OBJ_{x}\in n\right\} \\
\mathtt{set}\left(n,id,v\right) & = & \Upsilon\ \lambda\alpha:AObjMem.\left\{ x\mid{OBJ_{x}\in\alpha,x=\begin{cases}
\alpha\left(x\right)\left[id\mapsto v\right] & OBJ_{x}\in n\\
\alpha\left(x\right) & \mbox{otherwise}
\end{cases}}\right\} \\
\mathtt{obj}\left(j\right) & = & \Theta\ \lambda\alpha:AObjMem.\alpha\left(j\right)\\
\mathtt{getthis} & = & \Theta\ \lambda\tau:\wp\left(AObj\right).\tau\\
\mathtt{newobj} & = & \Psi\ \lambda\alpha:AObjMem.\left\langle \alpha\left[n\mapsto\phi\right],OBJ_{n}\right\rangle \ \mbox{where}\ n=N\left(\alpha\right)\\
\mathtt{call}\left(n,p,t,e\right) & = & \lambda f,\eta,\gamma.\underset{\left\langle FP_{x},C\right\rangle \in n}{\bigsqcup}\mathtt{scall}\left(\left\langle FP_{x},C\right\rangle ,p,t,f,\eta,\gamma,e\right)\\
\mathtt{scall}\left(\left\langle FP_{n},C\right\rangle ,p,t,f,\eta,\gamma,e\right) & = & \begin{cases}
\begin{gathered}\left\langle \bar{\kappa}\ \eta\ \eta',r',\gamma',\nu'\right\rangle \ \mbox{where}\\
\left\langle \eta',r,\gamma',\nu'\right\rangle =f\ n\ \left(\kappa\ \eta\ \left\langle p,t\right\rangle \ n\right)\ \gamma
\end{gathered}
 & \begin{gathered}N\left(\left[C|p\right]\right)\\
=arity_{n}
\end{gathered}
\\
{\scriptstyle \left\langle \Upsilon\ \lambda\nu:Curried.\nu\left[\left\langle e,n,N\left(\left[C|p\right]\right)\right\rangle \mapsto\left[C|p\right]\right],\gamma,\left\langle FP_{n},\left[C|p\right],e\right\rangle \right\rangle } & \mbox{otherwise}
\end{cases}\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \begin{cases}
\left\{ Number\right\}  & binop\in\left\{ '+','-','*','/'\right\} \\
\left\{ Boolean\right\}  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \Upsilon\ \lambda\sigma.\sigma\left[id\mapsto\left\langle FP_{n},\phi,n\right\rangle \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Prototype system
\end_layout

\begin_layout Standard
\begin_inset Formula ${\scriptstyle \mathcal{E}\dd{\mathtt{new}\ L\left(E*\right)}\ \mathtt{eid}}={\scriptstyle \left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
I_{T}\ \mathtt{newobj\left(n\right)} & \bind\lambda m.\\
\mathtt{call}\left(n,p,m,\mathtt{eid}\right) & \bind\lambda\_.\\
I_{A}\ m
\end{aligned}
\right)}$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Object & = & Oid\times\left\{ null\right\} \cup Fid\\
CState & = & Var\times ObjMem\times Object\\
 &  & \times Prototype\\
Prototype & = & Fid\rightarrow Object
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
{\scriptstyle \mathtt{get}\left(\left\langle FP_{n},\_\right\rangle ,\mathtt{prototype}\right)} & = & \Theta\ \lambda PT:Prototype.PT\left(n\right)\\
\mathtt{chain}\left(\left\langle OBJ_{n},f\right\rangle ,id,tr\right) & = & \lambda OM.PT.\\
 &  & \mbox{if}\ id\in OM\left(n\right),\ OM\left(n\right)\left(id\right)\\
 &  & \mbox{else if }f\notin tr\ \\
 &  & \mathtt{chain}\left(PT\left(f\right),id,\left[tr\mid f\right]\right)\\
 &  & \ OM\ PT\\
\mathtt{get}\left(\left\langle OBJ_{n},f\right\rangle ,id\right) & = & \Theta\ \lambda{\scriptstyle OM:ObjMem,PT:Prototype}.\\
 &  & \mbox{if}\ id\in OM\left(n\right)\ OM\left(n\right)\left(id\right)\\
 &  & \mbox{else}\ \mathtt{chain}\left(PT\left(f\right),id,\left[f\right]\right)\\
{\scriptstyle \mathtt{set}\left(\left\langle FP_{n},\_\right\rangle ,\mathtt{prototype},v\right)} & = & \Upsilon\ \lambda PT:Prototype.PT\left[n\mapsto v\right]\\
\mathtt{newobj}\left(\left\langle FP_{n},\_\right\rangle \right) & = & {\scriptstyle \Psi\ \lambda OM:ObjMem.\left\langle OM\left[n\mapsto\phi\right],OBJ_{n},f\right\rangle }\\
 &  & \ \mbox{where}\ n=N\left(OM\right)\\
\mathtt{fundecl}(id,n) & = & \Upsilon\ \lambda V,PT:Prototype.\\
 &  & \left\langle V\left[id\mapsto\left\langle FP_{n},\phi\right\rangle \right],PT'\right\rangle \\
 &  & \mbox{where}\\
 &  & PT'=\begin{cases}
PT\left[n\mapsto\phi\right] & n\notin PT\\
PT & \mbox{otherwise}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & AVar\times AObjMem\times\wp\left(AObj\right)\times\\
 &  & Curried\times APrototype\\
AObj & = & \left\{ 0\right\} \cup Eid\times Fid\cup\left\{ null\right\} \\
APrototype & = & Fid\rightarrow\wp\left(AObj\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
Given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-proto"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,\mathtt{prototype}\right) & = & \Theta\ \lambda\alpha:AObjMem,\zeta:APrototype.\\
 &  & \left\{ \alpha\left(x\right)\left(\mathtt{prototype}\right)\mid OBJ_{x}\in n\right\} \cup\left\{ \zeta\left(m\right)\mid\left\langle FP_{m},\_,\_\right\rangle \in n\right\} \\
\mathtt{get}\left(n,id\right) & = & \Theta\ \lambda\alpha:AObjMem,\zeta:APrototype.\\
 &  & \left\{ \alpha\left(x\right)\left(id\right)\mid x\in\mathtt{reach}\left(\alpha,\zeta,n\right)\right\} \\
\mathtt{set}\left(n,\mathtt{prototype},v\right) & = & \Upsilon\ \lambda\alpha:AObjMem,\zeta:APrototype.\\
 &  & \left\langle \begin{gathered}\left\{ x\mid{OBJ_{x}\in\alpha,x=\begin{cases}
\alpha\left(x\right)\left[\mathtt{prototype}\mapsto v\right] & OBJ_{x}\in n\\
\alpha\left(x\right) & \mbox{otherwise}
\end{cases}}\right\} ,\\
\left\{ x\mid{z\in\zeta,x=\begin{cases}
\zeta\left(z\right)\cup\left\{ v\right\}  & \left\langle FP_{z},\_,\_\right\rangle \in n\\
\zeta\left(z\right) & \mbox{otherwise}
\end{cases}}\right\} 
\end{gathered}
\right\rangle \\
\mathtt{newobj}\left(n\right) & = & \Psi\ \lambda\alpha:AObjMem.\left\langle \alpha\left[n\mapsto\phi\right],OBJ_{n}\right\rangle \ \mbox{where}\ n=N\left(\alpha\right)\\
\mathtt{fundecl}\left(id,n\right) & = & \Upsilon\ \lambda\sigma:AVar,\zeta:APrototype.\\
 &  & \left\langle \begin{gathered}\sigma\left[id\mapsto\left\langle FP_{n},\phi,n\right\rangle \right],\\
\zeta\left[n\mapsto\zeta\left(n\right)\cup\phi\right]
\end{gathered}
\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-proto"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion and Future Direction
\end_layout

\begin_layout Standard
As we have noted in the introduction, this work is a snapshot of an ongoing
 dialect between theory and practice, positively informing each other to
 gradually move towards a better theorisation (and practical implementation)
 of a difficult task of analysing dynamic languages.
 We sought to modularise the theoretic framework so that we can take an
 evolutionary approach.
 We anticipate that, as a result of having such theory, adding new features
 to the current SDTL while maintaining formality and rigour will be considerably
 less laborious than to invent a new incarnation of a more feature-complete
 model language and produce theory for it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "duck"
options "elsarticle-harv"

\end_inset


\end_layout

\end_body
\end_document
