#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass CRPITStyle
\begin_preamble
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{color}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\AtBeginDocument{\catcode`\_=8}

\newcommand{\dd}[1]{\llbracket#1\rrbracket}
\newcommand{\ds}[1]{\llbracket\left|#1\right|_s\rrbracket}
\newcommand{\de}[1]{\llbracket\left|#1\right|_e\rrbracket}

\newcommand{\bind}{\Yright}

\exhyphenpenalty=10000\hyphenpenalty=10000

\newcommand\conferencenameandplace{19th Computing: Australasian Theory Symposium (CATS 2013), Adelaide, Australia, January 2013}
\newcommand\volumenumber{xxx}
\newcommand\conferenceyear{2013}
\newcommand\editorname{Anthony Wirth}

\usepackage{hyperref}
\usepackage[all]{hypcap}
\end_preamble
\options fleqn
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement !t
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\small},comment={[l]{\#}},commentstyle={\color{purple}\ttfamily},frame=leftline,identifierstyle={\color{black}},keywords={new, function, return, if, while, else, output, input},keywordstyle={\bfseries\underline},ndkeywords={this, global, true, false},ndkeywordstyle={\bfseries},numbers=left,numbersep=10pt,numberstyle={\tiny},sensitive=false,tabsize=2,xleftmargin=20pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monadic Theory of Language Analysis and its Application in Type Analysis
 of Dynamic Language
\end_layout

\begin_layout Author
In-Ho Yi, Peter Schachte and Harald SÃ¸ndergaard
\begin_inset Newline newline
\end_inset

Department of Computing and Information Systems 
\begin_inset Newline newline
\end_inset

 The University of Melbourne, Victoria 3010, Australia 
\begin_inset Newline newline
\end_inset

 i.yi@student.unimelb.edu.au, schachte@unimelb.edu.au, harald@unimelb.edu.au
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
submittedstandard
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\st}[2]{\left|#1\right|_{s_{#2}}}
{#1_{\left[s#2\right]}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\ex}[2]{\left|#1\right|_{e_{#2}}}
{#1_{\left[e#2\right]}}
\end_inset


\end_layout

\begin_layout Abstract
We present a novel approach to construction of a formal semantics for a
 programming language.
 Our approach, using a parametric monadic semantics, allows the semantics
 to be easily extended to support new language features, and abstracted
 to define program analyses.
 We apply this in analysing a duck-typed, reflective, curried dynamic language.
 The benefits of this approach include its terseness and modularity, and
 the ease with which one can gradually build language features and analyses
 on top of a previous incarnation of a semantics.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Two distinct needs motivated the development of the present work.
 First, there is the theoretician's need for a simple, concise, elegant
 way of presenting a formal semantics for a programming language and of
 developing that into various static analyses.
 We base our approach on a monadic denotational semantics that is modularised
 to allow the concrete semantics and the abstract interpretation to share
 a common framework that uniformly handles most aspects of the programming
 language.
\end_layout

\begin_layout Standard
Second, there is a practical need for program analyses suitable for the
 dynamic languages that have been growing in popularity in recent years.
 Traditionally these languages were called 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

 languages, as they were mainly used for automating tasks and processing
 strings.
 However, with the advent of web applications, languages such as Perl and
 PHP gained popularity as languages for web application development.
 On the client side, web pages make heavy use of JavaScript, a dynamically
 typed language, to deliver dynamic contents to the browser.
 Recent years have seen an increasing use of JavaScript on the server side,
 as well.
\end_layout

\begin_layout Standard
What these languages provide is an ability to rapidly prototype and validate
 application models in a real time read-eval-print loop.
 Another strength comes from the fact that programmers do not need to have
 a class structure defined upfront.
 Rather, class structures and types of variables in general are dynamically
 built.
 This reduces the initial overhead of software design.
\end_layout

\begin_layout Standard
However, these features come at a cost.
 Lacking a formal, static definition of type information makes dynamically
 typed languages harder to analyse.
 This difficulty causes several practical problems.
 
\end_layout

\begin_layout Itemize
As applications become more mature, more efforts are devoted to program
 unit testing and writing assertions to ensure type safety of systems.
 This extra effort can sometimes outweigh the benefit of having a dynamically
 typed language.
\end_layout

\begin_layout Itemize
Whereas programmers using statically typed languages enjoy an abundance
 of development tools, choices of tools for development in dynamically typed
 languages are limited, and the tools that do exist lack much of the power
 of the tools for statically typed languages, largely due to the difficulty
 or infeasibility of type analysis for such languages.
\end_layout

\begin_layout Itemize
Lack of static type structure has a significant performance impact on dynamicall
y typed languages.
\end_layout

\begin_layout Standard
With these problems in mind, we designed a model language that has a dynamism
 comparable to that of the aforementioned scripting languages, such as duck
 typing, reflection, and function currying.
 A notable omission is a closure scoping.
 However, allowing function currying gives enough expressive power to the
 language.
\end_layout

\begin_layout Standard
The two concerns are not distinct ones, but an interconnected dialectic.
 The theoretical need is there because of the difficulty of describing the
 abstract and concrete meaning of dynamic languages, which often allow side-effe
ct causing, type-altering functions.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
On the theoretical side, denotational semantics is the starting point of
 our development of a theoretical system.
 The idea of incorporating monads into the denotational semantics was developed
 by 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998,Liang_Hudak:ESOP1996"

\end_inset

.
 Whereas these works modularise an analytic framework by having multiple
 layers of monadic transformations, we instead parametrise the definition
 of a program state.
 
\end_layout

\begin_layout Standard
Action semantics, as advanced by 
\begin_inset CommandInset citation
LatexCommand citet
key "Mosses1996TPA"

\end_inset

, shares the motivation that semantics ought to be pragmatic, yet expressive
 enough to analyse a non-trivial, feature-rich languages.
 While action semantics endeavours to devise a new semantics, we constrain
 ourself to the language of denotational semantics, and seek to devise a
 formalism largely compatible with denotational semantics.
\end_layout

\begin_layout Standard
The idea of constructing formulae with parametric types can be found in
 
\begin_inset CommandInset citation
LatexCommand cite
key "Wadler:1989:TF:99370.99404"

\end_inset

.
 The present work is a special application of the parametricity in the field
 of language semantics and analysis.
\end_layout

\begin_layout Standard
On the type analysis of dynamic languages, 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005,Guha:ESOP2011,Wrigstad:POPL2010"

\end_inset

 devise model languages and their semantics for the purpose of static analysis
 of dynamic languages.
 A major difference between them and the model language presented in this
 paper is that our model language is designed to capture the feature of
 real world languages that allow functions to alter types through side-effect
 causing statements.
 Similarities and differences of this work compared to the cited works are
 given as we encounter them in this paper.
\end_layout

\begin_layout Standard
Type analysis plays a crucial part in compiling scripting languages, mainly
 to improve performance.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ancona:2007:RST:1297081.1297091,Dufour:2006"

\end_inset

 design restricted versions of a scripting languages so that static inference
 of types can be performed.
 Some techniques employed in those projects can also be found in this paper;
 the use of allocation sites as static references is an example.
\end_layout

\begin_layout Standard
An important use case of functions in dynamically typed language is 
\begin_inset Quotes eld
\end_inset

mixin
\begin_inset Quotes erd
\end_inset

 functions (
\begin_inset CommandInset citation
LatexCommand cite
key "Bracha:1990:MI:97946.97982"

\end_inset

), where, by passing arguments to such function, objects can be extended
 with extra methods.
 There are model languages and formalisations of mixin functions, such as
 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Vub-prog-tr96aformalisation"

\end_inset

.
 Where those works seek to find functional models for mixins, we model a
 language with side-effect causing functions that is expressive enough to
 program mixin inheritance.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Jensen:SAS2009"

\end_inset

 built a feature-complete analyser for the JavaScript language.
 Our work can be progressed further to become a theoretical counterpart
 for the analyser.
 Furthermore, such an attempt to formalise the analysis might pave the way
 for further refinement and improvement.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
Our semantic framework is comprised of two components: one for the syntactic
 structure, and the other for giving meanings to the primitive operations.
 What divides the two is the following separation of concerns:
\end_layout

\begin_layout Enumerate
What is the semantic operations entailed in a particular syntactic structure?
 For example, syntactic structure 
\begin_inset Formula $\ds{a=30}$
\end_inset

 entails a primitive operation 
\begin_inset Formula $\mathtt{assign}\left(a,30\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
How do we interpret such semantic operations in a particular point of view?
 If we were to give a concrete interpretation, we would interpret 
\begin_inset Formula $\mathtt{assign}\left(a,30\right)$
\end_inset

 as updating an environment with a newly defined variable e.g.
 
\begin_inset Formula $Env\left[a=30\right]$
\end_inset

.
\end_layout

\begin_layout Standard
Observe that an interpretation of syntactic structure can remain agnostic
 of the view of a program state at a given point.
 Therefore, once we remove the actual interpretation of primitive operations,
 what remains in a semantics can be re-used for multiple interpretations
 of the language.
 Hence, not only are the primitive operations parametrised, but so is the
 whole definition of the domain of the program state.
 Now we give a formal definition of our framework.
 Such a separation of concerns also helps to define an extensible semantics,
 to which adding a new feature takes as little effort as possible.
\end_layout

\begin_layout Definition
A 
\begin_inset Argument
status open

\begin_layout Plain Layout
parametric semantics
\end_layout

\end_inset

 parametric semantics 
\begin_inset Formula $P$
\end_inset

 is a quintuple 
\begin_inset Formula $\left(X,D,d,M\right)$
\end_inset

 where 
\begin_inset Formula $X$
\end_inset

 is a collection of semantic functions for syntactic structures, 
\begin_inset Formula $D$
\end_inset

 is a definition of a 
\begin_inset Formula $State$
\end_inset

 record, 
\begin_inset Formula $d$
\end_inset

 is an initial program state, and 
\begin_inset Formula $M$
\end_inset

 is an interpretation of primitive operations.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Mention that state includes a return value.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Throughout the analysis, we use following primitive operations:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{isterm}$
\end_inset

 takes a state and reports whether a particular state is terminal (i.e.
 whether or not we would progress to execute the successor statement)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{cond}$
\end_inset

 interprets the meaning of a branching point when a value and two transformation
s (one for true and another for false) are given.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{asg}$
\end_inset

 takes an identifier and a value, and performs assignment
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{val}$
\end_inset

 takes an identifier and produces its value
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{conval}$
\end_inset

 takes a constant and produces its value
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{getinput}$
\end_inset

 and 
\begin_inset Formula $\mathtt{dooutput}$
\end_inset

 defines the meanings of console I/O operations
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Can we combine this item with the next to specify semantics of all language
 primitive operations?
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{bin}$
\end_inset

 defines the meaning of all binary operations given two values
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{ret}$
\end_inset

 defines the meaning of a return statement given the value to be returned
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{fundecl}$
\end_inset

 defines the meaning of dynamic execution of a function declaration
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{apply}$
\end_inset

 defines the meaning of (possibly partially) applying a function to a list
 of values
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{get}$
\end_inset

 and 
\begin_inset Formula $\mathtt{set}$
\end_inset

 defines the meaning of getting or setting a member to an object.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{getglobal}$
\end_inset

 and 
\begin_inset Formula $\mathtt{getthis}$
\end_inset

 define the meaning of keywords 
\begin_inset Formula $\mathtt{global}$
\end_inset

 and 
\begin_inset Formula $\mathtt{this}$
\end_inset

, respectively.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathtt{newobj}$
\end_inset

 defines the meaning of instantiating a new object from a particular allocation
 site.
\end_layout

\begin_layout Standard
Our model language, as it evolves along with the framework, has a set of
 features found common in scripting languages.
 Here is an example of the model language:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function fact(f,x) {
\end_layout

\begin_layout Plain Layout

	if(x < 2) { return 1; }
\end_layout

\begin_layout Plain Layout

	return x * f(f,x-1);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

output fact(fact,input);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fa=fact(fact);
\end_layout

\begin_layout Plain Layout

output fa(input);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function Fruit(v) {
\end_layout

\begin_layout Plain Layout

	this.value = v;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

global.answer = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function juicible(fruit, juice) {
\end_layout

\begin_layout Plain Layout

	function juiceMe(j,x) {
\end_layout

\begin_layout Plain Layout

		return this.value + j + x;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	fruit.juice = juiceMe(juice); #currying
\end_layout

\begin_layout Plain Layout

	global.answer=42;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Juicibles
\end_layout

\begin_layout Plain Layout

apple = new Fruit(15);
\end_layout

\begin_layout Plain Layout

juicible(apple, 20);
\end_layout

\begin_layout Plain Layout

grape = new Fruit(30);
\end_layout

\begin_layout Plain Layout

juicible(grape, 50);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Non-juicibles
\end_layout

\begin_layout Plain Layout

banana = new Fruit(20);
\end_layout

\begin_layout Plain Layout

watermelon = new Fruit(25);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

output apple.juice(10); # 15 + 20 + 10
\end_layout

\begin_layout Plain Layout

output grape.juice(10); # 30 + 50 + 10
\end_layout

\begin_layout Plain Layout

output global.answer; # 42
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

	if(input > 42) {throw 42;}
\end_layout

\begin_layout Plain Layout

} catch(e) {
\end_layout

\begin_layout Plain Layout

	output e;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Locally-scoped procedural languages with support for higher order functions
 (lines 1 to 5) are introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Procedural-language"

\end_inset

.
 Function currying (lines 7, 8 and 20) is introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Function-currying"

\end_inset

.
 Object oriented programming, with duck-typing and reflection, is introduced
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Object-Oriented"

\end_inset

.
 Finally, exception handling (lines 38 to 42) is introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Exception-handling"

\end_inset

.
\end_layout

\begin_layout Section
Analytic framework
\end_layout

\begin_layout Standard
We first describe a monadic framework for language analysis.
 In this section we produce a particular monadic construct, specifically
 designed for the purpose of analysis.
 We then introduce polymorphic auxiliary functions that are useful in expending
 theories in a modular manner.
\end_layout

\begin_layout Subsection
Monad
\end_layout

\begin_layout Standard
We define the monadic constructions.
 We define a type constructor 
\begin_inset Formula $M$
\end_inset

 and a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Type constructor
\end_layout

\end_inset

 Type constructor 
\begin_inset Formula $M$
\end_inset

 has the following polymorphic definition.
 
\begin_inset Formula $\beta$
\end_inset

, in this formulation, is a program-wide invariant.
 As we shall see in the next section, having a program-wide invariant in
 this formula is vital in modelling function calls in a program.
 
\begin_inset Formula $a$
\end_inset

 is a parametrised 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 type, which means different things in different context, as we shall see
 in a formulation of semantics.
\end_layout

\begin_layout Definition
\begin_inset Formula $M\ a=\beta\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)$
\end_inset


\end_layout

\begin_layout Definition
We are essentially modelling a non-deterministic state transformation.
 Allowing non-determinism helps (or enables) defining abstract interpretation
 of a language in the exact same framework on which concrete interpretation
 is defined.
\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Bind operator
\end_layout

\end_inset

We define a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M\ a\rightarrow\left(a\rightarrow M\ b\right)\rightarrow M\ b$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
T\ \bind\ U & = & \lambda f\lambda s.\mathbf{let}\ S=T\ f\ s\ \mathbf{in}\\
 &  & \underset{\left\langle s',a\right\rangle \in S}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s'\right)\\
\mbox{then}\ \left\{ \left\langle s',\bot\right\rangle \right\} \\
\mbox{else}\ U\ a\ f\ s'
\end{gathered}
\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\mathtt{isterm}$
\end_inset

 is a parametrised function that returns true if a State is at a terminal
 state (having encountered a return statement, for example).
 
\end_layout

\end_deeper
\begin_layout Standard
Now we define monadic functions in order to provide modularity.
 For example, if a particular parametrised operation takes a state but only
 produces a value, it would be redundant to include a state as a part of
 returning type, to match the definition of monadic binding.
 In such case, we take a function that returns only a value, then lift such
 function to be used in the monadic binding.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Monadic functions
\end_layout

\end_inset

We define following auxiliary functions to incorporate non-monadic functions
 as a part of monadic transformation:
\end_layout

\begin_deeper
\begin_layout Itemize
(return for 
\begin_inset Formula $M$
\end_inset

) 
\begin_inset Formula $I_{A}$
\end_inset

 is an identity state transformer that takes a constant and lifts it to
 an identity state transformer with the constant as a return value
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $I_{A}:a\rightarrow M\ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I_{A}\ v=\lambda f\lambda s.\left\{ \left\langle r,v\right\rangle \right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
(lift for 
\begin_inset Formula $M$
\end_inset

) 
\begin_inset Formula $I_{V}$
\end_inset

 lifts a function that takes a state and returns a value to a monadic function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $I_{V}:\left(State\rightarrow a\right)\rightarrow M\ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I_{V}\ t=\lambda f\lambda s.\left\langle \left\{ \left\langle r,t\ r\right\rangle \right\} ,\phi\right\rangle $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $I_{S}$
\end_inset

 takes a non-deterministic transformation and lifts it to a monadic function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $I_{S}:\left(State\rightarrow\wp\left(State\right)\right)\rightarrow M\ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I_{S}\ T=\lambda f\lambda s.\left\{ \left\langle s,\bot\right\rangle \mid s\in T\ r\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
(unit operation for 
\begin_inset Formula $M$
\end_inset

) 
\begin_inset Formula $\mathtt{noop}$
\end_inset

 is a function that does nothing.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $\mathtt{noop}=\lambda f\lambda x.\left\{ \left\langle x,\bot\right\rangle \right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "recup"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Record updater
\end_layout

\end_inset

 We model a state as a record, with named columns.
 In this way, an update operation written for a particular set of columns
 can be reused without redefining it when we add extra dimension to a 
\begin_inset Formula $State$
\end_inset

 domain to accommodate extra feature orthogonal to the previous version.
\end_layout

\begin_layout Definition
When we have a record 
\begin_inset Formula $\rho$
\end_inset

 with named columns 
\begin_inset Formula $\left\langle c_{1},\ldots,c_{k}\right\rangle $
\end_inset

, and when an updater function 
\begin_inset Formula $U$
\end_inset

 updates columns 
\begin_inset Formula $c_{i},\ldots,c_{j}$
\end_inset

, we define a function 
\begin_inset Formula $\Upsilon$
\end_inset

 that takes a record, project its columns into an n-tuple corresponding
 to the selected columns, let 
\begin_inset Formula $U$
\end_inset

 update the tuple, and finally update the whole record with the updated
 tuple.
\end_layout

\begin_layout Definition
\begin_inset Formula $P_{c_{i},\ldots,c_{j}}=\lambda\rho.\left\langle a_{i},\ldots,a_{j}\right\rangle $
\end_inset

 where 
\begin_inset Formula $a_{i}$
\end_inset

 is a value for the column 
\begin_inset Formula $c_{i}$
\end_inset

 of a record 
\begin_inset Formula $\rho$
\end_inset

 
\end_layout

\begin_layout Definition
\begin_inset Formula $J_{c_{i},\ldots,c_{j}}=\lambda\left\langle a_{i},\ldots,a_{j}\right\rangle \lambda\rho.\rho\left[c_{n}=a_{n},n\in\left\{ i,\ldots,j\right\} \right]$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\Upsilon_{c_{i},\ldots,c_{j}}\ U=J_{c_{i},\ldots,c_{j}}\circ U\circ P_{c_{i},\ldots,c_{j}}$
\end_inset


\end_layout

\begin_layout Definition
Similarly, we define an operation to update a record and return a value.
\end_layout

\begin_layout Definition
\begin_inset Formula $\Psi_{c_{i},\ldots,c_{j}}\ U=\lambda\rho.\left\langle \rho',a\right\rangle $
\end_inset

 
\end_layout

\begin_layout Definition
where 
\begin_inset Formula $\left\langle \upsilon,a\right\rangle =U\ \left(P_{c_{i},\ldots,c_{j}}\ \rho\right)$
\end_inset

 and 
\begin_inset Formula $\rho'=J_{c_{i},\ldots,c_{j}}\ \upsilon$
\end_inset


\end_layout

\begin_layout Definition
Finally, we define a value extractor, that takes a record and selects a
 value from it.
\end_layout

\begin_layout Definition
\begin_inset Formula $\Theta{}_{c_{i},\ldots,c_{j}}\ U=U\circ P_{c_{i},\ldots,c_{j}}$
\end_inset

 
\end_layout

\begin_layout Definition
When 
\begin_inset Formula $c$
\end_inset

 is an n-tuple space for chosen columns and 
\begin_inset Formula $r$
\end_inset

 is a domain of a 
\begin_inset Formula $State$
\end_inset

 record, functions defined here have the following type signature.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\Upsilon & : & \left(c\rightarrow r\right)\rightarrow\left(r\rightarrow r\right)\\
\Psi & : & \left(c\rightarrow c\times a\right)\rightarrow\left(r\rightarrow r\times a\right)\\
\Theta & : & \left(c\rightarrow a\right)\rightarrow\left(r\rightarrow a\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Singleton operation
\end_layout

\end_inset

Another commonly occurring pattern is that functions often return a singleton.
 We define a function that takes a function returning a value and lifts
 it to be a function that returns a singleton set.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\Gamma & : & \left(a\rightarrow b\right)\rightarrow\left(a\rightarrow\wp\left(b\right)\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
For simplicity of notation, we compose this function with the other functions
 defined in Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "recup"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
\bar{\Upsilon} & = & \Gamma\circ\Upsilon\\
\bar{\Psi} & = & \Gamma\circ\Psi\\
\bar{\Theta} & = & \Gamma\circ\Theta
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
We now have monadic constructs and auxiliary functions to describe a semantic
 functions of the model language.
 We can proceed to define following semantic functions of the language.
\end_layout

\begin_layout Section
Language Analysis
\end_layout

\begin_layout Standard
We use syntax nodes as references to various items constituting program
 environment.
 For that purpose, we define the following syntactic nodes and unique identifier
 spaces.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Stmt$
\end_inset

 is a statement node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Expr$
\end_inset

 is an expression node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $LExpr$
\end_inset

 is a left-expression node.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Sid$
\end_inset

 is a statement id.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $Eid$
\end_inset

 is an expression id.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $id$
\end_inset

 is an alphanumeric identifier.
\end_layout

\begin_layout Standard
We define following auxiliary functions to describe the use of the augmented
 values.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{stmt} & : & Sid\rightarrow Stmt\\
\mathtt{param} & : & Sid\rightarrow\left[id\right]\\
\mathtt{arity} & : & Sid\rightarrow\mathbb{N}\cup\left\{ 0\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Note that we use an sid of a function declaration statement as a reference
 point for the function defined.
 
\begin_inset Formula $\mathtt{param}$
\end_inset

 and 
\begin_inset Formula $\mathtt{arity}$
\end_inset

 functions take such sid and returns a list of parameter names and the arity
 of the function.
\end_layout

\begin_layout Standard
We write 
\begin_inset Formula $\ds{S}$
\end_inset

 to mean a statement 
\begin_inset Formula $S$
\end_inset

 with sid 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection
Semantic functions
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semantic functions
\end_layout

\end_inset

The analytic framework contains following semantic functions.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{eqnarray*}
F & = & Sid\rightarrow State\rightarrow\wp\left(State\right)\\
\mathcal{S} & : & Stmt\rightarrow F\rightarrow State\rightarrow\wp\left(State\times\left\{ \bot\right\} \right)\\
\mathcal{E} & : & Expr\rightarrow F\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)\\
\mathcal{L} & : & LExpr\rightarrow F\rightarrow State\rightarrow\wp\left(State\times a\cup\left\{ \bot\right\} \right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 functions are semantics functions for statements, expressions and left
 expressions, respectively.
 
\begin_inset Formula $F$
\end_inset

 is a function that models functions in a program, given the 
\begin_inset Formula $Sid$
\end_inset

 of a function declaration site, it gives a state transformer.
 Note that in this picture a function 
\begin_inset Quotes eld
\end_inset

returns
\begin_inset Quotes erd
\end_inset

 a value by giving a state transformation.
 Incorporating such concept as a return value in a 
\begin_inset Formula $State$
\end_inset

 itself provides a greater flexibility in describing the effects of executing
 a statement or an expression at a particular program point.
\end_layout

\begin_layout Section
Model language
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Procedural-language"

\end_inset

Procedural language
\end_layout

\begin_layout Standard
We start off with a procedural language with C-like syntax.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<con> ::= Number | Boolean
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= <con> | <Lexpr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Expr> <binop> <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  `(' <Expr> `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<binop> ::= `+' | `-' | `*' | `/' | `>' | `<' | `=='
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= nil | <Stmt> `;' <Stmt> | <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `output' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt <LExpr> `=' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}' `else' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `while' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `function' ID `(' [ID [, ID]*]? `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `return' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notably, this language supports higher-order functions, which allows functions
 to be recursively referenced.
 Hence, we formulate meaning of a function as a fixed point (see the definition
 of 
\begin_inset Formula $F$
\end_inset

).
 Semantic functions for the language is defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semantic"

\end_inset

.
 We use auxiliary functions 
\begin_inset Formula $\mathtt{evalParams}$
\end_inset

 and 
\begin_inset Formula $\mathtt{call}$
\end_inset

 to describe a function call.
 These functions are defined as following:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{call}\left(n,p\right) & = & \lambda f\lambda\rho.\left\{ \bar{\kappa}\ \rho\ \rho'\mid\rho'\in S\right\} \ \mbox{where}\\
 &  & S=f\ n\ \left(\kappa\ \rho\ p\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathtt{evalParams}:\left[Expr\right]\times\left[a\right]\rightarrow\\
\ \ F\rightarrow State\rightarrow\wp\left(State\times\left[a\right]\right)\\
\mathtt{evalParams}\ \phi\ ps\ f\ \rho=\lambda f\lambda\rho.\left\langle \rho,ps\right\rangle \\
\mathtt{evalParams}\ \left[\dd{\ex E{}}\mid Exprs\right]\ ps=\lambda f\lambda\rho.\\
\underset{\left\langle \rho',con\right\rangle \in S}{\bigcup}\left\{ \mathtt{evalParams}\ Exprs\ \left[ps\mid con\right]\ f\ \rho'\right\} \\
\ \ \mbox{where}S=\mathcal{E}\ \dd{\ex E{}}\ f\ \rho
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\kappa$
\end_inset

 is a parametrised function that takes a caller's state at the time of function
 invocation and an id-to-constant value mapping, and constructs initial
 state for a callee.
 
\begin_inset Formula $\bar{\kappa}$
\end_inset

 takes both the caller's state and the resulting states of callee's, and
 construct caller's states after the function call.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & F & = & Y\lambda f.\lambda n.\mathcal{S}\ \dd{\mathtt{Stmt}\left(n\right)}\ n\ f\\
 & \mathcal{S}\ds{\epsilon} & = & \mathtt{noop}\\
 & \mathcal{S}\ds{\st{S_{1}}1;\st{S_{2}}2} & = & \begin{aligned}\mathcal{S}\ \dd{\st{S_{1}}1}\bind\lambda\_.\mathcal{S}\ \dd{\st{S_{2}}2}\end{aligned}
\\
 & \mathcal{S}\ds{\ex E1} & = & \mathcal{E}\ \dd{\ex E1}\bind\lambda\_.\mathtt{noop}\\
 & \mathcal{S}\ds{\mathtt{return}\ \ex E1} & = & \mathcal{E}\ \dd{\ex E1}\bind\lambda v.I_{S}\ \mathtt{ret}\left(V\right)\\
 & \mathcal{S}\ds{\mathtt{if}\left(\ex E1\right)\st{S_{1}}1} & = & \mathcal{E}\ \dd{\ex E1}\bind\lambda v.\mathtt{cond}\left(v,\mathcal{S}\ \dd{\st{S_{1}}1},\mathtt{noop}\right)\\
 & \mathcal{S}\ds{\mathtt{if}\left(\ex E1\right)\st{S_{1}}1\mathtt{else}\st{S_{2}}2} & = & \mathcal{E}\ \dd{\ex E1}\bind\lambda v.\mathtt{cond}\left(v,\mathcal{S}\ \dd{\st{S_{1}}1},\mathcal{S}\ \dd{\st{S_{1}}1}\right)\\
 & \mathcal{S}\ds{id=\ex E1} & = & \begin{aligned}\mathcal{E}\ \dd{\ex e1} & \bind\lambda v.I_{S}\ \mathtt{asg}\left(id,v\right)\end{aligned}
\\
 & \mathcal{S}\ds{\mathtt{while}\left(\ex E1\right)\st{S_{1}}1} & = & Y\lambda x.\lambda f\lambda r.\left(\begin{aligned}\mathcal{E}\ \dd{\ex E1}\bind\lambda v.\mathtt{cond}\left(\begin{gathered}v,\left(\mathcal{S}\ \dd{\st{S_{1}}1}\right)\bind\lambda\_.x,\mathtt{noop}\end{gathered}
\right)\end{aligned}
\right)\\
 & \mathcal{S}\ds{\mathtt{output}\ \ex E1} & = & \mathcal{E}\ \dd{\ex E1}\bind\lambda v.I_{S}\ \mathtt{output}\left(v\right)\\
 & S\ds{\mathtt{function}\ id\left(IDs\right)\ \st{S_{1}}1} & = & I_{S}\ \mathtt{fundecl}\left(id,s\right)\\
 & \mathcal{E}\de{con} & = & I_{A}\ \mathtt{conval}\left(con\right)\\
 & \mathcal{E}\de{L} & = & \mathcal{L}\ \dd{L}\\
 & \mathcal{E}\de{\mathtt{input}} & = & I_{V}\ \mathtt{getinput}\\
 & \mathcal{E}\de{L\left(\vec{E}\right)} & = & \mathcal{L}\ \dd L\bind\lambda n.\left(\mathtt{evalParams}\ \vec{E}\ \phi\right)\bind\lambda p.\mathtt{call}\left(n,p\right)\\
 & \mathcal{E}\de{\ex{E_{1}}1\ binop\ \ex{E_{2}}2} & = & \mathcal{E}\ \dd{\ex{E_{1}}1}\bind\lambda c_{1}.\mathcal{E}\ \dd{\ex{E_{2}}2}\bind\lambda c_{2}.I_{A}\ \mathtt{bin}\left(binop,c_{0},c_{1}\right)\\
 & \mathcal{L}\dd{id} & = & I_{A}\ \mathtt{val}\left(id\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "semantic"

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Semantic functions for a procedural language
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ true,false\right\} \\
 &  & \cup FunctionPointer\\
FunctionPointer & = & Sid\\
Var & = & id\rightarrow Value\\
Return & = & Value\cup\left\{ Void\right\} \\
CState & = & Var\times IO\times Return
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $n$
\end_inset

 is a function identifier.
\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,io,Void\right\rangle $
\end_inset

 where 
\begin_inset Formula $io$
\end_inset

 is an initial IO state.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,IO,\_\right\rangle ,P,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],IO,Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V,\_,\_\right\rangle ,\left\langle \_,IO',R\right\rangle .\\
 &  & \ \left\langle \left\langle V,IO',Void\right\rangle ,R\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \bar{\Theta}_{Return}\ \lambda R.\left(R=Void\right)\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \begin{cases}
s_{1} & \mbox{if}\ v=true\\
s_{2} & \mbox{if}\ v=false
\end{cases}\\
\mathtt{asg}\left(id,v\right) & = & \bar{\Upsilon}_{Var}\ \lambda V.V\left[id\mapsto v\right]\\
\mathtt{val}\left(id\right) & = & \bar{\Upsilon}_{Var}\ \lambda V.V\left(id\right)\\
\mathtt{conval}\left(con\right) & = & \left\{ con\right\} \\
\mathtt{getinput\left(\rho\right)} & = & \bar{\Psi}_{IO}\ \lambda O.\left\langle O',z\in\mathbb{N}\right\rangle \mbox{see note}\\
\mathtt{dooutput}\left(v\right) & = & \bar{\Upsilon}_{IO}\ \lambda O.O'\mbox{see note}\\
\mathtt{fundecl}(id,n) & = & \bar{\Upsilon}_{Var}\ \lambda V.V\left[id\mapsto FP_{n}\right]\\
\mathtt{ret}\left(v\right) & = & \bar{\Upsilon}_{Return}\ \lambda R.v\\
\mathtt{bin}\left(op,c_{0},c_{1}\right) & = & \mbox{perform binary operation }\\
 &  & \mbox{between two constants}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
We omit a detailed description of IO environment.
 Normally, IO can be modelled as a queue of inputs and outputs as they are
 given and produced during the execution of a program.
\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Standard
At this stage, abstract interpretation looks largely similar to that of
 concrete interpretation.
 Notable differences are that we categorise constant by its type, and that
 
\begin_inset Formula $\mathtt{cond}$
\end_inset

 is a non-deterministic transformation where it collects effects of both
 branches at a branching point.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
FunPointer & = & Sid\\
AVal & = & \left\{ Number,Boolean\right\} \cup FunPointer\\
AVar & = & id\rightarrow AVal\\
AReturn & = & AVal\cup\left\{ Void\right\} \\
AState & = & AVar\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,Void\right\rangle $
\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,\_\right\rangle ,P,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V,\_\right\rangle ,\left\langle \_,R\right\rangle .\left\langle \left\langle V,Void\right\rangle ,R\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \bar{\Theta}_{AReturn}\ \lambda R.\left(R=Void\right)\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f\lambda\eta.\left(s_{1}\ f\ \eta\right)\cup\left(s_{2}\ f\ \eta\right)\\
\mathtt{asg}\left(id,v\right) & = & \bar{\Upsilon}_{AVar}\ \lambda\sigma.\sigma\left[id=v\right]\\
\mathtt{val}\left(id,v\right) & = & \bar{\Upsilon}_{AVar}\ \lambda\sigma.\sigma\left(id\right)\\
\mathtt{conval}\left(con\right) & = & \Gamma\ \begin{cases}
Number & \mbox{if}\ con\in\mathbb{N}\\
Boolean & \mbox{if}\ con\in\mathbb{B}
\end{cases}\\
\mathtt{getinput} & = & \Gamma\ \lambda\eta.\left\langle \eta,Number\right\rangle \\
\mathtt{dooutput}\left(v\right) & = & \Gamma\ \lambda\eta.\eta\\
\mathtt{fundecl}\left(id,n\right) & = & \bar{\Upsilon}_{AVar}\ \lambda\sigma.\sigma\left[id\mapsto n\right]\\
\mathtt{ret}\left(v\right) & = & \bar{\Upsilon}_{AReturn}\ \lambda R:AReturn.v\\
\mathtt{bin}\left(op,c_{0},c_{1}\right) & = & \Gamma\ \begin{cases}
Number & \mbox{if}\ op\in{\scriptstyle \left\{ +,-,*,/\right\} }\\
Boolean & \mbox{otherwise}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Function-currying"

\end_inset

Function currying
\end_layout

\begin_layout Standard
There is no inherent semantic function change required in this case.
 However, we do extend call function to include an eid as an input, for
 the reason explained in the abstract domain paragraph.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{E}\de{L\left(\vec{E}\right)}=\left(\begin{aligned}\mathcal{L}\ \dd{L} & \bind\lambda n.\\
\mathtt{evalParams}\ \vec{E}\ \phi & \bind\lambda p.\\
\mathtt{apply}\left(n,p,e\right)
\end{aligned}
\right)$
\end_inset


\end_layout

\begin_layout Standard
Here we introduce 
\begin_inset Formula $\mathtt{apply}$
\end_inset

 function.
 It invokes 
\begin_inset Formula $\mathtt{call}$
\end_inset

 function when the function arguments are saturated, or it returns a pointer
 to a curried function otherwise.
\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Standard
Obviously, we extend the definition of 
\begin_inset Formula $FunctionPointer$
\end_inset

 to hold curried parameters.
 This means that the 
\begin_inset Formula $\mathtt{fundecl}$
\end_inset

 function also needs to be modified to match the new type signature.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula $FunctionPointer=Sid\times\left[Value\right]$
\end_inset


\end_layout

\begin_layout Standard
Initial state of a program does not change.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathtt{apply}\left(\left\langle n,C\right\rangle ,p,\_\right)=\\
\begin{cases}
\mathtt{call}\left(n,\left[C\mid p\right]\right) & \mbox{if}\begin{gathered}N\left(\left[C\mid p\right]\right)=\\
\mathtt{arity}\left(n\right)
\end{gathered}
\\
\lambda f,\rho.\left\{ \left\langle \rho,\left\langle n,\left[C\mid p\right]\right\rangle \right\rangle \right\}  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}(id,n)=\bar{\Upsilon}_{Var}\ \lambda V.V\left[id\mapsto\left\langle n,\phi\right\rangle \right]
\end{gather*}

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Standard
Note that curried functions introduce a possibility of having an infinitely
 large concrete domain.
\end_layout

\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Currying loop
\end_layout

\end_inset

 Consider the following program.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function foo(a,b) {
\end_layout

\begin_layout Plain Layout

	return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x = 0;
\end_layout

\begin_layout Plain Layout

while(input < 30) {
\end_layout

\begin_layout Plain Layout

	x = foo(x);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, variable 
\begin_inset Formula $\mathtt{x}$
\end_inset

 could refer to an undetermined number of currying of a function.
 A solution to this problem is to have a curried function anchored to a
 particular language construct.
 In this case, we can use an eid of a currying expression as a point of
 reference (or '0' if not curried).
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
FunPointer & = & Sid\times c\times\left(Eid\cup\left\{ 0\right\} \right)\\
Curried & = & Sid\times c\times Eid\rightarrow\left[AVal\right]\\
 &  & \mbox{where}\\
 &  & c\mbox{ is a number of parameters curried}\\
AState & = & AVar\times Curried\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,\phi,Void\right\rangle $
\end_inset


\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
Definitions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-curry"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{apply}\left(\left\langle n,c,e\right\rangle ,p,e\right) & = & \begin{cases}
\Theta_{Curried}\ \lambda\nu.\underset{C\in\nu\left(n,c,e\right)}{\bigcup}\mathtt{call}\left(n,\left[C\mid p\right]\right)\ \mbox{if }c+N\left(p\right)=\mathtt{arity}\left(n\right)\\
\bar{\Psi}_{Curried}\ \lambda\nu.\left\langle \nu\left[\left\langle n,c+N\left(p\right),e\right\rangle \mapsto\left[C\mid p\right]\right],\left\langle n,c+N\left(p\right),e\right\rangle \right\rangle \ \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \bar{\Upsilon}_{AVar}\ \lambda\sigma.\sigma\left[id\mapsto\left\langle n,0,0\right\rangle \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for curried functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-curry"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Object-Oriented"

\end_inset

Object Oriented
\end_layout

\begin_layout Standard
We now extend our language to support objects.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= <Expr> `.' ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= `global' | `this'
\end_layout

\begin_layout Plain Layout


\backslash
alt  `new' <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{global}$
\end_inset

 is a reference to a global object, and the reference to global object is
 program invariant (akin to `window' in Client-side JavaScript or `global'
 in Node.js).
 
\begin_inset Formula $\mathtt{this}$
\end_inset

 is a usual reference to a receiver object of a method call.
 
\end_layout

\begin_layout Standard
As this extension introduces new syntactic structure, extra definitions
 for semantic functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semmon-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \mathcal{S}\ds{\ex{E_{1}}1.id=\ex{E_{2}}2} & = & \mathcal{E}\ \dd{\ex{E_{1}}1}\bind\lambda v.\mathcal{E}\ \dd{\ex{E_{2}}2}\bind\lambda r.I_{S}\ \mathtt{set}\left(r,id,v\right)\\
 & \mathcal{E}\de{\mathtt{global}} & = & I_{V}\ \mathtt{getglobal}\\
 & \mathcal{E}\de{\mathtt{this}} & = & I_{V}\ \mathtt{getthis}\\
 & \mathcal{E}\de{L\left(\vec{E}\right)} & = & \mathcal{L}\ \dd L\bind\lambda n.\left(\mathtt{evalParams}\ \vec{E}\ \phi\right)\bind\lambda p.\mathtt{apply}\left(n,p,\mathtt{obj}\left(0,\rho\right),e\right)\\
 & \mathcal{E}\de{\mathtt{new}\ L\left(\vec{E}\right)} & = & \left(\begin{aligned}\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ \vec{E}\ \phi & \bind\lambda p.\\
\mathtt{newobj}\left(e\right) & \bind\lambda m.\\
\mathtt{apply}\left(n,p,m,e\right) & \bind\lambda\_.\\
I_{A}\ m
\end{aligned}
\right)\\
 & \mathcal{E}\de{\ex{E_{1}}1.L\left(\vec{E}\right)} & = & \left(\begin{aligned}\mathcal{E}\ \dd{\ex{E_{1}}1} & \bind\lambda t.\\
\mathcal{L}\ \dd L & \bind\lambda n.\\
\mathtt{evalParams}\ \vec{E}\ \phi & \bind\lambda p.\\
\mathtt{apply}\left(n,p,t,e\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{\ex{E_{1}}1.id} & = & \mathcal{E}\ \dd{\ex{E_{1}}1}\bind\lambda v.I_{V}\ \mathtt{get}\left(v,id\right)
\end{align*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Semantic functions for object-oriented extension of the language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "semmon-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We redefine 
\begin_inset Formula $\mathtt{call}$
\end_inset

 function to include receiver object reference, and to account for side-effects
 that functions can have on object memories.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{call}\left(n,p,t\right)=\begin{gathered}\lambda f\lambda\rho,\gamma.\Omega\ \left\langle \left\{ \bar{\kappa}\ \rho\ \rho'\mid\rho'\in S\right\} ,\gamma'\right\rangle \\
\mbox{where}\left\langle S,\gamma'\right\rangle =f\ n\ \left(\kappa\ \rho\ \left\langle p,t\right\rangle \ n\right)\ \gamma
\end{gathered}
$
\end_inset


\end_layout

\begin_layout Standard
Note that by modelling function calls as an effect on a state, we can readily
 model such concepts as mixins.
 Compare this modelling of mixin functions with 
\begin_inset Formula $\mbox{JS}_{0}$
\end_inset

 language, as developed and presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005"

\end_inset

 where we attempt to contain a mixin creating behaviour in a functional
 model language.
 Similar approach has been taken in the discussion of 
\begin_inset Formula $\lambda_{S}$
\end_inset

 language as devised in 
\begin_inset CommandInset citation
LatexCommand citet
key "Guha:ESOP2011"

\end_inset

.
 With the languages like JavaScript, it is in the nature of such language
 that functions are side-effect causing, and much of the type operations
 are being done with by the side-effects.
 Hence our deviation from purely functional approach to devise a model language
 that resembles real life language.
\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Standard
We extend the domain to include object memory (where object references are
 mapped to a symbol mapping), and a reference to 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 object.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ T,F\right\} \cup Object\cup\\
 &  & FunctionPointer\\
Object & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
ObjMem & = & n\rightarrow V\\
This & = & Object\\
CState & = & Var\times ObjMem\times\\
 &  & This\times Return
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,\left\{ 0\mapsto\phi\right\} ,0,Void\right\rangle $
\end_inset

.
 
\begin_inset Formula $0$
\end_inset

 is a unique id referring to the global object.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
We redefine 
\begin_inset Formula $\kappa$
\end_inset

 and 
\begin_inset Formula $\bar{\kappa}$
\end_inset

 functions to allow passing of a receiver object.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,OM,\_,\_\right\rangle ,\left\langle P,T'\right\rangle ,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],OM,T',Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V,\_,T,\_\right\rangle ,\left\langle \_,OM',\_,r\right\rangle .\\
 &  & \ \left\langle \left\langle V,OM',T,Void\right\rangle ,r\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Other functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "concfunc-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,id\right) & = & \bar{\Theta}_{ObjMem}\ \lambda OM.OM\left(n\right)\left(id\right)\\
\mathtt{set}\left(n,id,v\right) & = & \bar{\Upsilon}_{ObjMem}\ \lambda OM.OM\left[n\mapsto OM\left(n\right)\left[id\mapsto v\right]\right]\\
\mathtt{getglobal} & = & \bar{\Theta}_{ObjMem}\ \lambda OM.OM\left(0\right)\\
\mathtt{getthis} & = & \bar{\Theta}_{This}\ \lambda T.T\\
\mathtt{apply}\left(\left\langle n,C\right\rangle ,p,t,\_\right) & = & \begin{cases}
\mathtt{call}\left(n,\left[C\mid p\right],t\right) & \mbox{if}\ N\left(\left[C\mid p\right]\right)=\mathtt{arity}\left(n\right)\\
\Gamma\ \lambda\rho.\left\langle \rho,\left\langle n,\left[C\mid p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{newobj}\left(\_\right) & = & \bar{\Psi}_{ObjMem}\ \lambda OM.\left\langle OM\left[n\mapsto\phi\right],n\right\rangle \ \mbox{where}\ n=N\left(OM\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Concrete functions for object-oriented language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "concfunc-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Standard
Similarly, we extend the abstract interpretation.
 Note that, whereas in a concrete interpretation we generate a unique id
 for each of the object instantiated in run-time, we use a reference to
 allocation site of an object as a reference to a particular object, hence
 we contain object memory in a finite domain.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AObj & = & \left\{ 0\right\} \cup Eid\\
AVal & = & P\cup AObj\cup FunPointer\\
AObjMem & = & Eid\rightarrow AVar\\
AThis & = & AObj\\
AState & = & AVar\times AObjMem\times\\
 &  & AThis\times Curried\times AReturn
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,\left\{ 0\mapsto\phi\right\} ,0,\phi,Void\right\rangle $
\end_inset

.
 
\begin_inset Formula $0$
\end_inset

 is a unique id referring to the global object.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,\alpha,\_,\nu,\_\right\rangle ,\left\langle P,\tau'\right\rangle ,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],\alpha,\tau',\nu,Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle \sigma,\_,\tau,\_,\_\right\rangle ,\left\langle \_,\alpha',\_,\nu',r\right\rangle .\\
 &  & \ \left\langle \left\langle \sigma,\alpha',\tau,\nu',Void\right\rangle ,r\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Other functions are defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun-oo"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{get}\left(n,id\right) & = & \bar{\Theta}_{AObjMem}\ \lambda\alpha.\alpha\left(n\right)\\
\mathtt{set}\left(n,id,v\right) & = & \bar{\Upsilon}_{AObjMem}\ \lambda\alpha.\alpha\left(n\right)\left[id\mapsto v\right]\\
\mathtt{obj}\left(j\right) & = & \bar{\Theta}_{AObjMem}\ \lambda\alpha.\alpha\left(j\right)\\
\mathtt{getthis} & = & \bar{\Theta}_{AThis}\ \lambda\tau.\tau\\
\mathtt{newobj}\left(n\right) & = & \bar{\Psi}_{AObjMem}\ \lambda\alpha.\left\langle \alpha\left[n\mapsto\phi\right],n\right\rangle \\
\mathtt{apply}\left(\left\langle n,c,e\right\rangle ,p,t,e\right) & = & \begin{cases}
\Theta_{Curried}\ \lambda\nu.\underset{C\in\nu\left(n,c,e\right)}{\bigcup}\mathtt{call}\left(n,\left[C\mid p\right],t\right)\ \mbox{if}\ c+N\left(p\right)=\mathtt{arity}\left(n\right) & \begin{gathered}\end{gathered}
\\
\bar{\Psi}_{Curried}\ \lambda\nu.\left\langle \nu\left[\left\langle n,c+N\left(p\right),e\right\rangle \mapsto\left[C\mid p\right]\right],\left\langle n,c+N\left(p\right),e\right\rangle \right\rangle \ \mbox{otherwise}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions for object-oriented language
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun-oo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Exception-handling"

\end_inset

Exception handling
\end_layout

\begin_layout Standard
As a final extension to the model language, we introduce exception throwing
 and handling.
 First, we introduce a familiar syntax for exception handling.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= `try' `{' <Stmt> `}' `catch' `(' id `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `throw' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Following functions are the semantic functions for the newly introduced
 syntax.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\mathcal{S}\ds{\mathtt{try}\ \st{S_{1}}1\ \mathtt{catch}\left(id\right)\ \st{S_{2}}2}=\\
\left(\begin{aligned}\mathcal{S}\ \dd{\st{S_{1}}1} & \bind\\
\lambda f\lambda r.\mathtt{catch}\left(id,\mathcal{S}\ \dd{\st{S_{2}}2}\right)\ f\ r
\end{aligned}
\right)
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{S}\ds{\mathtt{throw}\ \ex E1}=\left(\begin{aligned}\mathcal{E}\ \dd{\ex E1} & \bind\lambda v.\\
\mathtt{throw}\left(v\right)
\end{aligned}
\right)$
\end_inset


\end_layout

\begin_layout Subsubsection
Concrete interpretation
\end_layout

\begin_layout Standard
As the flow control of the execution is abstracted out and parametrised
 as a function 
\begin_inset Formula $\mathtt{isterm}$
\end_inset

, it is not very surprising that introducing exceptions to a program does
 not necessitates a heavy modification to an interpretation of the language.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Ex & = & Var\cup\left\{ Void\right\} \\
CState & = & Var\times ObjMem\times\\
 &  & This\times Return\times Ex
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,\left\{ 0\mapsto\phi\right\} ,0,Void,Void\right\rangle $
\end_inset

.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,OM,\_,\_,\_\right\rangle ,\left\langle P,T'\right\rangle ,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],OM,T',Void,Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle V,\_,T,\_,\_\right\rangle ,\left\langle \_,OM',\_,r,e\right\rangle .\\
 &  & \ \left\langle \left\langle V,OM',T,Void,e\right\rangle ,r\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \Theta_{Returnm,Ex}\ \lambda R,E.\\
 &  & \left(R=Void\right)\wedge\left(E=Void\right)\\
\mathtt{throw}\left(v\right) & = & \bar{\Upsilon}_{Ex}\ \lambda E.v\\
\mathtt{catch}\left(id,s\right) & = & \Theta_{Ex}\ \lambda E.\\
 &  & \begin{cases}
\mathtt{noop} & \mbox{if}\ E=Void\\
\lambda f,r.s\ f\ \mathtt{exs}\left(\rho,id\right) & \mbox{otherwise}
\end{cases}\\
\mathtt{exs}\left(id\right) & = & \Upsilon_{Vars,Ex}\ \lambda V,E.\left\langle V\left[id\mapsto E\right],Void\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{exs}$
\end_inset

 helps constructing an entering state to a catch block if an exception was
 caught.
 As we do not support lexical scoping, an exception variable enters a variable
 mapping as we enter the block.
\end_layout

\begin_layout Subsubsection
Abstract interpretation
\end_layout

\begin_layout Standard
Abstract definitions are largely similar to that of concrete ones.
 Notice that we carry on modified exception state returned from a function
 call, thereby allowing exception propagating.
\end_layout

\begin_layout Paragraph
Domain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AEx & = & AVar\cup\left\{ Void\right\} \\
AState & = & AVar\times AObjMem\times AThis\\
 &  & Curried\times AReturn\times AEx
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Initial state of a program is 
\begin_inset Formula $\left\langle \phi,\left\{ 0\mapsto\phi\right\} ,0,\phi,Void,Void\right\rangle $
\end_inset

.
\end_layout

\begin_layout Paragraph
Functions
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\kappa & = & \lambda\left\langle \_,\alpha,\_,\nu,\_,\_\right\rangle ,\left\langle P,\tau'\right\rangle ,n.\\
 &  & \ \left\langle \left[\mathtt{param}\left(n\right)_{k}\mapsto P_{k}\right],\alpha,\tau',\nu,Void,Void\right\rangle \\
\bar{\kappa} & = & \lambda\left\langle \sigma,\_,\tau,\_,\_,\_\right\rangle ,\left\langle \_,\alpha',\_,\nu',r,e\right\rangle .\\
 &  & \ \left\langle \left\langle \sigma,\alpha',\tau,\nu',Void,e\right\rangle ,r\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm} & = & \Theta_{AReturn,AEx}\ \lambda R,E.\\
 &  & \left(R=Void\right)\wedge\left(E=Void\right)\\
\mathtt{throw}\left(v\right) & = & \bar{\Upsilon}_{AEx}\ \lambda E.v\\
\mathtt{catch}\left(id,s\right) & = & \Theta_{AEx}\ \lambda E.\\
 &  & \begin{cases}
\mathtt{noop} & \mbox{if}\ E=Void\\
\lambda f\lambda\eta.s\ f\ \mathtt{exs}\left(\eta,id\right) & \mbox{otherwise}
\end{cases}\\
\mathtt{exs}\left(id\right) & = & \Upsilon_{AVars,AEx}\ \lambda\sigma,E.\\
 &  & \left\langle \sigma\left[id\mapsto E\right],Void\right\rangle 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Section
Existence of fixed point
\end_layout

\begin_layout Standard
Now we turn to examine key characteristic of the abstract interpretation.
 First, observe that the abstract domain is finite.
 Finiteness of the domain has been argued in various stages of development
 when such argument was necessary.
\end_layout

\begin_layout Standard
We now define a partial ordering between abstract states
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering
\end_layout

\end_inset


\begin_inset Formula $\forall\eta_{1},\eta_{2}\in AState,\eta_{1}\sqsubseteq\eta_{2}$
\end_inset

 if 
\begin_inset Formula $AVar,AObjMem,Curried$
\end_inset

 components of 
\begin_inset Formula $\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\eta_{2}$
\end_inset

 are point-wise ordered, and 
\begin_inset Formula $AObj,AReturn,AEx$
\end_inset

 components are identical.
\end_layout

\begin_layout Standard
We also define an ordering between powersets of abstract states and associated
 values.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering of powersets
\end_layout

\end_inset


\begin_inset Formula $\forall e_{1},e_{2}\in\wp\left(AState\times a\right),e_{1}\sqsubseteq e_{2}$
\end_inset

 if 
\begin_inset Formula $\forall\left\langle \eta_{1},a_{1}\right\rangle \in e_{1}\exists\left\langle \eta_{2},a_{2}\right\rangle \in e_{2}$
\end_inset

 such that 
\begin_inset Formula $\eta_{1}\sqsubseteq\eta_{2}\wedge a_{1}=a_{2}$
\end_inset


\end_layout

\begin_layout Standard
Then we argue that the abstract interpretation is a monotonic framework.
 First, observe that the bind operation preserves the monotonicity when
 binding two monotonic functions.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:bindmono"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Monotonicity of bind operation
\end_layout

\end_inset

Given two monotonous functions 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 is also a monotonous function.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $p_{1}=F\ f\ \eta_{1}$
\end_inset

, 
\begin_inset Formula $p_{2}=F\ f\ \eta_{2}$
\end_inset

 such that 
\begin_inset Formula $\eta_{1}\sqsubseteq\eta_{2},p_{1}\sqsubseteq p_{2}$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Formula $q_{1}=F\bind G\ f\ \eta_{1}=\underset{\left\langle s,a\right\rangle \in p_{1}}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s\right)\ \\
\mbox{then}\ \left\{ \left\langle s,a\right\rangle \right\} \ \\
\mbox{else}\ G\ a\ f\ s
\end{gathered}
\right)$
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $q_{2}=F\bind G\ f\ \eta_{2}=\underset{\left\langle s,a\right\rangle \in p_{2}}{\bigcup}\left(\begin{gathered}\mbox{if}\ \mathtt{isterm}\left(s\right)\ \\
\mbox{then}\ \left\{ \left\langle s,a\right\rangle \right\} \ \\
\mbox{else}\ G\ a\ f\ s
\end{gathered}
\right)$
\end_inset


\end_layout

\begin_layout Proof
\begin_inset Formula $\forall q\in q_{1}$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $\mathtt{isterm}\left(q\right)$
\end_inset

 is true, then it is immediately shown that 
\begin_inset Formula $\exists q'\in q_{2},q\sqsubseteq q'$
\end_inset

 from the fact that 
\begin_inset Formula $p_{1}\sqsubseteq p_{2}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Otherwise, let 
\begin_inset Formula $p$
\end_inset

 be an element in 
\begin_inset Formula $p_{1}$
\end_inset

 such that 
\begin_inset Formula $q\in G\ f\ p$
\end_inset

.
 Monotonicity of 
\begin_inset Formula $F$
\end_inset

 function provides the existence of 
\begin_inset Formula $p'$
\end_inset

 such that 
\begin_inset Formula $p\sqsubseteq p'$
\end_inset

.
 Then, monotonicity of 
\begin_inset Formula $G$
\end_inset

 provides the existence of 
\begin_inset Formula $q'\in G\ f\ q$
\end_inset

 such that 
\begin_inset Formula $q\sqsubseteq q'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we turn to examine each of the abstract functions that we have devised.
 We omit a detailed function-by-function argument.
 Generally, observe that those functions can be categorised and argued as
 thus:
\end_layout

\begin_layout Enumerate
For the functions calculating values from given environment, an increase
 in the environment implies that the resulting environment is also increased.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an increase
 in the environment implies an increase in the updated environment.
\end_layout

\begin_layout Standard
With all the foregoing arguments, it stands to argue that the analytic framework
 is a monotonic framework.
 This result sufficiently proves the existence of the fixed point.
\end_layout

\begin_layout Section
Correctness
\end_layout

\begin_layout Standard
We define an abstraction relation 
\begin_inset Formula $\succ$
\end_inset

between concrete and abstract states.
 
\end_layout

\begin_layout Subsection
Definition of correct abstraction
\end_layout

\begin_layout Standard
First, we define an abstraction between values and other components of the
 states.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction of primitive values
\end_layout

\end_inset


\begin_inset Formula $Number\succ\mathbb{N}$
\end_inset

, 
\begin_inset Formula $Boolean\succ\mathbb{B}$
\end_inset

, 
\begin_inset Formula $Void\succ Void$
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction of objects and symbol maps
\end_layout

\end_inset


\begin_inset Formula $\alpha,OM\vdash n\succ m$
\end_inset

 if 
\begin_inset Formula $\alpha\left(n\right)\succ OM\left(m\right)$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\sigma:AVars\succ V:Vars$
\end_inset

 if 
\begin_inset Formula $\forall id\in V,\sigma\left(id\right)\succ V\left(id\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Function pointers
\end_layout

\end_inset


\begin_inset Formula $C:Curried\vdash\left\langle n,c,e\right\rangle \succ\left\langle m,P\right\rangle $
\end_inset

 if 
\end_layout

\begin_layout Definition
\begin_inset Formula $n=m$
\end_inset

, 
\begin_inset Formula $c=N\left(P\right)$
\end_inset

 and 
\end_layout

\begin_layout Definition
\begin_inset Formula $\exists A\in C\left(n,c,e\right),A_{k}\succ P_{k}$
\end_inset

 for 
\begin_inset Formula $1\leq k\leq c$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Now we are ready to define an abstraction between concrete and abstract
 states.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction relation
\end_layout

\end_inset

Given 
\begin_inset Formula $\rho\in CState$
\end_inset

, 
\begin_inset Formula $\eta\in AState$
\end_inset

, 
\begin_inset Formula $\eta\succ\rho$
\end_inset

 if
\end_layout

\begin_layout Definition
when 
\end_layout

\begin_layout Definition
\begin_inset Formula $\rho=\left\langle \begin{gathered}V:Var,OM:ObjMem,T:Object,\\
R:Return,E:Ex
\end{gathered}
\right\rangle $
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\eta=\left\langle \begin{gathered}\sigma:AVar,\alpha:AObjMem,\tau:AObj\\
C:AObjCurried,r:AReturn,e:AEx
\end{gathered}
\right\rangle $
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{align*}
\sigma\succ V & \wedge\\
\forall m\in OM\exists n\in\alpha,OM\left(m\right)\succ\alpha\left(n\right) & \wedge\\
\tau\succ T\wedge r\succ R\wedge e\succ E
\end{align*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction between powersets
\end_layout

\end_inset

Given 
\begin_inset Formula $p\in\wp\left(AState\times a\right),q\in\wp\left(CState\times c\right),p\succ q$
\end_inset

 if
\end_layout

\begin_layout Definition
\begin_inset Formula $\forall\rho\in q\exists\eta\in p,\left(\eta\succ\rho\right)\wedge\left(\rho,\eta\vdash a\succ c\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Morphism
\end_layout

\begin_layout Standard
First, we observe that the bind operation preserves morphisms of the functions
\end_layout

\begin_layout Definition
a pair of functions
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 shows a morphism over 
\begin_inset Formula $\succ$
\end_inset

 if the following condition is met
\end_layout

\begin_layout Definition
\begin_inset Formula $a\succ b\implies F'\left(a\right)\succ F\left(b\right)$
\end_inset


\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

 are such pairs of functions that shows a morphism over 
\begin_inset Formula $\succ$
\end_inset

, then 
\begin_inset Formula $\left\langle F\bind G,F'\bind G'\right\rangle $
\end_inset

 is also such pair.
\end_layout

\begin_layout Proof
\begin_inset Formula $\forall\rho\in CState$
\end_inset

, let 
\begin_inset Formula $p=F\left(\rho\right)$
\end_inset

,
\begin_inset Formula $p'=F\bind G\left(\rho\right)$
\end_inset

, 
\begin_inset Formula $\eta\in AState\mbox{ such that }\eta\succ\rho,$
\end_inset


\begin_inset Formula $q=F'\left(\eta\right)$
\end_inset

,
\begin_inset Formula $q'=F'\bind G'\left(\eta\right)$
\end_inset

, 
\begin_inset Formula $\forall p_{1}\in p,$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
when 
\begin_inset Formula $\mathtt{isterm}\left(p_{1}\right)$
\end_inset

 is true, then the morphism and 
\begin_inset Formula $\succ$
\end_inset

 relation imply that 
\begin_inset Formula $\exists q_{1}\in q,\mathtt{isterm}\left(q_{1}\right)$
\end_inset

.
 Given the definition of 
\begin_inset Formula $\bind$
\end_inset

 operation, 
\begin_inset Formula $p_{1}$
\end_inset

 and 
\begin_inset Formula $q_{1}$
\end_inset

are also elements of 
\begin_inset Formula $p'$
\end_inset

 and 
\begin_inset Formula $q'$
\end_inset


\end_layout

\begin_layout Enumerate
otherwise, morphism of 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

 gives that 
\begin_inset Formula $\forall p_{2}\in G\left(p_{1}\right)\exists q_{2}\in G'\left(q_{1}\right)\mbox{ such that }q_{2}\succ p_{2}$
\end_inset

.
 Such entities also exist in 
\begin_inset Formula $q'$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Finally, we observe that operations resulting from abstract functions and
 their corresponding concrete functions form such a morphism over 
\begin_inset Formula $\succ$
\end_inset

.
 As with the monotonicity argument, we omit function-by-function proof.
\end_layout

\begin_layout Section
Conclusion and Future Direction
\end_layout

\begin_layout Standard
As we have noted in the introduction, this work is a snapshot of an ongoing
 dialect between theory and practice, positively informing each other to
 gradually move towards a better theorisation (and practical implementation)
 of a difficult task of analysing dynamic languages.
 We sought to modularise the theoretic framework so that we can take an
 evolutionary approach.
 We anticipate that, as a result of having such theory, adding new features
 to the current model language while maintaining formality and rigour will
 be considerably less laborious than to invent a new incarnation of a more
 feature-complete model language and produce theory for it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "duck"
options "elsarticle-harv"

\end_inset


\end_layout

\end_body
\end_document
