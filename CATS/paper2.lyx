#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass CRPITStyle
\begin_preamble
\usepackage{stmaryrd}
\usepackage{syntax}
\usepackage{color}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\AtBeginDocument{\catcode`\_=8}

\newcommand{\dd}[1]{\llbracket#1\rrbracket}
\newcommand{\bind}{\Yright}

\exhyphenpenalty=10000\hyphenpenalty=10000

\newcommand\conferencenameandplace{19th Computing: Australasian Theory Symposium (CATS 2013), Adelaide, Australia, January 2013}
\newcommand\volumenumber{xxx}
\newcommand\conferenceyear{2013}
\newcommand\editorname{Anthony Wirth}
\end_preamble
\options fleqn
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "comment={[l]{\#}},commentstyle={\color{purple}\ttfamily},frame=leftline,identifierstyle={\color{black}},keywords={new, true, false, function, return, if, while, else, output, input},keywordstyle={\bfseries\underline},ndkeywords={this, global},ndkeywordstyle={\bfseries},numbers=left,numbersep=10pt,numberstyle={\tiny},sensitive=false,tabsize=2,xleftmargin=20pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Monadic Theory of Language Analysis and its Application in Type Analysis
 of Dynamic Language
\end_layout

\begin_layout Author
In-Ho Yi, Peter Schachte and Harald SÃ¸ndergaard
\begin_inset Newline newline
\end_inset

Department of Computing and Information Systems 
\begin_inset Newline newline
\end_inset

 The University of Melbourne, Victoria 3010, Australia 
\begin_inset Newline newline
\end_inset

 i.yi@student.unimelb.edu.au, schachte@unimelb.edu.au, harald@unimelb.edu.au
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
submittedstandard
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
We present a novel approach in construction and formalisation of a static
 analysis of a language, in which we formulate a polymorphic and parametric
 interpretation of a language common to both denotational semantics and
 static analysis.
 We apply this in analysing a duck-typing, reflective and function currying
 language.
 We show the benefit of this new approach in term of its terseness and modularit
y, and a new research methodology in which we gradually build language features
 and analysis on top of a previous incarnation of the theory.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are two distinct needs for the development of the present work.
 First, there is a theoretician's need to have a simple and elegant way
 of presenting a formalised argument of a static analysis which enables
 one to focus on what is at the heart of the analysis - definitions of abstract
 domain and their relations to the concrete domain of a language semantics.
 Denotational semantics is a step towards such direction.
 In this paper we endeavour to further modularise the system to the point
 where formal presentation of semantics and analysis can share a common
 framework that mostly deals with linguistic aspects of a programming language.
\end_layout

\begin_layout Standard
Second, there is a practical need of analysing dynamic languages that are
 finding more popularity in recent years.
 Traditionally these languages were termed 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

 languages, as they were mainly used for automating tasks and processing
 strings.
 However, with the advent of Web environment, languages such as Perl and
 PHP gained popularity as languages for web application development.
 On a client side, web pages make heavy use of JavaScript, a dynamic typing
 language, to deliver dynamic content to a browser.
 Recent years have seen an increasing use of JavaScript in a server side
 environment as well.
\end_layout

\begin_layout Standard
What these languages provide is an ability to rapidly prototype and validate
 application models in a real time REPL environment.
 Another strength comes from the fact that programmers do not need to have
 a class structure defined upfront.
 Rather, class structures and types of variables in general are dynamically
 built.
 This reduces an initial overhead of software design.
\end_layout

\begin_layout Standard
However, these features come at a cost.
 Lacking formal and static definition of type information makes dynamically
 typing languages harder to analyse.
 This difficulty causes several practical problems.
 
\end_layout

\begin_layout Itemize
As applications become more mature, more efforts are devoted to program
 unit testing or assertions to ensure type safety of systems.
 These extra overheads can sometimes outweigh the benefit of having a dynamicall
y typing language.
\end_layout

\begin_layout Itemize
Whereas programmers writing statically typed languages enjoy the abundance
 of development tools, choices of tools for aiding development of dynamically
 typed languages are limited, and lacking much of the power, largely due
 to the difficulty and sometimes infeasibility of type analysis.
\end_layout

\begin_layout Itemize
Not having a static type structure has a significant performance implication.
\end_layout

\begin_layout Standard
With these problems in mind, we design a model language that has a dynamism
 comparable to those in the aforementioned scripting languages, such as
 duck-typing, reflection and function currying.
 A notable omission is a closure scoping.
 However, allowing function currying gives enough expressive power to the
 language.
\end_layout

\begin_layout Standard
The two concerns are not distinct ones, but an interconnected dialectic.
 Theoretical need is there because of a difficulty of describing abstract
 and concrete meaning of dynamic languages which often allow side-effect
 causing, type-altering functions.
\end_layout

\begin_layout Section
Related work
\end_layout

\begin_layout Standard
On a theoretical side, denotational semantics is the starting point of our
 development of a theoretical system.
 The idea of incorporating monads in the denotational semantics, as presented
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998,Liang_Hudak:ESOP1996"

\end_inset

, directly inspired the present work.
 We extend the idea to the static analysis of a language.
\end_layout

\begin_layout Standard
An idea of constructing formulae with parametric types can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "Wadler:1989:TF:99370.99404"

\end_inset

.
 This work is a special application of the parametricity in the field of
 language semantics and analysis.
\end_layout

\begin_layout Standard
On the type analysis of dynamic languages, 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005,Guha:ESOP2011,Wrigstad:POPL2010"

\end_inset

 devise model languages and their semantics for the purpose of static analysis
 of dynamic languages.
 A major difference between them and the model language presented in this
 paper is that our model language is designed to capture the feature of
 real world languages that functions alter types through side-effect causing
 statements.
 Similarities and differences of this work compared to the cited works are
 given as we encounter them in this paper.
\end_layout

\begin_layout Standard
Type analysis plays a crucial part in compiling scripting languages, mainly
 to improve performance.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ancona:2007:RST:1297081.1297091,Dufour:2006"

\end_inset

 design restricted versions of a scripting language so that a static inference
 of types can be performed.
 Some techniques employed in those projects can also be found in this paper,
 the use of allocation sites as static references is an example.
\end_layout

\begin_layout Standard
An important use case of functions in dynamic typing language is 
\begin_inset Quotes eld
\end_inset

mixin
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand cite
key "Bracha:1990:MI:97946.97982"

\end_inset

) functions, where, by passing argument to such function the variable, the
 object is extended with extra methods.
 There are model languages and formalisations of mixin functions (
\begin_inset CommandInset citation
LatexCommand citet
key "Anderson:ECOOP2005,Mens:TR1996"

\end_inset

).
 Where those works seek to find a functional models for mixins, we model
 a language with side-effect causing functions that is expressive enough
 to program a mixin inheritance.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Jensen:SAS2009"

\end_inset

 built a feature-complete analyser for JavaScript.
 Our work can be progressed further to become a theoretical counterpart
 of the analyser.
 Furthermore, such attempt at formalising the analysis might pave a way
 for a further refinement and improvement.
\end_layout

\begin_layout Section
Analytic framework
\end_layout

\begin_layout Standard
We first describe a monadic theory of language analysis.
 In this section we produce a particular monadic construct, specifically
 designed for the purpose of analysis.
 We then examine key properties of such construct that is vital to our theory.
\end_layout

\begin_layout Subsection
State collection
\end_layout

\begin_layout Standard
We design a system that collects state transitions from one to another,
 as has occurred in a particular execution point.
 We augment a syntax tree by giving each node a unique ID.
 Then, the type of the end product that the system is collecting can be
 described as thus:
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
State Collection
\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $StateCol:Stmt\rightarrow State\rightarrow State$
\end_inset


\end_layout

\begin_layout Subsection
Monad
\end_layout

\begin_layout Standard
We define the monadic constructions.
 We define a type constructor 
\begin_inset Formula $M$
\end_inset

 and a bind operator 
\begin_inset Formula $\bind$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Type constructor
\end_layout

\end_inset

 Type constructor 
\begin_inset Formula $M$
\end_inset

 gives the following polymorphic type.
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{multline*}
M\ a=Func\rightarrow\left(State\times StateCol\right)\rightarrow\\
\left(State\times StateCol\times a\right)
\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
Here are some text.
\end_layout

\begin_layout Definition
New definition.
\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Bind operator
\end_layout

\end_inset

We define a bind operator 
\begin_inset Formula $\bind$
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M\ a\rightarrow\left(a\rightarrow M\ b\right)\rightarrow M\ b$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $T\ \bind\ U=\lambda f,r,s.U\ t\ f\ r'\ s'$
\end_inset

 where 
\begin_inset Formula $\left\langle r',s',t\right\rangle =T\ f\ r\ s$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Now we define a series of lift functions in order to provide modularity.
 For example, if a particular parametrised operation takes a state but only
 produces a value, it would be redundant to include a state as a part of
 its return type, to match the definition of monadic binding.
 In such case, we take a function that returns only a value, then lift such
 function to be used in the monadic binding.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Lift functions
\end_layout

\end_inset

We define following lift functions to incorporate non-monadic functions
 as a part of monadic transformation:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $I_{A}$
\end_inset

 is an identity state transformer that takes a constant and lifts it to
 an identity state transformer with the constant as a return value
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{A}:a\rightarrow M\ a\\
I_{A}\ v=\lambda f,r,s.\left\langle r,s,v\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{T}$
\end_inset

 lifts a state transformer with a return value to a monadic function
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{T}:\left(State\rightarrow State\times a\right)\rightarrow M\ a\\
I_{T}\ t=\lambda f,r,s.\left\langle r',s,a\right\rangle \ \mbox{where}\ \left\langle r',a\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{V}$
\end_inset

 lifts a function that takes a state and returns a value to a monadic function
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{V}:\left(State\rightarrow a\right)\rightarrow M\ a\\
I_{V}\ t=\lambda f,r,s.\left\langle r,s,t\ r\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{0}$
\end_inset

 takes a state transformation with no return value and attaches a meaningless
 return value to it
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{0}:\left(State\rightarrow State\right)\rightarrow M\ a\\
I_{0}\ t=\lambda f,r,s.\left\langle r',s,0\right\rangle \ \mbox{where}\ \left\langle r'\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Now we turn to examine properties of the monad.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Liang:phd1998"

\end_inset

 gives a survey of mathematical properties that monadic constructs exhibit.
 For the purpose our discussion, we limit ourselves to the discussion of
 properties of monads that are crucial in proving correctness of the system.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:bindmono"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Continuity of bind operation
\end_layout

\end_inset

Given two monotonous functions 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 is also a monotonous function.
\end_layout

\begin_layout Proof
For state and state collection arguments, 
\begin_inset Formula $F\bind G$
\end_inset

 is a series of monotonic transformation.
 Since the composition of two monotonic functions is also monotonic, state
 and state collection are monotonic.
\end_layout

\begin_layout Proof
For the result of 
\begin_inset Formula $F$
\end_inset

 passed on to 
\begin_inset Formula $G$
\end_inset

 as a bound variable, a return value from 
\begin_inset Formula $F$
\end_inset

 is monotonous to the input.
 The return value, then becomes part of input to the 
\begin_inset Formula $G$
\end_inset

 function, whose return value is also monotonous.
\end_layout

\begin_layout Theorem
Given two pairs of isomorphic functions 
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $F\left(\rho_{0}\right)=\left\langle \rho_{1},\alpha_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G\left(\rho_{1},\alpha_{1}\right)=\left\langle \rho_{2},\alpha_{2}\right\rangle $
\end_inset

, 
\begin_inset Formula $F'\left(\eta_{0}\right)=\left\langle \eta_{1},\upsilon_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G'\left(\eta_{1},\upsilon_{1}\right)=\left\langle \eta_{2},\upsilon_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Proof
If there are defined relationship 
\begin_inset Formula $\prec$
\end_inset

between two different domains that two pairs of functions are isomorphic
 with, isomorphicity of 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F'$
\end_inset

 provides that 
\begin_inset Formula $\rho_{0}\prec\eta_{0}$
\end_inset

, 
\begin_inset Formula $\rho_{1}\prec\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\alpha_{1}\prec\upsilon_{1}$
\end_inset

.
 Isomorphicity of 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

 gives 
\begin_inset Formula $\rho_{2}\prec\eta_{2}$
\end_inset

 and 
\begin_inset Formula $\alpha_{2}\prec\upsilon_{2}$
\end_inset

.
 Therefore 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Standard
Finally, we define a state collection helper function 
\begin_inset Formula $T_{S}$
\end_inset

, which takes a state transformation and appends to the transformation a
 new association of state transformation from initial state to the final
 state for a given statement.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
State collection helper function
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{alignat*}{2}
 & T_{S} & : & M\ a\rightarrow s\rightarrow M\ a\\
 & T_{S}\ X\ z & = & \lambda f,r,s.\left\langle r',s'',a\right\rangle \\
 &  &  & \begin{aligned}\mbox{where} & \left\langle r',s',a\right\rangle =X\ f\ r\ s\\
 & s''=s'\left[z\times r\mapsto r'\right]
\end{aligned}
\end{alignat*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We now have monadic constructs and auxiliary functions to describe a semantic
 functions of the model language.
\end_layout

\begin_layout Section
Model language
\end_layout

\begin_layout Standard
In this section we define a model language, 
\begin_inset Quotes eld
\end_inset

Simple Duck-Typing Language (SDTL)
\begin_inset Quotes erd
\end_inset

.
 Our model language features C-like syntax and resembles JavaScript.
 The key differences are:
\end_layout

\begin_layout Itemize
Absence of prototypes
\end_layout

\begin_layout Itemize
Lack of lexical scoping
\end_layout

\begin_layout Itemize
Function currying
\end_layout

\begin_layout Itemize
Explicit use of 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mathtt{global}$
\end_inset


\begin_inset Quotes erd
\end_inset

 keyword
\end_layout

\begin_layout Standard
It is our anticipation that, with the methodology that we employ, we can
 gradually extend this language to embrace much of the language features
 in real world.
\end_layout

\begin_layout Standard
Following is the syntax of SDTL.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{grammar}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<con> ::= Number | Boolean
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Lexpr> ::= ID | <Expr> `.' ID
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Expr> ::= <con> | `global' | `this'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Lexpr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  `new' <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Lexpr> `(' [<Expr> [,<Expr>]*]? `)'
\end_layout

\begin_layout Plain Layout


\backslash
alt  <Expr> <binop> <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt  `(' <Expr> `)'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<binop> ::= `+' | `-' | `*' | `/' | `>' | `<' | `=='
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<Stmt> ::= nil | <Stmt> `;' <Stmt> | <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `output' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt <LExpr> `=' <Expr>
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `if' `(' <Expr> `)' `{' <Stmt> `}' `else' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `while' `(' <Expr> `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `function' ID `(' [ID [, ID]*]? `)' `{' <Stmt> `}'
\end_layout

\begin_layout Plain Layout


\backslash
alt `return' <Expr>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{grammar}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{global}$
\end_inset

 is a reference to a global object, and the reference to global object is
 program invariant (akin to `window' in Client-side javascript or `global'
 in Node.js).
 When the number of arguments given is less than that of the arity of the
 function as declared, a function is partially applied, and a curried function
 is returned for a further currying or invoking.
 In SDTL, like many other dynamic languages, functions are first-class objects.
 As such, we can express mixins in this language:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "name=juice"
inline false
status open

\begin_layout Plain Layout

function Fruit(v) {
\end_layout

\begin_layout Plain Layout

	this.value = v;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function juicible(fruit, juice) {
\end_layout

\begin_layout Plain Layout

	function juiceMe(j,x) {
\end_layout

\begin_layout Plain Layout

		return this.value + j + x;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	fruit.juice = juiceMe(juice); #currying
\end_layout

\begin_layout Plain Layout

	global.answer=42;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

global.answer = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Juicibles
\end_layout

\begin_layout Plain Layout

apple = new Fruit(15);
\end_layout

\begin_layout Plain Layout

juicible(apple, 20);
\end_layout

\begin_layout Plain Layout

grape = new Fruit(30);
\end_layout

\begin_layout Plain Layout

juicible(grape, 50);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Non-juicibles
\end_layout

\begin_layout Plain Layout

banana = new Fruit(20);
\end_layout

\begin_layout Plain Layout

watermelon = new Fruit(25);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

output apple.juice(10); # 15 + 20 + 10
\end_layout

\begin_layout Plain Layout

output grape.juice(10); # 30 + 50 + 10
\end_layout

\begin_layout Plain Layout

output global.answer; # 42
\end_layout

\end_inset


\end_layout

\begin_layout Standard
`juicible' function turns an ordinary fruit object into a juicible object.
 Although constructed by the same constructor function, types of variables
 `apple' and `grape' is different to that of non-juicibles.
 This gets further complicated if we add in-line extensions:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "name=juice"
inline false
status open

\begin_layout Plain Layout

function cider(x,y) {
\end_layout

\begin_layout Plain Layout

	return this.juice(x) + y;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

apple.cider = cider;
\end_layout

\begin_layout Plain Layout

output apple.cider(20,50); # 15+20+20+50
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now object type `apple' is different to that of `grape'.
 In our analysis, we approximate the object types of a variable by treating
 each allocation site as a separate object type.
 A similar approach has been taken by 
\begin_inset CommandInset citation
LatexCommand cite
key "Jensen:SAS2009"

\end_inset

.
\end_layout

\begin_layout Section
Analysis
\end_layout

\begin_layout Standard
We now present a concrete and abstract analysis of SDTL.
 We first discuss briefly analysing functions in SDTL.
 Then we present a parametrised monadic semantics and concrete and abstract
 functions that we can plug-in to obtain denotational semantics and a static
 analysis.
 Finally, we use properties of monadic constructs to prove the correctness
 of the analysis.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
A difficulty of analysing a function in a reflective language without any
 given type information has been noted in 
\begin_inset CommandInset citation
LatexCommand cite
key "Bono:arXiv2012"

\end_inset

.
 A function in SDTL can cause side-effects, which in turn allows it to act
 as a class extender and a mixin creator.
 The 
\begin_inset Formula $JS_{0}$
\end_inset

 language, as developed and presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "Anderson:ECOOP2005,Anderson:ENTCS2005"

\end_inset

 is an attempt to contain a mixin creating behaviour in a functional model
 language.
 A similar approach has been taken in the discussion of 
\begin_inset Formula $\lambda_{S}$
\end_inset

 language as devised in 
\begin_inset CommandInset citation
LatexCommand citet
key "Guha:ESOP2011"

\end_inset

.
\end_layout

\begin_layout Standard
With languages like JavaScript, it is in the nature of such language that
 functions are side-effect causing, and much of the type operations are
 being done with the side-effects.
 If we model a function in such a manner, then the function itself is a
 state transformer of a type: 
\begin_inset Formula $State\rightarrow State\times a$
\end_inset

.
 Parameters and a receiver object can be a part of the state as we define.
 This formulation could have been further refined by distinguishing what
 remains the same throughout a function execution (a receiver object, for
 example), and those that can be transformed.
 However, we do not make such distinction for simplicity's sake.
\end_layout

\begin_layout Standard
Observe that in a given program, we have a mutually recursive collection
 of such functions.
 In order to analyse such a collection, we augment the syntax tree of the
 SDTL language to give each function declaration a unique ID.
 We then map to each unique ID the function as we have discussed.
 Given recursions, we formulate a fixed point of such collection with mutual
 reference.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathcal{F}_{D}=Y\lambda f\lambda n.\mathcal{S}_{D}\ \mathtt{Stmt}_{n}\ f
\]

\end_inset

where 
\begin_inset Formula $\mathcal{S}_{D}$
\end_inset

 is a denotational semantic function that takes a statement and a function
 fixed point, and returns an updated state and a return value.
 
\begin_inset Formula $\mathtt{Stmt}_{n}$
\end_inset

 is a function body of a function with ID 
\begin_inset Formula $n$
\end_inset

.
 We also define 
\begin_inset Formula $param_{n,k}$
\end_inset

 to denote the name of 
\begin_inset Formula $k^{\mbox{th}}$
\end_inset

 parameter of the function 
\begin_inset Formula $n$
\end_inset

.
 
\begin_inset Formula $arity_{n}$
\end_inset

 is an arity of the function 
\begin_inset Formula $n$
\end_inset

.
 These informations are all immediately available from the syntax tree of
 a given program.
\end_layout

\begin_layout Subsection
Semantic functions
\end_layout

\begin_layout Standard
Now, we define 
\begin_inset Formula $\mathcal{F}$
\end_inset

 and other semantic functions.
 As discussed earlier, definition of semantic functions has a state collector
 incorporated to cater for the needs of the analysis.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Semantic functions
\end_layout

\end_inset

We define a monadic denotational semantics of the SDTL program
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathcal{F} & : & f\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\cup\left\{ Void\right\} \right)\\
\mathcal{S} & : & Stmt\rightarrow s\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\cup\left\{ Void\right\} \right)\\
\mathcal{E} & : & Expr\rightarrow e\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\right)\\
\mathcal{L} & : & LExpr\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Definition
The functions are defined in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semmon"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \mathcal{F} & = & Y\lambda f.\lambda n.\mathcal{S}\ \mathtt{Stmt}_{n}\ \mathtt{sid}\left(\mathtt{Stmt}_{n}\right)\ f\\
 & \mathcal{S}\dd{S_{1};S_{2}} & = & T_{S}\ \left(\begin{aligned}S\ S_{1}\ \mathtt{sid}\left(S_{1}\right) & \bind\lambda r.\\
\mathtt{isterm}\left(r,S\ S_{2}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{return}\ e} & = & T_{S}\ \left(\mathcal{E}\ e\ \mathtt{eid}\left(e\right)\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right),I_{A}\ Void\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}\mathtt{else}S_{2}} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right),\mathcal{S}\ S_{2}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{id=e} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
I_{0}\ \mathtt{asg}\left(id,v\right) & \bind\lambda\_.\\
I_{A}\ Void
\end{aligned}
\right)\\
 & \mathcal{S}\dd{e_{0}.id=e_{1}} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
\mathcal{E}\ e_{1}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda r.\\
I_{0}\ \mathtt{set}\left(r,id,v\right) & \bind\lambda\_.\\
I_{A}\ Void
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{while}\left(e\right)S_{1}}\ f\ \rho_{0} & = & T_{S}\ \left(Y\lambda x.\lambda\rho,r.\mathtt{isterm}\left(r,\left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right)\bind\lambda v.\\
{\scriptstyle \begin{gathered}\mathtt{cond}\left(v,\left(\begin{gathered}\lambda f,\rho'.x\ \\
\left(\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right)f\ \rho'\right)
\end{gathered}
\right),\left(I_{\rho}\ Void\right)\right)\end{gathered}
}
\end{aligned}
\right)\ f\right)\ \rho_{0}\ {\scriptstyle Void}\right)\\
 & \mathcal{S}\dd{\mathtt{output}\ e} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ eid\left(e\right) & \bind\lambda v.\\
I_{0}\ \mathtt{output}\left(v\right) & \bind\lambda\_.\\
I_{A}\ Void
\end{aligned}
\right)\\
 & S\dd{{\scriptstyle \mathtt{function}}\ id\left(IDs\right)\ S_{1}}\ \mathtt{s} & = & T_{S}\ \left(\begin{aligned}I_{0}\ \mathtt{fundecl}\left(id,\mathtt{s}\right) & \bind\lambda\_.\\
I_{A}\ Void
\end{aligned}
\right)\\
 & \mathcal{E}\dd{con}\ \mathtt{eid} & = & I_{A}\ \mathtt{conval}\left(con\right)\\
 & \mathcal{E}\dd{\mathtt{global}}\ \mathtt{eid} & = & I_{V}\ \mathtt{obj}\left(0\right)\\
 & \mathcal{E}\dd{L}\ \mathtt{eid} & = & \mathcal{L}\ L\\
 & \mathcal{E}\dd{\mathtt{this}}\ \mathtt{eid} & = & I_{V}\ \mathtt{getthis}\\
 & \mathcal{E}\dd{\mathtt{input}}\ \mathtt{eid} & = & I_{T}\ \mathtt{getinput}\\
 & \mathcal{E}\dd{\mathtt{new}\ L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
I_{T}\ \mathtt{newobj} & \bind\lambda m.\\
\mathtt{call}\left(n,p,m,\mathtt{eid}\right) & \bind\lambda\_.\\
I_{A}\ m
\end{aligned}
\right)\\
 & \mathcal{E}\dd{L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,\mathtt{obj}\left(0,\rho\right),\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}.L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda t.\\
\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,t,\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}\ binop\ e_{1}}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda c_{0}.\\
\mathcal{E}\ e_{1}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda c_{1}.\\
I_{V}\ \mathtt{bin}\left(binop,c_{0},c_{1}\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{id} & = & \left(I_{V}\ \mathtt{val}\left(id\right)\right)\\
 & \mathcal{L}\dd{\mathtt{this}} & = & \left(I_{V}\ \mathtt{getthis}\left(\rho\right)\right)\\
 & \mathcal{L}\dd{\mathtt{global}} & = & \left(I_{V}\ \mathtt{obj}\left(0\right)\right)\\
 & \mathcal{L}\dd{e_{0}.id} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
I_{V}\ \mathtt{get}\left(v,id\right)
\end{aligned}
\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathtt{evalParam}$
\end_inset

 is a parameter evaluation auxiliary function, defined as following:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{gather*}
\mathtt{evalParam}:\left[ID\right]\times\left[Expr\right]\times\left[a\right]\times\mathcal{F}\times State\times StateCol\rightarrow State\times StateCol\times\left[a\right]\\
\mathtt{evalParam}\ \phi\ ps\ f\ \rho\ \sigma=\left\langle \rho,\sigma,ps\right\rangle \\
\mathtt{evalParam}\ \left[e|Exprs\right]\ ps\ f\ \rho\ \sigma=\mathtt{evalParam}\ Exprs\ \left[ps|con\right]\ f\ \rho_{1}\ \sigma_{1}\ \mbox{where}\left\langle \rho_{1},\sigma_{1},con\right\rangle =\mathcal{E}\ e\ f\ \rho\ \sigma
\end{gather*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Semantic functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "semmon"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Denotational semantics
\end_layout

\begin_layout Standard
We define a concrete domain and concrete functions to plug into the semantic
 functions, the end result of which is a state-collecting denotational semantics.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concrete domain
\end_layout

\end_inset

We define a concrete domain of a concrete state 
\begin_inset Formula $CState$
\end_inset

 as following:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ T,F\right\} \cup Objects\cup\\
 &  & FunctionPointers\\
Objects & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
FunctionPointers & = & \left\langle FP_{n},\left[Value\right]\right\rangle \\
CState & = & \left\langle Vars,ObjMem,This\right\rangle \\
Vars & = & id\rightarrow Value\\
ObjMem & = & n\rightarrow V\\
This & = & Objects
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concrete functions
\end_layout

\end_inset

We define concrete functions in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "concfunc"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \lambda f,\rho.\begin{cases}
s\ f\ \rho & v=Void\\
I_{\rho}\ v & \mbox{otherwise}
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\rho.\begin{cases}
s_{1}\ f\ \rho & v=true\\
s_{2}\ f\ \rho & v=false
\end{cases}\\
\mathtt{asg}\left(id,v\right) & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle V\left[id=v\right],OM,T\right\rangle \\
\mathtt{val}\left(id\right) & = & \lambda\left\langle V,OM,T\right\rangle .V\left(id\right)\\
\mathtt{get}\left(OBJ_{n},id\right) & = & \lambda\left\langle V,OM,T\right\rangle .OM\left(n\right)\\
\mathtt{set}\left(OBJ_{n},id,v\right) & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle V,OM\left[OBJ_{n}\left[id\mapsto v\right]\right],T\right\rangle \\
\mathtt{conval}\left(con\right) & = & con\\
\mathtt{obj}\left(n\right) & = & \lambda\left\langle V,OM,T\right\rangle .OM\left(n\right)\\
\mathtt{getthis} & = & \lambda\left\langle V,OM,T\right\rangle .T\\
\mathtt{getinput\left(\rho\right)} & = & \mbox{see note}\\
\mathtt{dooutput}\left(v\right) & = & \mbox{see note}\\
\mathtt{newobj} & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle \left\langle V,OM\left[n\mapsto\phi\right],T\right\rangle ,OBJ_{n}\right\rangle \ \mbox{where}\ n=N\left(OM\right)\\
\mathtt{call}\left(\left\langle FP_{n},C\right\rangle ,p,t,\_\right) & = & \lambda f,s,\left\langle V,OM,T\right\rangle .\begin{cases}
\begin{gathered}\left\langle \left\langle V,OM',T\right\rangle ,s',r\right\rangle \mbox{where}\left\langle \left\langle V',OM',T'\right\rangle ,s',r\right\rangle =\\
f\ n\ \left\langle \left[param_{n,k}\mapsto\left[C|p\right]_{k}\right],OM,t\right\rangle \ s
\end{gathered}
 & N\left(C\right)+N\left(p\right)=arity_{n}\\
\left\langle \left\langle V,OM,T\right\rangle ,s,\left\langle FP_{n},\left[C|p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}(id,n) & = & \lambda\left\langle V,OM,T\right\rangle .V\left[id\mapsto\left\langle FP_{n},\left[\right]\right\rangle \right]\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \mbox{perform binary operation between two constants}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
Note that we largely omit IO operation, since it is not a major concern
 of this paper.
 It is trivial to add another element to the state vector to take account
 of IO operations.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Concrete functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "concfunc"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Abstract interpretation
\end_layout

\begin_layout Standard
We now define an abstract domain and abstract functions.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstract domain
\end_layout

\end_inset

We define an abstract domain of an abstract state, 
\begin_inset Formula $AState$
\end_inset

 as following:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & \left\langle AVars,AObjMem,AThis,CurriedVals\right\rangle \\
P & = & \left\{ Number,Boolean\right\} \\
Obj & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
FunPointers & = & \left\langle FP_{n},\left[\wp\left(\begin{gathered}P\cup Obj\cup\left\{ FP_{n}\right\} \cup\\
\left\{ \left\langle FC,n,c,eid\right\rangle \right\} 
\end{gathered}
\right)\right]\right\rangle \\
AVal & = & P\cup Obj\cup FunPointers\\
AVars & = & id\rightarrow\wp\left(AVal\right)\\
AObjMem & = & n\rightarrow AVars\\
AThis & = & \wp\left(Obj\right)\\
CurriedVals & = & \left\langle n,c,eid\right\rangle \rightarrow\left[\wp\left(\begin{gathered}P\cup Obj\cup\\
\left\{ \left\langle FC,n,c,eid\right\rangle \right\} 
\end{gathered}
\right)\right]\\
 &  & \mbox{where \emph{n} is a function identifier \emph{c}}\\
 &  & \ \ c\mbox{ is a natural number}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset Formula $OBJ_{n}$
\end_inset

:
\end_layout

\begin_layout Standard
We number each of the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expressions as we parse the program.
 The number n corresponds to the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expression number.
\end_layout

\begin_layout Standard
In 
\begin_inset Formula $\left\langle FC,n,c,eid\right\rangle $
\end_inset

:
\end_layout

\begin_layout Standard
n = function number
\end_layout

\begin_layout Standard
c = number of arguments curried
\end_layout

\begin_layout Standard
eid = A uid of an expression from which this value has been produced
\end_layout

\end_deeper
\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Currying loop
\end_layout

\end_inset

 Consider the following SDTL program.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function foo(a,b) {
\end_layout

\begin_layout Plain Layout

	return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x = 0;
\end_layout

\begin_layout Plain Layout

while(input < 30) {
\end_layout

\begin_layout Plain Layout

	x = foo(x);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, in line 7, x is associated with a value 
\begin_inset Formula $\left\langle FP_{1},a\mapsto\left\{ Number,\left\langle FC,1,1,e_{1}\right\rangle \right\} \right\rangle $
\end_inset

 where 
\begin_inset Formula $e_{1}$
\end_inset

 is the eid of 
\begin_inset Formula $\mathtt{foo\left(x\right);}$
\end_inset

 in line 7.
 
\begin_inset Formula $\nu$
\end_inset

 has one entry 
\begin_inset Formula $\left\langle 1,1,e_{1}\right\rangle \mapsto\left\{ a\mapsto\left\{ 0,\left\langle FC,1,1,e_{1}\right\rangle \right\} \right\} $
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Finiteness of the abstract property
\end_layout

\end_inset

Given an SDTL program,
\begin_inset Formula $AState$
\end_inset

 has a finite domain
\end_layout

\begin_layout Proof
We show that each of the component 
\begin_inset Formula $AVars,AObjMem,AThis,CurriedVals$
\end_inset

 has a finite domain
\end_layout

\begin_deeper
\begin_layout Enumerate
First, we show that the number of possible
\begin_inset Formula $AVal$
\end_inset

 is finite.
\end_layout

\begin_deeper
\begin_layout Enumerate
Trivially,
\begin_inset Formula $P$
\end_inset

 is a set of two elements.
\end_layout

\begin_layout Enumerate
There are finite number of 
\emph on
new
\emph default
 expressions in a program.
 Therefore number of elements in 
\begin_inset Formula $Obj$
\end_inset

 is finite.
\end_layout

\begin_layout Enumerate
In case of 
\emph on
FunPointers
\end_layout

\begin_deeper
\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
There are a finite number of function declarations.
 Each function can only have a set number of parameters.
 There are a finite number of expressions in a program.
 Therefore, number of possible values of
\begin_inset Formula $\left\langle FC,n,c,eid\right\rangle $
\end_inset

is finite.
\end_layout

\begin_layout Enumerate
Each functions have a set number of accepted parameters.
 Therefore, the number of elements in the list is finite.
\end_layout

\begin_layout Enumerate
There are only a finite number of function declarations in a program.
\end_layout

\begin_layout Enumerate
Hence, 
\emph on
FunPointers
\emph default
 has a finite domain
\end_layout

\end_deeper
\begin_layout Enumerate
Then, 
\begin_inset Formula $AVal$
\end_inset

, a union of finite domains, also has a finite domain.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AVars$
\end_inset

 is a composite of two components: 
\emph on
id
\emph default
 and 
\begin_inset Formula $\wp\left(AVal\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
There are only a finite number of identifiers appearing in a program
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AVal$
\end_inset

 has a finite domain.
 Therefore, a powerset of it also has a finite domain.
\end_layout

\end_deeper
\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $AObjMem$
\end_inset

 has two components, finiteness of which are argued in 1 (b) and 2 respectively.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AThis$
\end_inset

 is a finite as it is a powerset of a finite domain (1 (b))
\end_layout

\begin_layout Enumerate
\begin_inset Formula $CurriedVals$
\end_inset

 has two components: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\langle n,c,eid\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left[\wp\left(P\cup Obj\cup\left\{ \left\langle FC,n,c,eid\right\rangle \right\} \right)\right]$
\end_inset

.
 Finiteness of both are argued in 1 (c).
\end_layout

\end_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering
\end_layout

\end_inset

We define a partial ordering 
\begin_inset Formula $\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqsubseteq\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle $
\end_inset

 between abstract environments as thus:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\sigma_{1}\sqsubseteq\sigma_{2}\ \mbox{if}\ \forall id\in\mbox{domain}\left(\sigma_{1}\right),\sigma_{1}\left(id\right)\subseteq\sigma_{2}\left(id\right)\\
\alpha_{1}\sqsubseteq\alpha_{2}\ \mbox{if}\ \forall n\in\mbox{domain}\left(\alpha_{1}\right),\alpha_{1}\left(n\right)\sqsubseteq\alpha_{2}\left(n\right)\\
\tau_{1}\sqsubseteq\tau_{2}\ \mbox{if}\ \tau_{1}\subseteq\tau_{2}\\
\nu_{1}\sqsubseteq\nu_{2}\ \mbox{if}\ \forall\left\langle n,c,eid\right\rangle \in\mbox{domain}\left(\nu_{1}\right)\\
\ \ \forall k\in\left\{ 1,2,3,\ldots,c\right\} ,\nu_{1}\left(\left\langle n,c,eid\right\rangle \right)_{k}\subseteq\nu_{2}\left(\left\langle n,c,eid\right\rangle \right)_{k}\\
\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqsubseteq\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle \equiv\\
\ \ \sigma_{1}\sqsubseteq\sigma_{2}\wedge\alpha_{1}\sqsubseteq\alpha_{2}\wedge\tau_{1}\sqsubseteq\tau_{2}\wedge\nu_{1}\sqsubseteq\nu_{2}
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We formulate a least upper bound between two abstract environments.
\end_layout

\begin_layout Theorem
Given two abstract environments 
\begin_inset Formula $\eta_{1}=\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \ \mbox{and}\ \eta_{2}=\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle $
\end_inset

, we can find a least upper bound by finding the value of 
\begin_inset Formula $\eta_{1}\sqcup\eta_{2}$
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\begin{gather*}
\sigma_{1}\sqcup\sigma_{2}=id\mapsto\sigma_{1}\left(id\right)\cup\sigma_{2}\left(id\right)\\
\alpha_{1}\sqcup\alpha_{2}=n\mapsto\sigma_{1}\left(n\right)\sqcup\sigma_{2}\left(n\right)\\
\tau_{1}\sqcup\tau_{2}=\tau_{1}\cup\tau_{2}\\
\nu_{1}\sqcup\nu_{2}=c\mapsto\nu_{1}\left(c\right)\cup\nu_{2}\left(c\right)\\
\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqcup\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle \equiv\\
\ \ \left\langle \sigma_{1}\sqcup\sigma_{2},\alpha_{1}\sqcup\alpha_{2},\tau_{1}\sqcup\tau_{2},\nu_{1}\sqcup\nu_{2}\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
Satisfying each lines of conditions gives an environment that can satisfy
 conditions set for the partial ordering of both environments.
\end_layout

\begin_layout Proof
Observe that if there is an upper bound 
\begin_inset Formula $\eta'=\left\langle \sigma',\alpha',\tau',\nu'\right\rangle $
\end_inset

 of two environments 
\begin_inset Formula $\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\eta_{2}$
\end_inset

, if 
\begin_inset Formula $\eta'\sqsubseteq\eta_{1}\sqcup\eta_{2}$
\end_inset

 then necessarily 
\begin_inset Formula $\eta'=\eta_{1}\sqcup\eta_{2}$
\end_inset

, since any missing elements in keys and values of 
\begin_inset Formula $\sigma',\alpha',\tau',\nu'$
\end_inset

 will violate the partial ordering condition.
\end_layout

\begin_layout Standard
We can then deduce that:
\end_layout

\begin_layout Lemma
\begin_inset Formula $\left(AState,\sqsubseteq\right)$
\end_inset

 is a chain complete partial ordering.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset

 We define abstract functions in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \lambda f,\eta.\begin{cases}
s\ f\ \eta & v=\left\{ Void\right\} \\
\left(s\ f\ \eta\right)\sqcup\left(I_{\rho}\ v\right) & Void\in v,N\left(v\right)>1\\
I_{\rho}\ v & \mbox{otherwise}\left(\mbox{i.e.}\ Void\notin v\right)
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\eta.\left(s_{1}\ f\ \eta\right)\sqcup\left(s_{2}\ f\ \eta\right)\\
\mathtt{asg}\left(id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \sigma\left[id=v\right],\alpha,\tau,\nu\right\rangle \\
\mathtt{val}\left(id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\sigma\left(id\right)\\
\mathtt{get}\left(n,id\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\{ \alpha\left(x\right)\mid OBJ_{x}\in n\right\} \\
\mathtt{set}\left(n,id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \sigma,\left\{ x\mid{OBJ_{x}\in\alpha,x=\begin{cases}
\alpha\left(x\right)\left[id\mapsto v\right] & OBJ_{x}\in n\\
\alpha\left(x\right) & \mbox{otherwise}
\end{cases}}\right\} ,\tau,\nu\right\rangle \\
\mathtt{conval}\left(con\right) & = & \begin{cases}
Number & con\in\mathbb{N}\\
Boolean & con\in\left\{ true,false\right\} 
\end{cases}\\
\mathtt{obj}\left(j\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\alpha\left(j\right)\\
\mathtt{getthis} & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\tau\\
\mathtt{getinput} & = & \lambda\eta.\left\langle \eta,\left\{ Number\right\} \right\rangle \\
\mathtt{dooutput}\left(v\right) & = & \lambda\eta.\eta\\
\mathtt{newobj} & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \left\langle \sigma,\alpha\left[n\mapsto\phi\right],\tau,\nu\right\rangle ,OBJ_{n},\nu\right\rangle \ \mbox{where}\ n=N\left(\alpha\right)\\
\mathtt{call}\left(n,p,t,e\right) & = & \lambda f,s,\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\underset{\left\langle FP_{x},C\right\rangle \in n}{\bigsqcup}\mathtt{scall}\left(\left\langle FP_{x},C\right\rangle ,p,t,f,\left\langle \sigma,\alpha,\tau,\nu\right\rangle ,s,e\right)\\
{\scriptstyle \mathtt{scall}\left(\left\langle FP_{n},C\right\rangle ,p,t,f,\left\langle \sigma,\alpha,\tau,\nu\right\rangle ,s,e\right)} & = & \begin{cases}
\begin{gathered}\left\langle \left\langle \sigma,\alpha',\tau,\nu'\right\rangle ,s',r'\right\rangle \ \mbox{where}\ \left\langle \left\langle \sigma',\alpha',\tau'\right\rangle ,s',r,\nu'\right\rangle =\\
f\ n\ \left\langle \left\{ param_{n,k}\mapsto\left[C|p\right]_{k}\right\} ,\alpha,\tau,\nu\right\rangle \ s
\end{gathered}
 & N\left(C\right)+N\left(p\right)=arity_{n}\\
\left\langle \left\langle \sigma,\alpha,\tau,\nu\left[\left\langle e,n,N\left(C\right)+N\left(p\right)\right\rangle \mapsto\left[C|p\right]\right]\right\rangle ,s,\left\langle FP_{n},\left[C|p\right],e\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \begin{cases}
\left\{ Number\right\}  & binop\in\left\{ '+','-','*','/'\right\} \\
\left\{ Boolean\right\}  & \mbox{otherwise}
\end{cases}\\
\mathtt{fundecl}\left(id,n\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\sigma\left[id\mapsto\left\langle FP_{n},\left[\right],n\right\rangle \right]
\end{eqnarray*}

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to argue for a completeness of an analysis, we first argue monotonicity
 of the interpretation.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:mono"

\end_inset

Abstract functions produce monotonic lambda functions
\end_layout

\begin_deeper
\begin_layout Proof
Following list of arguments cover all the functions:
\end_layout

\begin_deeper
\begin_layout Enumerate
Observe that for the functions calculating values from given parameters
 and an environment, an increase in the environment implies that the values
 we obtain are also increased.
 This is from the definition of the partial ordering.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an increase
 in the environment implies an increase in the updated environment.
\end_layout

\begin_layout Enumerate
In case of 
\begin_inset Formula $\mathtt{call}$
\end_inset

, its the least upper bound of results from 
\begin_inset Formula $\mathtt{scall}$
\end_inset

, which falls into categories 1 and 2.
 An increase in the results implies increase in the least upper bound of
 them.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
From theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:bindmono"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:mono"

\end_inset

 give the following important lemma:
\end_layout

\begin_layout Lemma
Abstract 
\begin_inset Formula $\mathcal{S},\mathcal{E}\ \mbox{and}\ \mathcal{L}$
\end_inset

 are monotonic functions.
\end_layout

\begin_layout Standard
Then, it stands to reason that fixed points exist for our analytic framework.
\end_layout

\begin_layout Lemma
Fixed points exist for an abstract 
\begin_inset Formula $\mathcal{F}$
\end_inset


\end_layout

\begin_layout Standard
Hence, it stands to reason that for any given program, we obtain an analysis
 of it.
\end_layout

\begin_layout Standard
Now we turn to examine the relationship between concrete and abstract domain.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction
\end_layout

\end_inset

 We define an abstraction relation between concrete and abstract environments,
 
\begin_inset Formula $\left\langle \sigma,\alpha,\tau,\nu\right\rangle \succ\left\langle V,OM,T\right\rangle $
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
\left\langle \sigma,\alpha,\tau,\nu\right\rangle \succ\left\langle V,OM,T\right\rangle \ \mbox{iff}\ \\
\ \ \forall id\in V\exists a\in\sigma\left(id\right),a\succ V\left(id\right)\mbox{ and }\tau\succ T\\
\forall z\in\mathbb{Z},\left\{ Number\right\} \succ z\\
\forall b\in\left\{ True,False\right\} ,\left\{ Boolean\right\} \succ b\\
OBJ_{m}\succ OBJ_{n}\ \mbox{if}\ \eta\vdash OBJ_{m}\succ OM\vdash OBJ_{n}\\
\left\langle FP_{m},\left[c'\right],e\right\rangle \succ\left\langle FP_{n},\left[c\right]\right\rangle \ \mbox{if}\ m=n\ \\
\ \ N\left(c\right)=N\left(c'\right)\ \mbox{and}\ \forall c_{k}\in c,\eta\vdash c'_{k}\succ c_{k}
\end{gather*}

\end_inset


\end_layout

\begin_layout Definition
In turn, contextual definitions of abstract object and function pointer
 values are defined as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
\left\langle \sigma,\alpha,\tau,\nu\right\rangle \vdash OBJ_{m}\succ OBJ_{n}\mbox{ if }\\
\forall id\in OM\left(n\right),OM\left(n\right)\left(id\right)\in Z\cup\left\{ True,False\right\} ,\\
\ \ \alpha\left(m\right)\left(id\right)\succ OM\left(n\right)\left(id\right)\\
\forall id\in OM\left(n\right),OM\left(n\right)\left(id\right)=OBJ_{x},\alpha\left(m\right)=OBJ_{y},\\
\ \ \alpha\left(y\right)\succ OBJ_{x}
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We now define abstraction and concretisation relations between an abstract
 domain and a powerset of concrete domain.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction and concretisation
\end_layout

\end_inset

 We define abstraction function 
\begin_inset Formula $P$
\end_inset

 and concretisation function 
\begin_inset Formula $Q$
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
P:\wp\left(CState\right)\rightarrow AState\\
P\left(r\right)=\bigsqcup\left\{ \eta|\rho\in r,\eta\succ\rho\right\} \\
Q:AState\rightarrow\wp\left(CState\right)\\
Q\left(\eta\right)=\left\{ r|r\in\rho,\eta\succ\rho\right\} 
\end{gather*}

\end_inset


\end_layout

\begin_layout Definition
Note that, as one would expect, we find a Galois connection between the
 abstract domain and the collection of concrete states.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "thm:galois"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Galois connection
\end_layout

\end_inset


\begin_inset Formula $\left(P,Q\right)$
\end_inset

 forms a Galois connection between 
\begin_inset Formula $\left(AState,\sqsubseteq\right)$
\end_inset

 and
\begin_inset Formula $\left(\wp\left(CState\right),\subseteq\right)$
\end_inset


\end_layout

\begin_layout Standard
Now we turn to argue isomorphism.
 For the simplicity of argument, without losing generality, we lift abstract
 functions to produce a lambda function of the type 
\begin_inset Formula $\left(State\times StateCol\right)\rightarrow\left(State\times StateCol\times a\right)$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Isomorphism
\end_layout

\end_inset

For all abstract and concrete functions, the following holds true: when
 
\begin_inset Formula $F\left(n_{c},id_{c},v_{c},p_{c},t_{c},e_{c},j_{c}\right)=f,f\left(s_{a},\rho\right)=\left\langle s_{c}',\rho',V_{C}\right\rangle ,G\left(n_{a},id_{a},v_{a},p_{a},t_{a},e_{a},j_{a}\right)=g,g\left(s_{a},\eta\right)=\left\langle s_{a}',\eta',V_{A}\right\rangle $
\end_inset

 
\end_layout

\begin_layout Theorem
\begin_inset Formula 
\begin{multline*}
\left(\begin{array}{ccc}
\eta\vdash n_{a} & \succ & \rho\vdash n_{c}\\
id_{a} & = & id_{c}\\
\eta\vdash v_{a} & \succ & \rho\vdash v_{c}\\
\eta\vdash p_{a,k} & \succ & \rho\vdash p_{c,k}\mbox{ for all\ }k\\
\eta\vdash t_{a} & \succ & \rho\vdash t_{c}\\
e_{a} & = & \rho\vdash e_{c}\\
\eta\vdash OBJ_{j_{a}} & \succ & \rho\vdash OBJ_{j_{c}}
\end{array}\right)\implies\\
\left(\left\langle s_{a},\eta\right\rangle \succ\left\langle s_{c},\rho\right\rangle \implies\left\langle s_{a}',\eta',V_{A}\right\rangle \succ\left\langle s_{c}'\rho',V_{C}\right\rangle \right)
\end{multline*}

\end_inset


\end_layout

\begin_layout Theorem
(ignoring conditions set for parameters that the function is not taking)
\end_layout

\begin_layout Proof
As with 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:mono"

\end_inset

, we categorise our discussion as following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Observe that for the functions calculating values from given parameters
 and an environment, isomorphicity between parameters and given environments
 implies isomorphicity of the results.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an isomorphicity
 between given environments and between parameters imply an isomorphicity
 in the updated environments.
\end_layout

\begin_layout Enumerate
In case of 
\begin_inset Formula $\mathtt{call}$
\end_inset

, its the least upper bound of results from 
\begin_inset Formula $\mathtt{scall}$
\end_inset

, which falls into categories 1 and 2.
 Given Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:galois"

\end_inset

, when 
\begin_inset Formula $\mathtt{scall}$
\end_inset

 functions are isomorphic, then so are 
\begin_inset Formula $\mathtt{call}$
\end_inset

 functions.
\end_layout

\end_deeper
\begin_layout Standard
These theorems together with the properties of bind operator give rise to
 an important lemma in proving the correctness of the analysis.
 That is:
\end_layout

\begin_layout Lemma
Abstract 
\begin_inset Formula $\mathcal{F},\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 and concrete 
\begin_inset Formula $\mathcal{F},\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 are isomorphic.
\end_layout

\begin_layout Standard
Now we are ready to argue correctness.
\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Correctness of the analysis
\end_layout

\end_inset

 Given an SDTL program, 
\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $\mathcal{F}\ 0\ \left\langle \phi,\left\{ 0\mapsto\phi\right\} ,OBJ_{0}\right\rangle \ \phi=\rho'\ S_{C}$
\end_inset

 and 
\begin_inset Formula $\mathcal{F}\ 0\ \left\langle \phi,\left\{ 0\mapsto\phi\right\} ,\left\{ OBJ_{0}\right\} ,\phi\right\rangle \ \phi=\eta'\ S_{A}$
\end_inset

 then 
\begin_inset Formula $S_{C}$
\end_inset

 and 
\begin_inset Formula $S_{A}$
\end_inset

 are related in the following manner:
\end_layout

\begin_layout Theorem
\begin_inset Formula $\forall sid\in P,\exists\rho_{0},\rho_{1},\rho_{0}\times\rho_{1}\in S_{A}\left(sid\right)\rightarrow\exists\eta_{0},\eta_{1},\eta_{0}\times\eta_{1}\in S_{A}\left(sid\right)\wedge\eta_{0}\succ\rho_{0}\wedge\eta_{1}\succ\rho_{1}$
\end_inset

 where 
\begin_inset Formula $P$
\end_inset

 is set of all statement IDs in the program.
\end_layout

\begin_layout Proof
Recall the isomorphicity between abstract and concrete functions.
 If there is a state collected in the concrete result, then it is implied
 that an abstraction of such state is collected in an abstract result.
\end_layout

\begin_layout Subparagraph
Dual of the analysis
\end_layout

\begin_layout Standard
Partial ordering theory provides that what holds true for the particular
 partial ordering will also hold true for a dual of it.
 We show the dual of this analysis by the following example.
\end_layout

\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Dual
\end_layout

\end_inset

Consider the following program.
\end_layout

\begin_layout Example
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function object() { this.value = 1; }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function foo(x) {
\end_layout

\begin_layout Plain Layout

	if(input > 20) { 
\end_layout

\begin_layout Plain Layout

		x.propA = 20;
\end_layout

\begin_layout Plain Layout

		x.propC = 15;
\end_layout

\begin_layout Plain Layout

	else {
\end_layout

\begin_layout Plain Layout

		x.propB = False;
\end_layout

\begin_layout Plain Layout

		x.propC = 15;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

z = new object(); # 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(input > 15) {
\end_layout

\begin_layout Plain Layout

	a = new object(); # 2
\end_layout

\begin_layout Plain Layout

	foo(a);
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

	a = new object(); # 3
\end_layout

\begin_layout Plain Layout

	foo(a);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

output a.value + a.propC;
\end_layout

\end_inset


\end_layout

\begin_layout Example
we obtain different results depending on the kind of analysis we perform.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\subseteq$
\end_inset

 ordering
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\sigma_{\subseteq} & = & \left\{ \begin{alignedat}{2}z & \mapsto & \left\{ OBJ_{1}\right\} \\
a & \mapsto & \left\{ OBJ_{2},OBJ_{3}\right\} 
\end{alignedat}
\right\} \\
\alpha_{\subseteq} & = & \left\{ \begin{alignedat}{2}1 & \mapsto & \left\{ \mathtt{value}\mapsto\left\{ Number\right\} \right\} \\
2,3 & \mapsto & \left\{ \begin{gathered}\mathtt{value}\mapsto\left\{ Number\right\} \\
\mathtt{propA}\mapsto\left\{ Number\right\} \\
\mathtt{propB}\mapsto\left\{ Boolean\right\} \\
\mathtt{propC}\mapsto\left\{ Number\right\} 
\end{gathered}
\right\} 
\end{alignedat}
\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\supseteq$
\end_inset

 ordering
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\sigma_{\supseteq} & = & \left\{ \begin{alignedat}{2}z & \mapsto & \left\{ OBJ_{1}\right\} \\
a & \mapsto & \left\{ \right\} 
\end{alignedat}
\right\} \\
\alpha_{\supseteq} & = & \left\{ \begin{alignedat}{2}1 & \mapsto & \left\{ \mathtt{value}\mapsto\left\{ Number\right\} \right\} \\
2,3 & \mapsto & \left\{ \begin{gathered}\mathtt{value}\mapsto\left\{ Number\right\} \\
\mathtt{propC}\mapsto\left\{ Number\right\} 
\end{gathered}
\right\} 
\end{alignedat}
\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Given our treatment of each new expression as a creation of a type of its
 own, the result that we obtain for 
\begin_inset Formula $\sigma_{\supseteq}$
\end_inset

 might be too limiting and imprecise.
 We could use the combination of 
\begin_inset Formula $\sigma_{\subseteq}$
\end_inset

 and 
\begin_inset Formula $\alpha_{\supseteq}$
\end_inset

 to calculate a member of an object that is referred to by a variable must
 have.
 Combinations of results from may and must analysis is helpful in designing
 an IDE for a programming language, where the IDE can statically inform
 the programmer what members would an object must have or may have at a
 particular program point.
\end_layout

\begin_layout Section
Conclusion and Future Direction
\end_layout

\begin_layout Standard
As we have noted in the introduction, this work is a snapshot of an ongoing
 dialect between theory and practice, positively informing each other to
 gradually move towards a better theorisation (and practical implementation)
 of a difficult task of analysing dynamic languages.
 We sought to modularise the theoretic framework so that we can take an
 evolutionary approach.
 We anticipate that, as a result of having such theory, adding new features
 to the current SDTL while maintaining formality and rigour will be considerably
 less laborious than to invent a new incarnation of a more feature-complete
 model language and produce theory for it.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "duck"
options "elsarticle-harv"

\end_inset


\end_layout

\end_body
\end_document
