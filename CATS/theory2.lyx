#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass CRPITStyle
\begin_preamble
\usepackage{stmaryrd}
\newcommand{\dd}[1]{\llbracket#1\rrbracket}
\newcommand{\bind}{\Yright}
\end_preamble
\options fleqn
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 0cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Paragraph
Statement to initial and final state mapping
\end_layout

\begin_layout Standard
We design functions to collect state transitions as they occur in the course
 of the execution of a program.
 The 
\begin_inset Quotes eld
\end_inset

state collection
\begin_inset Quotes erd
\end_inset

 has a type:
\end_layout

\begin_layout Standard
\begin_inset Formula $StateCol:Stmt\rightarrow State\rightarrow State$
\end_inset


\end_layout

\begin_layout Paragraph
Auxiliary functions
\end_layout

\begin_layout Standard
Given sheer complexity of the task of analysing SDTL language, we define
 a series of auxiliary functions to help make formulation terse and more
 expressive.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Type constructor
\end_layout

\end_inset

 We define a type constructor 
\begin_inset Formula $M$
\end_inset

 as the following polymorphic type
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{multline*}
M\ a=Func\rightarrow\left(State\times StateCol\right)\rightarrow\\
\left(State\times StateCol\times a\right)
\end{multline*}

\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Bind operator
\end_layout

\end_inset

We define a bind operator 
\begin_inset Formula $\bind$
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula $\left(\bind\right):M\ a\rightarrow\left(a\rightarrow M\ b\right)\rightarrow M\ b$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $T\ \bind\ U=\lambda f,r,s.U\ t\ f\ r'\ s'$
\end_inset

 where 
\begin_inset Formula $\left\langle r',s',t\right\rangle =T\ f\ r\ s$
\end_inset


\end_layout

\begin_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Lift functions
\end_layout

\end_inset

We define following lift functions to incorporate non-monadic functions
 as a part of monadic transformation:
\end_layout

\begin_layout Itemize
\begin_inset Formula $I_{A}$
\end_inset

is an identity state transformer that takes a constant and lifts it to a
 identity state transformer with the constant as a return value
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{a}:a\rightarrow b\rightarrow M\ a\\
I_{a}\ v=\lambda f,r,s.\left\langle r,s,v\right\rangle 
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $I_{T}$
\end_inset

 lifts a state transformer with a return value to a monadic function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{S}:\left(State\rightarrow State\times a\right)\rightarrow M\ a\\
I_{S}\ t=\lambda f,r,s.\left\langle r',s,a\right\rangle \ \mbox{where}\ \left\langle r',a\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $I_{V}$
\end_inset

 lifes a function that takes a state and returns a value to a monadic function
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{V}:\left(State\rightarrow a\right)\rightarrow M\ a\\
I_{V}\ t=\lambda f,r,s.\left\langle r,s,t\ r\right\rangle 
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $I_{0}$
\end_inset

 takes a state transformation with no return value and attach to it a meaningles
s return value
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
I_{0}:\left(State\rightarrow State\right)\rightarrow M\ a\\
I_{0}\ t=\lambda f,r,s.\left\langle r',s,0\right\rangle \ \mbox{where}\ \left\langle r'\right\rangle =t\ r
\end{gather*}

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Liang_modularmonadic"

\end_inset

 gives a survey of mathematical properties that monadic constructs exhibit.
 For the purpose our discussion, we limit ourselves to the discussion of
 properties of monads that are crucial in proving correctness of the system.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:bindmono"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Continuity of bind operation
\end_layout

\end_inset

Given two monotonous functions 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $G$
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 is also a monotonous function.
\end_layout

\begin_layout Proof
For state and state collection arguments, 
\begin_inset Formula $F\bind G$
\end_inset

 is a series of monotonic transformation.
 Since the composition of two monotonic functions is also monotonic, state
 and state collection are monotonic.
\end_layout

\begin_layout Proof
For the result of 
\begin_inset Formula $F$
\end_inset

 passed on to 
\begin_inset Formula $G$
\end_inset

 as a bound variable, a return value from 
\begin_inset Formula $F$
\end_inset

 is monotonous to the input.
 The return value, then becomes part of input to the 
\begin_inset Formula $G$
\end_inset

 function, whose return value is also monotonous.
\end_layout

\begin_layout Theorem
Given two pairs of isomorphic functions 
\begin_inset Formula $\left\langle F,F'\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle G,G'\right\rangle $
\end_inset

, 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $F\left(\rho_{0}\right)=\left\langle \rho_{1},\alpha_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G\left(\rho_{1},\alpha_{1}\right)=\left\langle \rho_{2},\alpha_{2}\right\rangle $
\end_inset

, 
\begin_inset Formula $F'\left(\eta_{0}\right)=\left\langle \eta_{1},\upsilon_{1}\right\rangle $
\end_inset

, 
\begin_inset Formula $G'\left(\eta_{1},\upsilon_{1}\right)=\left\langle \eta_{2},\upsilon_{2}\right\rangle $
\end_inset


\end_layout

\begin_layout Proof
If there are defined relationship 
\begin_inset Formula $\prec$
\end_inset

between two different domains that two pairs of functions are isomorphic
 with, isomorphicity of 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F'$
\end_inset

 provides that 
\begin_inset Formula $\rho_{0}\prec\eta_{0}$
\end_inset

, 
\begin_inset Formula $\rho_{1}\prec\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\alpha_{1}\prec\upsilon_{1}$
\end_inset

.
 Isomorphicity of 
\begin_inset Formula $G$
\end_inset

 and 
\begin_inset Formula $G'$
\end_inset

 gives 
\begin_inset Formula $\rho_{2}\prec\eta_{2}$
\end_inset

 and 
\begin_inset Formula $\alpha_{2}\prec\upsilon_{2}$
\end_inset

.
 Therefore 
\begin_inset Formula $F\bind G$
\end_inset

 and 
\begin_inset Formula $F'\bind G'$
\end_inset

 are also isomorphic.
\end_layout

\begin_layout Definition
\begin_inset Argument
status collapsed

\begin_layout Plain Layout
State collector function
\end_layout

\end_inset

We define a state collection helper function 
\begin_inset Formula $T_{S}$
\end_inset

, which takes a state transformation and appends to the transformation a
 new association of state transformation from initial state to the final
 state for a given statement.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{alignat*}{2}
 & T_{S} & : & M\ a\rightarrow s\rightarrow M\ a\\
 & T_{S}\ X\ s & = & \lambda f,r,s.\left\langle r',s'',a\right\rangle \\
 &  &  & \begin{aligned}\mbox{where} & \left\langle r',s',a\right\rangle =X\ f\ r\ s\\
 & s''=s'\left[s\times r\mapsto r'\right]
\end{aligned}
\end{alignat*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Denotational semantics
\end_layout

\end_inset

We now define a denotational semantics of the SDTL program
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathcal{F} & : & f\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\cup\left\{ Void\right\} \right)\\
\mathcal{S} & : & Stmt\rightarrow s\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\cup\left\{ Void\right\} \right)\\
\mathcal{E} & : & Expr\rightarrow e\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\right)\\
\mathcal{L} & : & LExpr\rightarrow\mathcal{F}\rightarrow\left(State\times StateCol\right)\rightarrow\\
 &  & \left(State\times StateCol\times a\right)
\end{eqnarray*}

\end_inset


\end_layout

\end_deeper
\begin_layout Definition
Definition for those functions are given in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "semmon"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{align*}
 & \mathcal{F} & = & Y\lambda f.\lambda n.\mathcal{S}\ \mathtt{Stmt}_{n}\ \mathtt{sid}\left(\mathtt{Stmt}_{n}\right)\ f\\
 & \mathcal{S}\dd{S_{1};S_{2}} & = & T_{S}\ \left(\begin{aligned}S\ S_{1}\ \mathtt{sid}\left(S_{1}\right) & \bind\lambda r.\\
\mathtt{isterm}\left(r,S\ S_{2}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{return}\ e} & = & T_{S}\ \left(\mathcal{E}\ e\ \mathtt{eid}\left(e\right)\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}}\ f & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right),I_{\alpha}\ Void\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{if}\left(e\right)S_{1}\mathtt{else}S_{2}}\ f & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{cond}\left(v,\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right),\mathcal{S}\ S_{2}\ \mathtt{sid}\left(S_{2}\right)\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{id=e} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right) & \bind\lambda v.\\
\mathtt{asg}\left(id,v\right) & \bind\lambda\_.\\
I_{\alpha}\ NoReturn
\end{aligned}
\right)\\
 & \mathcal{S}\dd{e_{0}.id=e_{1}} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
\mathcal{E}\ e_{1}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda r.\\
I_{T}\ \mathtt{set}\left(r,id,v\right)
\end{aligned}
\right)\\
 & \mathcal{S}\dd{\mathtt{while}\left(e\right)S_{1}}\ f\ \rho & = & T_{S}\ \left(Y\lambda x.\lambda\rho,r.\mathtt{isterm}\left(r,\left(\begin{aligned}\mathcal{E}\ e\ \mathtt{eid}\left(e\right)\bind\lambda v.\\
{\scriptstyle \begin{gathered}\mathtt{cond}(v,\left(\lambda f,\rho'.x\ \left(\mathcal{S}\ S_{1}\ \mathtt{sid}\left(S_{1}\right)f\ \rho'\right)\right)\\
,\left(,I_{\rho}\ Void\right))
\end{gathered}
}
\end{aligned}
\right)\ f\right)\right)\ \rho\ {\scriptstyle Void}\\
 & \mathcal{S}\dd{\mathtt{output}\ e} & = & T_{S}\ \left(\begin{aligned}\mathcal{E}\ e\ eid\left(e\right) & \bind\lambda v.\\
\mathtt{output}\left(v\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{con}\ \mathtt{eid} & = & I_{\alpha}\ \mathtt{conval}\left(con\right)\\
 & \mathcal{E}\dd{\mathtt{global}}\ \mathtt{eid} & = & I_{V}\ \mathtt{obj}\left(0\right)\\
 & \mathcal{E}\dd{L}\ \mathtt{eid} & = & \mathcal{L}\ L\\
 & \mathcal{E}\dd{\mathtt{this}}\ \mathtt{eid} & = & I_{V}\ \mathtt{getthis}\\
 & \mathcal{E}\dd{\mathtt{input}}\ \mathtt{eid} & = & I_{T}\ \mathtt{getinput}\\
 & \mathcal{E}\dd{\mathtt{new}\ L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
I_{T}\ \mathtt{newobj} & \bind\lambda m.\\
\mathtt{call}\left(n,p,m,\mathtt{eid}\right) & \bind\lambda\_.\\
I_{\alpha}\ m
\end{aligned}
\right)\\
 & \mathcal{E}\dd{L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,\mathtt{obj}\left(0,\rho\right),\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}.L\left(E*\right)}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda t.\\
\mathcal{L}\ L & \bind\lambda n.\\
\mathtt{evalParams}\ n\ E*\ \phi & \bind\lambda p.\\
\mathtt{call}\left(n,p,t,\mathtt{eid}\right)
\end{aligned}
\right)\\
 & \mathcal{E}\dd{e_{0}\ binop\ e_{1}}\ \mathtt{eid} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda c_{0}.\\
\mathcal{E}\ e_{1}\ \mathtt{eid}\left(e_{1}\right) & \bind\lambda c_{1}.\\
I_{V}\ \mathtt{bin}\left(binop,c_{0},c_{1}\right)
\end{aligned}
\right)\\
 & \mathcal{L}\dd{id} & = & \left(I_{V}\ \mathtt{val}\left(id\right)\right)\\
 & \mathcal{L}\dd{\mathtt{this}} & = & \left(I_{V}\ \mathtt{getthis}\left(\rho\right)\right)\\
 & \mathcal{L}\dd{\mathtt{global}} & = & \left(I_{V}\ \mathtt{obj}\left(0\right)\right)\\
 & \mathcal{L}\dd{e_{0}.id} & = & \left(\begin{aligned}\mathcal{E}\ e_{0}\ \mathtt{eid}\left(e_{0}\right) & \bind\lambda v.\\
I_{V}\ \mathtt{get}\left(v,id\right)
\end{aligned}
\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Plain Layout
Where
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathtt{Stmt}_{n}$
\end_inset

 is a function body of a function numbered 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $\mathtt{evalParam}$
\end_inset

 is a parameter evaluation auxiliary function, defined as following:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{gather*}
\mathtt{evalParam}:\left[ID\right]\times\left[Expr\right]\times\left[a\right]\times\mathcal{F}\times State\times StateCol\rightarrow State\times StateCol\times\left[a\right]\\
\mathtt{evalParam}\ \phi\ ps\ f\ \rho\ \sigma=\left\langle \rho,\sigma,ps\right\rangle \\
\mathtt{evalParam}\ \left[e|Exprs\right]\ ps\ f\ \rho\ \sigma=\mathtt{evalParam}\ Exprs\ \left[ps|con\right]\ f\ \rho_{1}\ \sigma_{1}\\
\ \mbox{where}\left\langle \rho_{1},\sigma_{1},con\right\rangle =\mathcal{E}\ e\ f\ \rho\ \sigma
\end{gather*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Semantic monadic functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "semmon"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concrete domain
\end_layout

\end_inset

We define a concrete domain of a concrete state 
\begin_inset Formula $CState$
\end_inset

 as following:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
Value & = & \mathbb{Z}\cup\left\{ T,F\right\} \cup Objects\cup\\
 &  & FunctionPointers\\
Objects & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
FunctionPointers & = & \left\langle FP_{n},\left[Value\right]\right\rangle \\
CState & = & \left\langle Vars,ObjMem,This\right\rangle \\
Vars & = & id\rightarrow Value\\
ObjMem & = & n\rightarrow V\\
This & = & Objects
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Concrete functions
\end_layout

\end_inset

We define concrete functions in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "concfunc"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \lambda f,\rho.\begin{cases}
s\ f\ \rho & v=Void\\
I_{\rho}\ v & \mbox{otherwise}
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\rho.\begin{cases}
s_{1}\ f\ \rho & v=true\\
s_{2}\ f\ \rho & v=false
\end{cases}\\
\mathtt{asg}\left(id,v\right) & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle V\left[id=v\right],OM,T\right\rangle \\
\mathtt{val}\left(id\right) & = & \lambda\left\langle V,OM,T\right\rangle .V\left(id\right)\\
\mathtt{get}\left(OBJ_{n},id\right) & = & \lambda\left\langle V,OM,T\right\rangle .OM\left(n\right)\\
\mathtt{set}\left(OBJ_{n},id,v\right) & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle V,OM\left[OBJ_{n}\left[id\mapsto v\right]\right],T\right\rangle \\
\mathtt{conval}\left(con\right) & = & con\\
\mathtt{obj}\left(n\right) & = & \lambda\left\langle V,OM,T\right\rangle .OM\left(n\right)\\
\mathtt{getthis} & = & \lambda\left\langle V,OM,T\right\rangle .T\\
\mathtt{getinput\left(\rho\right)} & = & \mbox{see note}\\
\mathtt{dooutput}\left(v\right) & = & \mbox{see note}\\
\mathtt{newobj} & = & \lambda\left\langle V,OM,T\right\rangle .\left\langle \left\langle V,OM\left[n\mapsto\phi\right],T\right\rangle ,OBJ_{n}\right\rangle \ \mbox{where}\ n=N\left(OM\right)\\
\mathtt{call}\left(\left\langle FP_{n},C\right\rangle ,p,t,\_\right) & = & \lambda f,s,\left\langle V,OM,T\right\rangle .\begin{cases}
\begin{gathered}\left\langle \left\langle V,OM',T\right\rangle ,s',r\right\rangle \ \mbox{where}\ \left\langle \left\langle V',OM',T'\right\rangle ,s',r\right\rangle =\\
f\ n\ \left\langle \left[param_{n,k}\mapsto\left[C|p\right]_{k}\right],OM,t\right\rangle \ s
\end{gathered}
 & N\left(C\right)+N\left(p\right)=arity_{n}\\
\left\langle \left\langle V,OM,T\right\rangle ,s,\left\langle FP_{n},\left[C|p\right]\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \mbox{perform binary operation between two constants}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
Note that we largely omit IO operation, since it is not a major concern
 of this paper.
 It is trivial to add another element to the state vector to take account
 of IO operations.
\begin_inset Caption

\begin_layout Plain Layout
Concrete functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "concfunc"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstract domain
\end_layout

\end_inset

We define an abstract domain of an abstract state, 
\begin_inset Formula $AState$
\end_inset

 as following:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
AState & = & \left\langle AVars,AObjMem,AThis,CurriedVals\right\rangle \\
P & = & \left\{ Number,Boolean\right\} \\
Obj & = & \left\{ OBJ_{n}\mid n\in\left\{ 0\right\} \cup\mathbb{N}\right\} \\
FunPointers & = & \left\langle FP_{n},\left[\wp\left(P\cup Obj\cup\left\{ FP_{n}\right\} \cup\left\{ \left\langle FC,n,c,eid\right\rangle \right\} \right)\right]\right\rangle \\
AVal & = & P\cup Obj\cup FunPointers\\
AVars & = & id\rightarrow\wp\left(AVal\right)\\
AObjMem & = & n\rightarrow AVars\\
AThis & = & \wp\left(Obj\right)\\
CurriedVals & = & \left\langle n,c,eid\right\rangle \rightarrow\left[\wp\left(P\cup Obj\cup\left\{ \left\langle FC,n,c,eid\right\rangle \right\} \right)\right]\\
 &  & \mbox{where \emph{n} is a function identifier \emph{c}}\\
 &  & \ \ c\mbox{ is a natural number}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset Formula $OBJ_{n}$
\end_inset

:
\end_layout

\begin_layout Standard
We number each of the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expressions as we parse the program.
 The number n corresponds to the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 expression number.
\end_layout

\begin_layout Standard
In 
\begin_inset Formula $\left\langle FC,n,c,eid\right\rangle $
\end_inset

:
\end_layout

\begin_layout Standard
n = function number
\end_layout

\begin_layout Standard
c = number of arguments curried
\end_layout

\begin_layout Standard
eid = A uid of an expression from which this value has been produced
\end_layout

\end_deeper
\begin_layout Example
\begin_inset Argument
status open

\begin_layout Plain Layout
Currying loop
\end_layout

\end_inset

 Consider the following SDTL program.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

function foo(a,b) {
\end_layout

\begin_layout Plain Layout

	return a;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x = 0;
\end_layout

\begin_layout Plain Layout

while(input < 30) {
\end_layout

\begin_layout Plain Layout

	x = foo(x);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, in line 7, x is associated with a value 
\begin_inset Formula $\left\langle FP_{1},a\mapsto\left\{ Number,\left\langle FC,1,1,e_{1}\right\rangle \right\} \right\rangle $
\end_inset

 where 
\begin_inset Formula $e_{1}$
\end_inset

 is the eid of 
\begin_inset Formula $\mathtt{foo\left(x\right);}$
\end_inset

 in line 7.
 
\begin_inset Formula $\nu$
\end_inset

 has one entry 
\begin_inset Formula $\left\langle 1,1,e_{1}\right\rangle \mapsto\left\{ a\mapsto\left\{ 0,\left\langle FC,1,1,e_{1}\right\rangle \right\} \right\} $
\end_inset


\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Finiteness of the abstract property
\end_layout

\end_inset

Given an SDTL program,
\begin_inset Formula $AState$
\end_inset

 has a finite domain
\end_layout

\begin_layout Proof
We show that each of the component 
\begin_inset Formula $AVars,AObjMem,AThis,CurriedVals$
\end_inset

 has a finite domain
\end_layout

\begin_deeper
\begin_layout Enumerate
First, we show that the number of possible
\begin_inset Formula $AVal$
\end_inset

 is finite.
\end_layout

\begin_deeper
\begin_layout Enumerate
Trivially,
\begin_inset Formula $P$
\end_inset

 is a set of two elements.
\end_layout

\begin_layout Enumerate
There are finite number of 
\emph on
new
\emph default
 expressions in a program.
 Therefore number of elements in 
\begin_inset Formula $Obj$
\end_inset

 is finite.
\end_layout

\begin_layout Enumerate
In case of 
\emph on
FunPointers
\end_layout

\begin_deeper
\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
There are a finite number of function declarations.
 Each function can only have a set number of parameters.
 There are a finite number of expressions in a program.
 Therefore, number of possible values of
\begin_inset Formula $\left\langle FC,n,c,eid\right\rangle $
\end_inset

is finite.
\end_layout

\begin_layout Enumerate
Each functions have a set number of accepted parameters.
 Therefore, the number of elements in the list is finite.
\end_layout

\begin_layout Enumerate
There are only a finite number of function declarations in a program.
\end_layout

\begin_layout Enumerate
Hence, 
\emph on
FunPointers
\emph default
 has a finite domain
\end_layout

\end_deeper
\begin_layout Enumerate
Then, 
\begin_inset Formula $AVal$
\end_inset

, a union of finite domains, also has a finite domain.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AVars$
\end_inset

 is a composite of two components: 
\emph on
id
\emph default
 and 
\begin_inset Formula $\wp\left(AVal\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
There are only a finite number of identifiers appearing in a program
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AVal$
\end_inset

 has a finite domain.
 Therefore, a powerset of it also has a finite domain.
\end_layout

\end_deeper
\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $AObjMem$
\end_inset

 has two components, finiteness of which are argued in 1 (b) and 2 respectively.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AThis$
\end_inset

 is a finite as it is a powerset of a finite domain (1 (b))
\end_layout

\begin_layout Enumerate
\begin_inset Formula $CurriedVals$
\end_inset

 has two components: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left\langle n,c,eid\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left[\wp\left(P\cup Obj\cup\left\{ \left\langle FC,n,c,eid\right\rangle \right\} \right)\right]$
\end_inset

.
 Finiteness of both are argued in 1 (c).
\end_layout

\end_deeper
\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Partial ordering
\end_layout

\end_inset

We define a partial ordering 
\begin_inset Formula $\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqsubseteq\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle $
\end_inset

 between abstract environments as thus:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula 
\begin{gather*}
\sigma_{1}\sqsubseteq\sigma_{2}\ \mbox{if}\ \forall id\in\mbox{domain}\left(\sigma_{1}\right),\sigma_{1}\left(id\right)\subseteq\sigma_{2}\left(id\right)\\
\alpha_{1}\sqsubseteq\alpha_{2}\ \mbox{if}\ \forall n\in\mbox{domain}\left(\alpha_{1}\right),\alpha_{1}\left(n\right)\sqsubseteq\alpha_{2}\left(n\right)\\
\tau_{1}\sqsubseteq\tau_{2}\ \mbox{if}\ \tau_{1}\subseteq\tau_{2}\\
\nu_{1}\sqsubseteq\nu_{2}\ \mbox{if}\ \forall\left\langle n,c,eid\right\rangle \in\mbox{domain}\left(\nu_{1}\right)\\
\ \ \forall k\in\left\{ 1,2,3,\ldots,c\right\} ,\nu_{1}\left(\left\langle n,c,eid\right\rangle \right)_{k}\subseteq\nu_{2}\left(\left\langle n,c,eid\right\rangle \right)_{k}\\
\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqsubseteq\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle \equiv\\
\ \ \sigma_{1}\sqsubseteq\sigma_{2}\wedge\alpha_{1}\sqsubseteq\alpha_{2}\wedge\tau_{1}\sqsubseteq\tau_{2}\wedge\nu_{1}\sqsubseteq\nu_{2}
\end{gather*}

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
We define a union between two abstract environments.
\end_layout

\begin_layout Theorem
Given two abstract environments 
\begin_inset Formula $\eta_{1}=\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \ \mbox{and}\ \eta_{2}=\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle $
\end_inset

, we can find an upper bound by finding the value of 
\begin_inset Formula $\eta_{1}\sqcup\eta_{2}$
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\begin{gather*}
\sigma_{1}\sqcup\sigma_{2}=id\mapsto\sigma_{1}\left(id\right)\cup\sigma_{2}\left(id\right)\\
\alpha_{1}\sqcup\alpha_{2}=n\mapsto\sigma_{1}\left(n\right)\sqcup\sigma_{2}\left(n\right)\\
\tau_{1}\sqcup\tau_{2}=\tau_{1}\cup\tau_{2}\\
\nu_{1}\sqcup\nu_{2}=c\mapsto\nu_{1}\left(c\right)\cup\nu_{2}\left(c\right)\\
\left\langle \sigma_{1},\alpha_{1},\tau_{1},\nu_{1}\right\rangle \sqcup\left\langle \sigma_{2},\alpha_{2},\tau_{2},\nu_{2}\right\rangle \equiv\\
\ \ \left\langle \sigma_{1}\sqcup\sigma_{2},\alpha_{1}\sqcup\alpha_{2},\tau_{1}\sqcup\tau_{2},\nu_{1}\sqcup\nu_{2}\right\rangle 
\end{gather*}

\end_inset


\end_layout

\begin_layout Proof
Satisfying each lines of conditions gives an environment that can satisfy
 conditions set for the partial ordering of both environments.
\end_layout

\begin_layout Proof
Observe that if there is an upper bound 
\begin_inset Formula $\eta'=\left\langle \sigma',\alpha',\tau',\nu'\right\rangle $
\end_inset

 of two environments 
\begin_inset Formula $\eta_{1}$
\end_inset

 and 
\begin_inset Formula $\eta_{2}$
\end_inset

, if 
\begin_inset Formula $\eta'\sqsubseteq\eta_{1}\sqcup\eta_{2}$
\end_inset

 then necessarily 
\begin_inset Formula $\eta'=\eta_{1}\sqcup\eta_{2}$
\end_inset

, since any missing elements in keys and values of 
\begin_inset Formula $\sigma',\alpha',\tau',\nu'$
\end_inset

 will violate the partial ordering condition.
\end_layout

\begin_layout Lemma
\begin_inset Formula $\left(AState,\sqsubseteq\right)$
\end_inset

 is a chain complete partial ordering.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset

 We define abstract functions in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "absfun"

\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray*}
\mathtt{isterm}\left(v,s\right) & = & \lambda f,\eta.\begin{cases}
s\ f\ \eta & v=\left\{ Void\right\} \\
\left(s\ f\ \eta\right)\sqcup\left(I_{\rho}\ v\right) & Void\in v,N\left(v\right)>1\\
I_{\rho}\ v & \mbox{otherwise}\left(\mbox{i.e.}\ Void\notin v\right)
\end{cases}\\
\mathtt{cond}\left(v,s_{1},s_{2}\right) & = & \lambda f,\eta.\left(s_{1}\ f\ \eta\right)\sqcup\left(s_{2}\ f\ \eta\right)\\
\mathtt{asg}\left(id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \sigma\left[id=v\right],\alpha,\tau,\nu\right\rangle \\
\mathtt{val}\left(id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\sigma\left(id\right)\\
\mathtt{get}\left(n,id\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\{ \alpha\left(x\right)\mid OBJ_{x}\in n\right\} \\
\mathtt{set}\left(n,id,v\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \sigma,\left\{ x\mid{OBJ_{x}\in\alpha,x=\begin{cases}
\alpha\left(x\right)\left[id\mapsto v\right] & OBJ_{x}\in n\\
\alpha\left(x\right) & \mbox{otherwise}
\end{cases}}\right\} ,\tau,\nu\right\rangle \\
\mathtt{conval}\left(con\right) & = & \begin{cases}
Number & con\in\mathbb{N}\\
Boolean & con\in\left\{ true,false\right\} 
\end{cases}\\
\mathtt{obj}\left(j\right) & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\alpha\left(j\right)\\
\mathtt{getthis} & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\tau\\
\mathtt{getinput} & = & \lambda\eta.\left\langle \eta,\left\{ Number\right\} \right\rangle \\
\mathtt{dooutput}\left(v\right) & = & \lambda\eta.\eta\\
\mathtt{newobj} & = & \lambda\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\left\langle \left\langle \sigma,\alpha\left[n\mapsto\phi\right],\tau,\nu\right\rangle ,OBJ_{n},\nu\right\rangle \ \mbox{where}\ n=N\left(\alpha\right)\\
\mathtt{call}\left(n,p,t,e\right) & = & \lambda f,s,\left\langle \sigma,\alpha,\tau,\nu\right\rangle .\underset{\left\langle FP_{x},C\right\rangle \in n}{\bigsqcup}\mathtt{scall}\left(\left\langle FP_{x},C\right\rangle ,p,t,f,\left\langle \sigma,\alpha,\tau,\nu\right\rangle ,s,e\right)\\
{\scriptstyle \mathtt{scall}\left(\left\langle FP_{n},C\right\rangle ,p,t,f,\left\langle \sigma,\alpha,\tau,\nu\right\rangle ,s,e\right)} & = & \begin{cases}
\begin{gathered}\left\langle \left\langle \sigma,\alpha',\tau,\nu'\right\rangle ,s',r'\right\rangle \ \mbox{where}\ \left\langle \left\langle \sigma',\alpha',\tau'\right\rangle ,s',r,\nu'\right\rangle =\\
f\ n\ \left\langle \left\{ param_{n,k}\mapsto\left[C|p\right]_{k}\right\} ,\alpha,\tau,\nu\right\rangle \ s
\end{gathered}
 & N\left(C\right)+N\left(p\right)=arity_{n}\\
\left\langle \left\langle \sigma,\alpha,\tau,\nu\left[\left\langle e,n,N\left(C\right)+N\left(p\right)\right\rangle \mapsto\left[C|p\right]\right]\right\rangle ,s,\left\langle FP_{n},\left[C|p\right],e\right\rangle \right\rangle  & \mbox{otherwise}
\end{cases}\\
\mathtt{bin}\left(binop,c_{0},c_{1}\right) & = & \begin{cases}
\left\{ Number\right\}  & binop\in\left\{ '+','-','*','/'\right\} \\
\left\{ Boolean\right\}  & \mbox{otherwise}
\end{cases}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Abstract functions
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "absfun"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:mono"

\end_inset

Abstract functions produce monotonic lambda functions
\end_layout

\begin_layout Proof
Following list of arguments cover all the functions:
\end_layout

\begin_deeper
\begin_layout Enumerate
Observe that for the functions calculating values from given parameters
 and an environment, an increase in the environment implies that the values
 we obtain are also increased.
 This is from the definition of the partial ordering.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an increase
 in the environment implies an increase in the updated environment.
\end_layout

\begin_layout Enumerate
In case of 
\begin_inset Formula $\mathtt{call}$
\end_inset

, its the least upper bound of results from 
\begin_inset Formula $\mathtt{scall}$
\end_inset

, which falls into categories 1 and 2.
 An increase in the results implies increase in the least upper bound of
 them.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
From theorems 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:bindmono"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:mono"

\end_inset

 give the following important lemma:
\end_layout

\begin_layout Lemma
Abstract 
\begin_inset Formula $\mathcal{S},\mathcal{E}\ \mbox{and}\ \mathcal{L}$
\end_inset

 are monotonic functions.
\end_layout

\begin_layout Standard
Then, it stands to reason that fixed points exist for our analytic framework.
\end_layout

\begin_layout Lemma
Fixed points exist for an abstract 
\begin_inset Formula $\mathcal{F}$
\end_inset


\end_layout

\begin_layout Standard
Now we turn to examine the relationship between concrete and abstract domain.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction
\end_layout

\end_inset

 We define an abstraction relation between concrete and abstract environments,
 
\begin_inset Formula $\left\langle \sigma,\alpha,\tau,\nu\right\rangle \succ\left\langle V,OM,T\right\rangle $
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
\left\langle \sigma,\alpha,\tau,\nu\right\rangle \succ\left\langle V,OM,T\right\rangle \ \mbox{iff}\ \\
\ \ \forall id\in V\exists a\in\sigma\left(id\right),a\succ V\left(id\right)\mbox{ and }\tau\succ T\\
\forall z\in\mathbb{Z},\left\{ Number\right\} \succ z\\
\forall b\in\left\{ True,False\right\} ,\left\{ Boolean\right\} \succ b\\
OBJ_{m}\succ OBJ_{n}\ \mbox{if}\ \eta\vdash OBJ_{m}\succ OM\vdash OBJ_{n}\\
\left\langle FP_{m},\left[c'\right],e\right\rangle \succ\left\langle FP_{n},\left[c\right]\right\rangle \ \mbox{if}\ m=n\ \\
\ \ N\left(c\right)=N\left(c'\right)\ \mbox{and}\ \forall c_{k}\in c,\eta\vdash c'_{k}\succ c_{k}
\end{gather*}

\end_inset


\end_layout

\begin_layout Definition
In turn, contextual definitions of abstract object and function pointer
 values are defined as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
\left\langle \sigma,\alpha,\tau,\nu\right\rangle \vdash OBJ_{m}\succ OBJ_{n}\mbox{ if }\\
\forall id\in OM\left(n\right),OM\left(n\right)\left(id\right)\in Z\cup\left\{ True,False\right\} ,\\
\ \ \alpha\left(m\right)\left(id\right)\succ OM\left(n\right)\left(id\right)\\
\forall id\in OM\left(n\right),OM\left(n\right)\left(id\right)=OBJ_{x},\alpha\left(m\right)=OBJ_{y},\\
\ \ \alpha\left(y\right)\succ OBJ_{x}
\end{gather*}

\end_inset


\end_layout

\begin_layout Standard
We now define abstraction and concretisation relations between an abstract
 domain and a powerset of concrete domain.
\end_layout

\begin_layout Definition
\begin_inset Argument
status open

\begin_layout Plain Layout
Abstraction and concretisation
\end_layout

\end_inset

 We define abstraction function 
\begin_inset Formula $P$
\end_inset

 and concretisation function 
\begin_inset Formula $Q$
\end_inset

 as following:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\begin{gather*}
P:\wp\left(CState\right)\rightarrow AState\\
P\left(r\right)=\bigsqcup\left\{ \eta|\rho\in r,\eta\succ\rho\right\} \\
Q:AState\rightarrow\wp\left(CState\right)\\
Q\left(\eta\right)=\left\{ r|r\in\rho,\eta\succ\rho\right\} 
\end{gather*}

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:galois"

\end_inset


\begin_inset Argument
status open

\begin_layout Plain Layout
Galois connection
\end_layout

\end_inset


\begin_inset Formula $\left(P,Q\right)$
\end_inset

 forms a Galois connection between 
\begin_inset Formula $\left(AState,\sqsubseteq\right)$
\end_inset

 and
\begin_inset Formula $\left(\wp\left(CState\right),\subseteq\right)$
\end_inset


\end_layout

\begin_layout Standard
For the simplicity of argument, without losing generality, we lift abstract
 functions to produce a lambda function of the type 
\begin_inset Formula $\left(State\times StateCol\right)\rightarrow\left(State\times StateCol\times a\right)$
\end_inset

.
 Now we turn to argue isomorphism.
\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Isomorphism
\end_layout

\end_inset

For all abstract and concrete functions, the following holds true: when
 
\begin_inset Formula $F\left(n_{c},id_{c},v_{c},p_{c},t_{c},e_{c},j_{c}\right)=f,f\left(s_{a},\rho\right)=\left\langle s_{c}',\rho',V_{C}\right\rangle ,G\left(n_{a},id_{a},v_{a},p_{a},t_{a},e_{a},j_{a}\right)=g,g\left(s_{a},\eta\right)=\left\langle s_{a}',\eta',V_{A}\right\rangle $
\end_inset

 
\end_layout

\begin_layout Theorem
\begin_inset Formula 
\begin{multline*}
\left(\begin{array}{ccc}
\eta\vdash n_{a} & \succ & \rho\vdash n_{c}\\
id_{a} & = & id_{c}\\
\eta\vdash v_{a} & \succ & \rho\vdash v_{c}\\
\eta\vdash p_{a,k} & \succ & \rho\vdash p_{c,k}\mbox{ for all\ }k\\
\eta\vdash t_{a} & \succ & \rho\vdash t_{c}\\
e_{a} & = & \rho\vdash e_{c}\\
\eta\vdash OBJ_{j_{a}} & \succ & \rho\vdash OBJ_{j_{c}}
\end{array}\right)\implies\\
\left(\left\langle s_{a},\eta\right\rangle \succ\left\langle s_{c},\rho\right\rangle \implies\left\langle s_{a}',\eta',V_{A}\right\rangle \succ\left\langle s_{c}'\rho',V_{C}\right\rangle \right)
\end{multline*}

\end_inset


\end_layout

\begin_layout Theorem
(ignoring conditions set for parameters that the function is not taking)
\end_layout

\begin_layout Proof
As with 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:mono"

\end_inset

, we categorise our discussion as following:
\end_layout

\begin_deeper
\begin_layout Enumerate
Observe that for the functions calculating values from given parameters
 and an environment, isomorphicity between parameters and given environments
 implies isomorphicity of the results.
\end_layout

\begin_layout Enumerate
For the functions that are updating environment, observe that an isomorphicity
 between given environments and between parameters imply an isomorphicity
 in the updated environments.
\end_layout

\begin_layout Enumerate
In case of 
\begin_inset Formula $\mathtt{call}$
\end_inset

, its the least upper bound of results from 
\begin_inset Formula $\mathtt{scall}$
\end_inset

, which falls into categories 1 and 2.
 Given Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:galois"

\end_inset

, when 
\begin_inset Formula $\mathtt{scall}$
\end_inset

 functions are isomorphic, then so are 
\begin_inset Formula $\mathtt{call}$
\end_inset

 functions.
\end_layout

\end_deeper
\begin_layout Standard
These theorems together with the properties of bind operator give rise to
 an important lemma in proving the correctness of the analysis.
 That is:
\end_layout

\begin_layout Lemma
Abstract 
\begin_inset Formula $\mathcal{F},\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 and concrete 
\begin_inset Formula $\mathcal{F},\mathcal{S},\mathcal{E},\mathcal{L}$
\end_inset

 are isomorphic.
\end_layout

\begin_layout Standard
Now we are ready to produce the main thesis.
\end_layout

\begin_layout Theorem
\begin_inset Argument
status open

\begin_layout Plain Layout
Correctness of the analysis
\end_layout

\end_inset

 Given an SDTL program, 
\end_layout

\begin_layout Theorem
If 
\begin_inset Formula $\mathcal{F}\ 0\ \left\langle \phi,\left\{ 0\mapsto\phi\right\} ,OBJ_{0}\right\rangle \ \phi=\rho'\ S_{C}$
\end_inset

 and 
\begin_inset Formula $\mathcal{F}\ 0\ \left\langle \phi,\left\{ 0\mapsto\phi\right\} ,\left\{ OBJ_{0}\right\} ,\phi\right\rangle \ \phi=\eta'\ S_{A}$
\end_inset

 then 
\begin_inset Formula $S_{C}$
\end_inset

 and 
\begin_inset Formula $S_{A}$
\end_inset

 are related in the following manner:
\end_layout

\begin_layout Theorem
\begin_inset Formula $\forall sid\in P,\exists\rho_{0},\rho_{1},\rho_{0}\times\rho_{1}\in S_{A}\left(sid\right)\rightarrow\exists\eta_{0},\eta_{1},\eta_{0}\times\eta_{1}\in S_{A}\left(sid\right)\wedge\eta_{0}\succ\rho_{0}\wedge\eta_{1}\succ\rho_{1}$
\end_inset

 where 
\begin_inset Formula $P$
\end_inset

 is set of all statement IDs in the program.
\end_layout

\begin_layout Proof
Recall the isomorphicity between abstract and concrete functions.
 If there is a state collected in the concrete result, then it is implied
 that an abstraction of such state is collected in an abstract result.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "duck"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
